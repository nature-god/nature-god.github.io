{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/new-vno/source/css/vno.styl","path":"css/vno.styl","modified":1,"renderable":1},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/new-vno/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/new-vno/source/images/Unity.png","path":"images/Unity.png","modified":1,"renderable":1},{"_id":"themes/new-vno/source/images/zhihu.png","path":"images/zhihu.png","modified":1,"renderable":1},{"_id":"themes/new-vno/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/new-vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/new-vno/source/images/kunka.jpg","path":"images/kunka.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/new-vno/LICENSE","hash":"f2701e7ce147a3a18df85df7a8fa8922a8b6d3fe","modified":1551058606836},{"_id":"themes/new-vno/README.md","hash":"b5e5262014f01e0ac29283602b26060a1e97a774","modified":1551058606837},{"_id":"themes/new-vno/_config.yml","hash":"669f241558350dc596c28606fad4051243999b74","modified":1551058606838},{"_id":"source/_posts/C#Delegate_Event.md","hash":"b45dd28ce8ddbd7d22f37f59b77963a16e9bcc78","modified":1551058606826},{"_id":"source/_posts/Qt5_QGLViewer.md","hash":"3856b142ace5e4242ce61c28a20bc3519c6e9114","modified":1551062772593},{"_id":"source/_posts/a_FirstBlog.md","hash":"2bc36a2e142a06a736d38dfa8e7a152e1aee421c","modified":1551058606827},{"_id":"source/_posts/b_Dota2_thinking.md","hash":"c74a1d0c2804768be1e6e6bc594dd784947dd75f","modified":1551058606828},{"_id":"source/_posts/c_LearningPlan.md","hash":"ca02dbbe55c131181687d11f813673ad34b8fb20","modified":1551058606829},{"_id":"source/_posts/d_shaderLearning01.md","hash":"750591f471646652eab63dac035da242dcf42134","modified":1551058606830},{"_id":"source/_posts/d_shaderLearning02.md","hash":"2657bd99866b8edab3b395177621be7f49841ed9","modified":1551058606831},{"_id":"source/_posts/e_TextAdventureGame.md","hash":"e7be7bd555e72d0143bc00bdc5ac1654400c04dc","modified":1551058606832},{"_id":"source/_posts/f_HorribleGameFeeling.md","hash":"14140fa74be220a6365a1c7de052155dd4ab1041","modified":1551058606833},{"_id":"source/_posts/g_HorribleGameThinking.md","hash":"965f8aa82e5e5b1c3b01d6b50d0cbe86b5e50363","modified":1551058606833},{"_id":"source/_posts/h_UnityAndC#.md","hash":"45e73dad10164f57d86c8b07249227e4952c2eb5","modified":1551058606834},{"_id":"source/_posts/i_2048Game.md","hash":"19f85949006e72f26d5505cf8fe67822bde7d1c1","modified":1551058793511},{"_id":"themes/new-vno/languages/default.yml","hash":"c737a170ef93e7a81922ad7563243d3acc728a08","modified":1551058606840},{"_id":"themes/new-vno/languages/ja.yml","hash":"ef7500623287c335fa6b5aa71ae618afc13ff376","modified":1551058606840},{"_id":"themes/new-vno/languages/zh-CN.yml","hash":"6b78f3e68abc9da2030fe6ad0d42f8b2090bb122","modified":1551058606841},{"_id":"themes/new-vno/layout/index.ejs","hash":"30b062b6f576a9aac4bc1261303e26bcac2e60bd","modified":1551058606857},{"_id":"themes/new-vno/layout/layout.ejs","hash":"18860daff3412f0b7986be8d634871fa35755903","modified":1551058606858},{"_id":"themes/new-vno/layout/page.ejs","hash":"151f64ae7e65aa0c8c1de8e369d2b29756a3561a","modified":1551058606858},{"_id":"themes/new-vno/layout/post.ejs","hash":"a576ba91d342214c5dfc2aa1719e3e890cba623d","modified":1551058606859},{"_id":"themes/new-vno/layout/_partial/date.ejs","hash":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1551058606845},{"_id":"themes/new-vno/layout/_partial/baidu_tongji.ejs","hash":"a83ae1c0b55af1dc18121ab9689e07ab5e306b32","modified":1551058606843},{"_id":"themes/new-vno/layout/_partial/comments.ejs","hash":"1eeac8d784fec20f1beba0edb2e2c01e3dbea965","modified":1551058606844},{"_id":"themes/new-vno/layout/_partial/head.ejs","hash":"69b39a43cbc69ee03b966fb53dd85a4b00172b49","modified":1551058606848},{"_id":"themes/new-vno/layout/_partial/google_analytics.ejs","hash":"caa29f45a76e4c062f56c65b12d88038d5943674","modified":1551058606847},{"_id":"themes/new-vno/layout/_partial/footer.ejs","hash":"889c11701069ec1d58296028d0cb7a794d84d17e","modified":1551058606846},{"_id":"themes/new-vno/layout/_partial/mathjax.ejs","hash":"5216bd244749719b04deff50fd2d564e4e1dd17d","modified":1551058606849},{"_id":"themes/new-vno/layout/_partial/read-more.ejs","hash":"0fbc39cb8ec08b1c2d71533e70cdc9b51e09c568","modified":1551058606851},{"_id":"themes/new-vno/layout/_partial/side-panel.ejs","hash":"1d9287298609f0f9e4aa226b49386d7d80b93be6","modified":1551058606852},{"_id":"themes/new-vno/layout/_partial/social.ejs","hash":"ee656864470554ba2dbee1621fa12e139eef794d","modified":1551058606853},{"_id":"themes/new-vno/layout/_partial/tags.ejs","hash":"c7bff65dec927f903945e846eab7eba977c6d52e","modified":1551058606854},{"_id":"themes/new-vno/source/css/_variables.styl","hash":"60ca2ff4c5fd15adeb51f88a69854a9b63703586","modified":1551058606864},{"_id":"themes/new-vno/source/css/vno.styl","hash":"8ea87fdf51c19cec59800c4f99330c19e7c02c1e","modified":1551058606865},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1551058606869},{"_id":"themes/new-vno/source/images/avatar.jpg","hash":"aac5fa3721bdeffaeae22e0d331690fad591c182","modified":1551058606882},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1551058606878},{"_id":"themes/new-vno/source/images/Unity.png","hash":"6fd916bafca2e1ef173bc135b828663d37aff01d","modified":1551058606880},{"_id":"themes/new-vno/source/images/zhihu.png","hash":"9cb32fc90c59496459420e79928a13ee948ad9b3","modified":1551058606889},{"_id":"themes/new-vno/source/js/main.js","hash":"7b946e9b76ca21e34002f66c9ae704e7f5845c2a","modified":1551058606892},{"_id":"themes/new-vno/source/css/_animate.styl","hash":"651fcf046b1bd2bff3ab4cb8947ff7fe058de373","modified":1551058606862},{"_id":"themes/new-vno/source/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1551058606868},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1551058606876},{"_id":"themes/new-vno/source/css/_partial/highlight.styl","hash":"05da1b8f4859761dc60bca40b8682f167e350742","modified":1551058606863},{"_id":"themes/new-vno/source/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1551058606874},{"_id":"themes/new-vno/source/images/kunka.jpg","hash":"e80c816a8b9abae5f506ee24c79edc23a16441d2","modified":1551058606886},{"_id":"public/2019/02/25/Qt5_QGLViewer/index.html","hash":"8d53c1e7d4f2121883c918da1f1313f56c9b3ccb","modified":1551353985332},{"_id":"public/2018/12/20/i_2048Game/index.html","hash":"24b542a06fb74ba799946d0d84db840775388ad8","modified":1551353985332},{"_id":"public/2018/12/20/h_UnityAndC#/index.html","hash":"f597a8f0016b740b7a62e1ab490edce249a5b2e2","modified":1551353985333},{"_id":"public/2018/11/13/g_HorribleGameThinking/index.html","hash":"257098425d2544ba1b92247474f1f9411e8276c5","modified":1551353985333},{"_id":"public/2018/11/12/f_HorribleGameFeeling/index.html","hash":"b8f57a39ec604287dc8883c9efb65d8fe35e30f7","modified":1551353985333},{"_id":"public/2018/11/12/e_TextAdventureGame/index.html","hash":"ce6e4ba6129c1c9f3250d53a16e1dbe838d43e0b","modified":1551353985333},{"_id":"public/2018/11/09/c_LearningPlan/index.html","hash":"f100845d36624ae05b6479fa7045c1d5775ae3d9","modified":1551353985333},{"_id":"public/2018/11/09/b_Dota2_thinking/index.html","hash":"058d1b85aefea858c375cd1ab3423f7394ccbb0e","modified":1551353985334},{"_id":"public/2018/11/08/a_FirstBlog/index.html","hash":"45fcd3dc123e38d60d79e234f0b0c119e61cdb1f","modified":1551353985334},{"_id":"public/archives/page/2/index.html","hash":"1f31c73e339a5a6673cc4ae1889dea171cf4ada1","modified":1551353985334},{"_id":"public/archives/2018/page/2/index.html","hash":"49f42fdd88445e16d5b467532ccca688cf463a35","modified":1551353985334},{"_id":"public/archives/2018/12/index.html","hash":"5d93be57baab6b3550e41c680941eba9fc2bf5c0","modified":1551353985334},{"_id":"public/archives/2019/index.html","hash":"c019101df5ae072eb5f405605ca414b712e757cb","modified":1551353985334},{"_id":"public/archives/2019/02/index.html","hash":"c019101df5ae072eb5f405605ca414b712e757cb","modified":1551353985334},{"_id":"public/page/2/index.html","hash":"71b896fd3bf9113aa7ee8692dfe04ebe5a3bb2f0","modified":1551353985334},{"_id":"public/tags/Unity/index.html","hash":"f5a9050fc03fafd048faffca332309adfcddef5a","modified":1551353985335},{"_id":"public/tags/随笔/index.html","hash":"832d85d0b6a101a7f1b6e09ff887017dc4619663","modified":1551353985335},{"_id":"public/tags/Qt/index.html","hash":"c019101df5ae072eb5f405605ca414b712e757cb","modified":1551353985335},{"_id":"public/tags/游戏杂谈/index.html","hash":"02229a2b63c72e68adc30e059712311793bc8041","modified":1551353985335},{"_id":"public/tags/学习/index.html","hash":"26184041704b585a8a45006475157aa5ae5054b2","modified":1551353985335},{"_id":"public/tags/游戏观后感/index.html","hash":"1885d85880c7c319f369399c1a6dd3b0c980bad0","modified":1551353985335},{"_id":"public/tags/Unity-Shader/index.html","hash":"b879aa7e7744039a252fb1b9c6bbfe5384f633b7","modified":1551353985335},{"_id":"public/2018/11/22/C#Delegate_Event/index.html","hash":"111f9b337029a5c0a2e136833f9c3db89265495a","modified":1551353985335},{"_id":"public/2018/11/15/d_shaderLearning02/index.html","hash":"d7f6ba058a9b1743cdd4e3c0bf8815b8be60d4d0","modified":1551353985335},{"_id":"public/2018/11/09/d_shaderLearning01/index.html","hash":"3f79aa12fba330fea75969809c9abddea198c1c5","modified":1551353985335},{"_id":"public/archives/index.html","hash":"513ae70b4272e077bc96b574b5b0ef9b60ab973b","modified":1551353985336},{"_id":"public/archives/2018/index.html","hash":"52cbdafc3756629aa9d4e6a02870ef44c8624740","modified":1551353985336},{"_id":"public/archives/2018/11/index.html","hash":"0f511579ba271caf50a6c62dbb6e626f0d4fc45f","modified":1551353985336},{"_id":"public/index.html","hash":"9a49e143d01914fa1d4eccfacf044c9d29061de4","modified":1551353985336},{"_id":"public/images/avatar.jpg","hash":"aac5fa3721bdeffaeae22e0d331690fad591c182","modified":1551353985356},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1551353985356},{"_id":"public/images/zhihu.png","hash":"9cb32fc90c59496459420e79928a13ee948ad9b3","modified":1551353985356},{"_id":"public/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath%20Dere1.mtn","hash":"11f7cbf6068937965aeda4a3ebbce3fba58a0495","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath%20Dere2.mtn","hash":"b1b280ba08365d986a219f843601d478802c84af","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath%20Dere3.mtn","hash":"421f00d9b263eb1ba5ae7744d3e36b874f3574cd","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath1.mtn","hash":"8b9830960269c57540f235550b662bd8bb2eb9e7","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath2.mtn","hash":"2f1d687ac155865af6176d77e0ec6f4a4d29071b","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath3.mtn","hash":"848c2740a0b824a53c592c8052ce06453b1ca346","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath4.mtn","hash":"e046b214762c0cf59d41c5a794aa0f48ebbfadab","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath5.mtn","hash":"df45551eb085bd60ec0da2aa053bf50d362f8f98","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath6.mtn","hash":"222e9801e2394950398c4904897b5ad89244f429","modified":1551353985357},{"_id":"public/live2dw/assets/motions/Breath7.mtn","hash":"cbab9298b360f3548e2365813ec0ed95ab111135","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Breath8.mtn","hash":"366b357fb26bcc39ed3f6d397f280d0e6381be0c","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Fail.mtn","hash":"ee758e7fc4f7080de4576b05ad685834c995ac47","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Sleeping.mtn","hash":"14371217f96d56b7920c89e8336aa19d2dc1b457","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Success.mtn","hash":"fb2c6350010c0841598d645e354fb8f301e21593","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Sukebei1.mtn","hash":"7baa2802152d82bba7eb0edb31b0ddc054d85180","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Sukebei2.mtn","hash":"d684cbcc31e794dae0cecd6d940167ae372f946f","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Sukebei3.mtn","hash":"deb7994cc055443e6287b0e983351efa46129326","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Touch%20Dere1.mtn","hash":"408960c3b98c4d43c30e33cd3d8c34a24b96fdc5","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Touch%20Dere2.mtn","hash":"a6e1c2437d0280b59d9f937fca7e5957a0fbb9d2","modified":1551353985358},{"_id":"public/live2dw/assets/motions/Touch%20Dere3.mtn","hash":"9f4f5ed6831fb262afbabc9536c87262fa10c471","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch%20Dere4.mtn","hash":"e556a3618d394848488b056561d7219b8dd6b086","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch%20Dere5.mtn","hash":"340ee5d25c44de3d899e5d42e93a140207e820e2","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch%20Dere6.mtn","hash":"1dbc118605f33ec4e0e82dee60499d69ef07a741","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch1.mtn","hash":"9089e535269648f14d45edee01d108cd9c93fcf6","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch3.mtn","hash":"ccf97daf9208ea25865fc409bfdc713be31e41f7","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch2.mtn","hash":"b6c6c3022aae612d4f0ce7cd59f99db1f6241a43","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch4.mtn","hash":"21925fa7aac4003a10a7cd46006cfa9b13374ff9","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch5.mtn","hash":"19bd0390dc69b28437a908373895dccf2bb8d7eb","modified":1551353985359},{"_id":"public/live2dw/assets/motions/Touch6.mtn","hash":"3bb0a1a1fe5dc13146fb4347f3b408f496280898","modified":1551353985360},{"_id":"public/live2dw/assets/motions/WakeUp.mtn","hash":"8778f42f1ce509ca2fc4a385db96a4976f44647e","modified":1551353985361},{"_id":"public/live2dw/assets/poi.model.json","hash":"56ada9d23487305e8f423bfe36869026208ffee8","modified":1551353985362},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"6e013af9c502b2e63ac5e42944e3244f8f515eb7","modified":1551353985362},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1551353985373},{"_id":"public/images/Unity.png","hash":"6fd916bafca2e1ef173bc135b828663d37aff01d","modified":1551353985375},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1551353985375},{"_id":"public/live2dw/assets/model.moc","hash":"0f883ea279bda9133028124003b11c7f3edf20bb","modified":1551353985377},{"_id":"public/js/main.js","hash":"43e748aeb132037e27b27d8d1279a4b838d97b38","modified":1551353985393},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"7d3a9c937317b9c15f2c3a872f0e26607a729458","modified":1551353985393},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"5e7669733ecd0b1bc3881d2cf7fcc01e2990a07d","modified":1551353985393},{"_id":"public/css/vno.css","hash":"caac6e934d40178864bfc7d9e57952a4d83b0e6b","modified":1551353986802},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1551353986802},{"_id":"public/live2dw/assets/textures/pajamas-costume.png","hash":"a0bf4a08335eeee7fb68a372c91d91372c8d08ec","modified":1551353986961},{"_id":"public/images/kunka.jpg","hash":"e80c816a8b9abae5f506ee24c79edc23a16441d2","modified":1551353987049},{"_id":"public/live2dw/assets/textures/school-costume.png","hash":"77f79821d879f5027c950de3adedf5b8fb4b2904","modified":1551353987067},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"09521263ecc625a246b3406c385300e99e966a2e","modified":1551353987110},{"_id":"public/live2dw/assets/textures/default-costume.png","hash":"badeb207fa62b28ae3b4cc8a3e9ad06d873f4808","modified":1551353987321}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Unity委托简单使用","date":"2018-11-21T16:00:00.000Z","_content":"在C/C++体系中，回调(callback)函数是十分重要的一个部分，以前用cocos2d或是其他一些windows相关的编程，很多地方都要用到类似的回调函数。在C#中，它同样是十分重要的。回调函数实际上是方法调用的指针，也称为函数指针，是一个十分强大的函数特性，同样也是C/C++体系最难的一部分。.NET以委托的形式实现了函数指针的概念，它们之间的区别在于，.NET委托是类型安全的。这说明，C中的函数指针是一个指向存储单元的指针，我们无法说明这个指针实际指向的是什么，更不用说参数和返回类型了。\n#### 委托\n什么是委托，通俗的来讲，就是将方法\"委托\"给另一个\"对象\"来执行。我们都知道函数的写法，在参数列表中可以传入参数，而委托则是不过是将其参数变成传入方法罢了。依旧是考虑我们游戏编程中可能遇到的一个实际性的需求：血量变化。\n>假设这里有一个玩家控制的角色Player，其拥有当前生命值属性CurrentHealth，最大生命值属性MaxHealth，在UI层面，我们有一个血条UI，要求这个血条UI随着当前生命值的变化而进行长短与颜色的变化。\n* CurrentHealth > 0.5*MaxHealth 血条颜色变成绿色\n* 0.2*MaxHealth< CurrentHealth < 0.5*MaxHealth 血条颜色要变成黄色\n* 0 < CurrentHealth < 0.1*MaxHealth 血条变成红色\n\n这是一个很常见常见的需求，大家有做血条设计时有很大可能会遇到该需求,最简单的可能就是弄一个函数，每次有有血量值变化时就调用：\n```C\nvoid CurrentHealthChange(float _health)\n{\n    CurrentHealth = _health;\n    //血条长度变化\n    //血条颜色变化\n}\n\n//调用方式\nPlayer.CurrentHealthChange(250.0f);\n```\n简单易懂，很好的实现了需求，未来有新的变化就直接往这个函数加内容就好了。\n<br/>但是啊，这看上去很Low，而且未来如果新增属性：魔法值显示，体力值显示等问题的话，这个Player会变的很大，维护很困难——至少你会觉得写的不好，没有美感不是么？而且由于血条逻辑直接写在了该函数内，与UI层连接很紧密，未来每次UI层有变化，这边的代码逻辑也都需要进行变化。那好，我们现在换种方式：<br/>\n<br/>不用delegate，我们可以用set/get访问器属性来解决这个问题:\n```C\npublic class Player\n{\n    private float currentHealth;\n    private float maxHealth;\n    // accessors \n    public float CurrentHealth\n    {\n        set\n        {\n            currentHealth = value;\n            //血条长度变化代码\n            //血条颜色变化代码\n            //if(value < 0.5*MaxHalth)\n            //...\n        }\n        get\n        {\n            return currentHealth;\n        }\n    }\n    public float MaxHealth\n    {\n        set\n        {\n            maxHealth = value;\n        }\n        get\n        {\n            return maxHealth;\n        }\n    }\n}\n\n```\n这样，我们只要每次进行\n```C\nPlayer.CurrentHealth -= 950.0f;\n```\n这样的指令操作，就能进行UI相关的逻辑变化了！这个看上去好了不少，至少比较直观，血条逻辑代码似乎也看上去很不错？但是实际上它不过比上面方法的形式好了那么一点点，只不过是\"看上去\"厉害了一些。这依旧与UI层的耦合很紧密，我们追求的是松耦合，即一个模块的代码变化应该尽可能小地影响其他模块。这是代码编程地艺术，也是设计模式追求的简洁清晰与易扩展。<br/>\n<br/>这个时候，就是我们的委托(delegate)出场的时候了。\n<br/>先来简单介绍一下委托的基本结构与语法。在C#中使用一个类时，分两个阶段——首先要先定义这个类，即告诉编译器这个类由哪些成员变量与方法所组成。然后实例化类的一个对象。委托也是这样，首先要定义一个委托，然后创建该委托的一个或多个实例：\n```C\ndelegate void NumChange(float changeNum);\n```\n这就是定义好了一个委托NumChange，它带有一个参数changeNum，返回类型为void。可见，我们给出了该委托的几乎所有细节：它要什么参数，返回什么值——因此它们的类型安全非常高。因此声明一个委托就跟一个函数声明类似，不过前面加了一个delegate的关键字罢了。此外与类相似的，委托也有访问级别：public，private，protected等。\n>注意，实际上，定义一个委托是指定义一个新类。委托实现为派生自基类System.MulticastDelegate，而System.MylticastDelegate又派生自基类System.Delegate。\n\n我们称呼类的实例为\"对象\"，但是委托的实例还是叫做\"委托\"，下面请根据上下文理解此处委托是指委托还是委托的实例啊。接下来我们就可以使用委托了。首先我们定义两个函数，一个用于血条长度控制，一个用于颜色控制：\n```C\nvoid HealthSliderController(float num)\n{\n    //血条长度逻辑\n}\nvoid HealthColorController(float num)\n{\n    //血条颜色控制\n}\n```\n然后我们实例化一个委托对象，并赋初值\n```C\npublic NumChange HealthNumChange;\nHealthNumChange = HealthSliderController;\nHealthNUmChange += HealthColorController;\n```\n调用委托\n```C\nHealthNumChange(500.0f);\n```\n这样就实现了同时调用多个方法的效果。这就是简单的委托用法，后续的魔法值，体力值逻辑我们依旧可以照葫芦画瓢就行，后续血条变化而引起的更多的UI逻辑，我们也可以再写函数新加入委托之中即可，无需对原有代码进行修改。在C#与Unity中的委托写法有点不同，另外委托可以直接使用匿名函数的方式进行赋值。","source":"_posts/C#Delegate_Event.md","raw":"---\ntitle: Unity委托简单使用\ndate: 2018-11-22\ntag: Unity\n---\n在C/C++体系中，回调(callback)函数是十分重要的一个部分，以前用cocos2d或是其他一些windows相关的编程，很多地方都要用到类似的回调函数。在C#中，它同样是十分重要的。回调函数实际上是方法调用的指针，也称为函数指针，是一个十分强大的函数特性，同样也是C/C++体系最难的一部分。.NET以委托的形式实现了函数指针的概念，它们之间的区别在于，.NET委托是类型安全的。这说明，C中的函数指针是一个指向存储单元的指针，我们无法说明这个指针实际指向的是什么，更不用说参数和返回类型了。\n#### 委托\n什么是委托，通俗的来讲，就是将方法\"委托\"给另一个\"对象\"来执行。我们都知道函数的写法，在参数列表中可以传入参数，而委托则是不过是将其参数变成传入方法罢了。依旧是考虑我们游戏编程中可能遇到的一个实际性的需求：血量变化。\n>假设这里有一个玩家控制的角色Player，其拥有当前生命值属性CurrentHealth，最大生命值属性MaxHealth，在UI层面，我们有一个血条UI，要求这个血条UI随着当前生命值的变化而进行长短与颜色的变化。\n* CurrentHealth > 0.5*MaxHealth 血条颜色变成绿色\n* 0.2*MaxHealth< CurrentHealth < 0.5*MaxHealth 血条颜色要变成黄色\n* 0 < CurrentHealth < 0.1*MaxHealth 血条变成红色\n\n这是一个很常见常见的需求，大家有做血条设计时有很大可能会遇到该需求,最简单的可能就是弄一个函数，每次有有血量值变化时就调用：\n```C\nvoid CurrentHealthChange(float _health)\n{\n    CurrentHealth = _health;\n    //血条长度变化\n    //血条颜色变化\n}\n\n//调用方式\nPlayer.CurrentHealthChange(250.0f);\n```\n简单易懂，很好的实现了需求，未来有新的变化就直接往这个函数加内容就好了。\n<br/>但是啊，这看上去很Low，而且未来如果新增属性：魔法值显示，体力值显示等问题的话，这个Player会变的很大，维护很困难——至少你会觉得写的不好，没有美感不是么？而且由于血条逻辑直接写在了该函数内，与UI层连接很紧密，未来每次UI层有变化，这边的代码逻辑也都需要进行变化。那好，我们现在换种方式：<br/>\n<br/>不用delegate，我们可以用set/get访问器属性来解决这个问题:\n```C\npublic class Player\n{\n    private float currentHealth;\n    private float maxHealth;\n    // accessors \n    public float CurrentHealth\n    {\n        set\n        {\n            currentHealth = value;\n            //血条长度变化代码\n            //血条颜色变化代码\n            //if(value < 0.5*MaxHalth)\n            //...\n        }\n        get\n        {\n            return currentHealth;\n        }\n    }\n    public float MaxHealth\n    {\n        set\n        {\n            maxHealth = value;\n        }\n        get\n        {\n            return maxHealth;\n        }\n    }\n}\n\n```\n这样，我们只要每次进行\n```C\nPlayer.CurrentHealth -= 950.0f;\n```\n这样的指令操作，就能进行UI相关的逻辑变化了！这个看上去好了不少，至少比较直观，血条逻辑代码似乎也看上去很不错？但是实际上它不过比上面方法的形式好了那么一点点，只不过是\"看上去\"厉害了一些。这依旧与UI层的耦合很紧密，我们追求的是松耦合，即一个模块的代码变化应该尽可能小地影响其他模块。这是代码编程地艺术，也是设计模式追求的简洁清晰与易扩展。<br/>\n<br/>这个时候，就是我们的委托(delegate)出场的时候了。\n<br/>先来简单介绍一下委托的基本结构与语法。在C#中使用一个类时，分两个阶段——首先要先定义这个类，即告诉编译器这个类由哪些成员变量与方法所组成。然后实例化类的一个对象。委托也是这样，首先要定义一个委托，然后创建该委托的一个或多个实例：\n```C\ndelegate void NumChange(float changeNum);\n```\n这就是定义好了一个委托NumChange，它带有一个参数changeNum，返回类型为void。可见，我们给出了该委托的几乎所有细节：它要什么参数，返回什么值——因此它们的类型安全非常高。因此声明一个委托就跟一个函数声明类似，不过前面加了一个delegate的关键字罢了。此外与类相似的，委托也有访问级别：public，private，protected等。\n>注意，实际上，定义一个委托是指定义一个新类。委托实现为派生自基类System.MulticastDelegate，而System.MylticastDelegate又派生自基类System.Delegate。\n\n我们称呼类的实例为\"对象\"，但是委托的实例还是叫做\"委托\"，下面请根据上下文理解此处委托是指委托还是委托的实例啊。接下来我们就可以使用委托了。首先我们定义两个函数，一个用于血条长度控制，一个用于颜色控制：\n```C\nvoid HealthSliderController(float num)\n{\n    //血条长度逻辑\n}\nvoid HealthColorController(float num)\n{\n    //血条颜色控制\n}\n```\n然后我们实例化一个委托对象，并赋初值\n```C\npublic NumChange HealthNumChange;\nHealthNumChange = HealthSliderController;\nHealthNUmChange += HealthColorController;\n```\n调用委托\n```C\nHealthNumChange(500.0f);\n```\n这样就实现了同时调用多个方法的效果。这就是简单的委托用法，后续的魔法值，体力值逻辑我们依旧可以照葫芦画瓢就行，后续血条变化而引起的更多的UI逻辑，我们也可以再写函数新加入委托之中即可，无需对原有代码进行修改。在C#与Unity中的委托写法有点不同，另外委托可以直接使用匿名函数的方式进行赋值。","slug":"C#Delegate_Event","published":1,"updated":"2019-02-25T01:36:46.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v1o0000l8v6qp9kmk88","content":"<p>在C/C++体系中，回调(callback)函数是十分重要的一个部分，以前用cocos2d或是其他一些windows相关的编程，很多地方都要用到类似的回调函数。在C#中，它同样是十分重要的。回调函数实际上是方法调用的指针，也称为函数指针，是一个十分强大的函数特性，同样也是C/C++体系最难的一部分。.NET以委托的形式实现了函数指针的概念，它们之间的区别在于，.NET委托是类型安全的。这说明，C中的函数指针是一个指向存储单元的指针，我们无法说明这个指针实际指向的是什么，更不用说参数和返回类型了。</p>\n<h4 id=\"委托\"><a href=\"#委托\" class=\"headerlink\" title=\"委托\"></a>委托</h4><p>什么是委托，通俗的来讲，就是将方法”委托”给另一个”对象”来执行。我们都知道函数的写法，在参数列表中可以传入参数，而委托则是不过是将其参数变成传入方法罢了。依旧是考虑我们游戏编程中可能遇到的一个实际性的需求：血量变化。</p>\n<blockquote>\n<p>假设这里有一个玩家控制的角色Player，其拥有当前生命值属性CurrentHealth，最大生命值属性MaxHealth，在UI层面，我们有一个血条UI，要求这个血条UI随着当前生命值的变化而进行长短与颜色的变化。</p>\n<ul>\n<li>CurrentHealth &gt; 0.5*MaxHealth 血条颜色变成绿色</li>\n<li>0.2<em>MaxHealth&lt; CurrentHealth &lt; 0.5</em>MaxHealth 血条颜色要变成黄色</li>\n<li>0 &lt; CurrentHealth &lt; 0.1*MaxHealth 血条变成红色</li>\n</ul>\n</blockquote>\n<p>这是一个很常见常见的需求，大家有做血条设计时有很大可能会遇到该需求,最简单的可能就是弄一个函数，每次有有血量值变化时就调用：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CurrentHealthChange</span><span class=\"params\">(<span class=\"keyword\">float</span> _health)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CurrentHealth = _health;</span><br><span class=\"line\">    <span class=\"comment\">//血条长度变化</span></span><br><span class=\"line\">    <span class=\"comment\">//血条颜色变化</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用方式</span></span><br><span class=\"line\">Player.CurrentHealthChange(<span class=\"number\">250.0f</span>);</span><br></pre></td></tr></table></figure></p>\n<p>简单易懂，很好的实现了需求，未来有新的变化就直接往这个函数加内容就好了。<br><br>但是啊，这看上去很Low，而且未来如果新增属性：魔法值显示，体力值显示等问题的话，这个Player会变的很大，维护很困难——至少你会觉得写的不好，没有美感不是么？而且由于血条逻辑直接写在了该函数内，与UI层连接很紧密，未来每次UI层有变化，这边的代码逻辑也都需要进行变化。那好，我们现在换种方式：<br><br><br>不用delegate，我们可以用set/get访问器属性来解决这个问题:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> currentHealth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> maxHealth;</span><br><span class=\"line\">    <span class=\"comment\">// accessors </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> CurrentHealth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            currentHealth = value;</span><br><span class=\"line\">            <span class=\"comment\">//血条长度变化代码</span></span><br><span class=\"line\">            <span class=\"comment\">//血条颜色变化代码</span></span><br><span class=\"line\">            <span class=\"comment\">//if(value &lt; 0.5*MaxHalth)</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        get</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> currentHealth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> MaxHealth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            maxHealth = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        get</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxHealth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们只要每次进行<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Player.CurrentHealth -= <span class=\"number\">950.0f</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样的指令操作，就能进行UI相关的逻辑变化了！这个看上去好了不少，至少比较直观，血条逻辑代码似乎也看上去很不错？但是实际上它不过比上面方法的形式好了那么一点点，只不过是”看上去”厉害了一些。这依旧与UI层的耦合很紧密，我们追求的是松耦合，即一个模块的代码变化应该尽可能小地影响其他模块。这是代码编程地艺术，也是设计模式追求的简洁清晰与易扩展。<br><br><br>这个时候，就是我们的委托(delegate)出场的时候了。<br><br>先来简单介绍一下委托的基本结构与语法。在C#中使用一个类时，分两个阶段——首先要先定义这个类，即告诉编译器这个类由哪些成员变量与方法所组成。然后实例化类的一个对象。委托也是这样，首先要定义一个委托，然后创建该委托的一个或多个实例：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">delegate <span class=\"keyword\">void</span> <span class=\"title\">NumChange</span><span class=\"params\">(<span class=\"keyword\">float</span> changeNum)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>这就是定义好了一个委托NumChange，它带有一个参数changeNum，返回类型为void。可见，我们给出了该委托的几乎所有细节：它要什么参数，返回什么值——因此它们的类型安全非常高。因此声明一个委托就跟一个函数声明类似，不过前面加了一个delegate的关键字罢了。此外与类相似的，委托也有访问级别：public，private，protected等。</p>\n<blockquote>\n<p>注意，实际上，定义一个委托是指定义一个新类。委托实现为派生自基类System.MulticastDelegate，而System.MylticastDelegate又派生自基类System.Delegate。</p>\n</blockquote>\n<p>我们称呼类的实例为”对象”，但是委托的实例还是叫做”委托”，下面请根据上下文理解此处委托是指委托还是委托的实例啊。接下来我们就可以使用委托了。首先我们定义两个函数，一个用于血条长度控制，一个用于颜色控制：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HealthSliderController</span><span class=\"params\">(<span class=\"keyword\">float</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//血条长度逻辑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HealthColorController</span><span class=\"params\">(<span class=\"keyword\">float</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//血条颜色控制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们实例化一个委托对象，并赋初值<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> NumChange HealthNumChange;</span><br><span class=\"line\">HealthNumChange = HealthSliderController;</span><br><span class=\"line\">HealthNUmChange += HealthColorController;</span><br></pre></td></tr></table></figure></p>\n<p>调用委托<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HealthNumChange(<span class=\"number\">500.0f</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了同时调用多个方法的效果。这就是简单的委托用法，后续的魔法值，体力值逻辑我们依旧可以照葫芦画瓢就行，后续血条变化而引起的更多的UI逻辑，我们也可以再写函数新加入委托之中即可，无需对原有代码进行修改。在C#与Unity中的委托写法有点不同，另外委托可以直接使用匿名函数的方式进行赋值。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在C/C++体系中，回调(callback)函数是十分重要的一个部分，以前用cocos2d或是其他一些windows相关的编程，很多地方都要用到类似的回调函数。在C#中，它同样是十分重要的。回调函数实际上是方法调用的指针，也称为函数指针，是一个十分强大的函数特性，同样也是C/C++体系最难的一部分。.NET以委托的形式实现了函数指针的概念，它们之间的区别在于，.NET委托是类型安全的。这说明，C中的函数指针是一个指向存储单元的指针，我们无法说明这个指针实际指向的是什么，更不用说参数和返回类型了。</p>\n<h4 id=\"委托\"><a href=\"#委托\" class=\"headerlink\" title=\"委托\"></a>委托</h4><p>什么是委托，通俗的来讲，就是将方法”委托”给另一个”对象”来执行。我们都知道函数的写法，在参数列表中可以传入参数，而委托则是不过是将其参数变成传入方法罢了。依旧是考虑我们游戏编程中可能遇到的一个实际性的需求：血量变化。</p>\n<blockquote>\n<p>假设这里有一个玩家控制的角色Player，其拥有当前生命值属性CurrentHealth，最大生命值属性MaxHealth，在UI层面，我们有一个血条UI，要求这个血条UI随着当前生命值的变化而进行长短与颜色的变化。</p>\n<ul>\n<li>CurrentHealth &gt; 0.5*MaxHealth 血条颜色变成绿色</li>\n<li>0.2<em>MaxHealth&lt; CurrentHealth &lt; 0.5</em>MaxHealth 血条颜色要变成黄色</li>\n<li>0 &lt; CurrentHealth &lt; 0.1*MaxHealth 血条变成红色</li>\n</ul>\n</blockquote>\n<p>这是一个很常见常见的需求，大家有做血条设计时有很大可能会遇到该需求,最简单的可能就是弄一个函数，每次有有血量值变化时就调用：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CurrentHealthChange</span><span class=\"params\">(<span class=\"keyword\">float</span> _health)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CurrentHealth = _health;</span><br><span class=\"line\">    <span class=\"comment\">//血条长度变化</span></span><br><span class=\"line\">    <span class=\"comment\">//血条颜色变化</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//调用方式</span></span><br><span class=\"line\">Player.CurrentHealthChange(<span class=\"number\">250.0f</span>);</span><br></pre></td></tr></table></figure></p>\n<p>简单易懂，很好的实现了需求，未来有新的变化就直接往这个函数加内容就好了。<br><br>但是啊，这看上去很Low，而且未来如果新增属性：魔法值显示，体力值显示等问题的话，这个Player会变的很大，维护很困难——至少你会觉得写的不好，没有美感不是么？而且由于血条逻辑直接写在了该函数内，与UI层连接很紧密，未来每次UI层有变化，这边的代码逻辑也都需要进行变化。那好，我们现在换种方式：<br><br><br>不用delegate，我们可以用set/get访问器属性来解决这个问题:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> currentHealth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> maxHealth;</span><br><span class=\"line\">    <span class=\"comment\">// accessors </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> CurrentHealth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            currentHealth = value;</span><br><span class=\"line\">            <span class=\"comment\">//血条长度变化代码</span></span><br><span class=\"line\">            <span class=\"comment\">//血条颜色变化代码</span></span><br><span class=\"line\">            <span class=\"comment\">//if(value &lt; 0.5*MaxHalth)</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        get</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> currentHealth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">float</span> MaxHealth</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">set</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            maxHealth = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        get</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxHealth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，我们只要每次进行<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Player.CurrentHealth -= <span class=\"number\">950.0f</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样的指令操作，就能进行UI相关的逻辑变化了！这个看上去好了不少，至少比较直观，血条逻辑代码似乎也看上去很不错？但是实际上它不过比上面方法的形式好了那么一点点，只不过是”看上去”厉害了一些。这依旧与UI层的耦合很紧密，我们追求的是松耦合，即一个模块的代码变化应该尽可能小地影响其他模块。这是代码编程地艺术，也是设计模式追求的简洁清晰与易扩展。<br><br><br>这个时候，就是我们的委托(delegate)出场的时候了。<br><br>先来简单介绍一下委托的基本结构与语法。在C#中使用一个类时，分两个阶段——首先要先定义这个类，即告诉编译器这个类由哪些成员变量与方法所组成。然后实例化类的一个对象。委托也是这样，首先要定义一个委托，然后创建该委托的一个或多个实例：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">delegate <span class=\"keyword\">void</span> <span class=\"title\">NumChange</span><span class=\"params\">(<span class=\"keyword\">float</span> changeNum)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>这就是定义好了一个委托NumChange，它带有一个参数changeNum，返回类型为void。可见，我们给出了该委托的几乎所有细节：它要什么参数，返回什么值——因此它们的类型安全非常高。因此声明一个委托就跟一个函数声明类似，不过前面加了一个delegate的关键字罢了。此外与类相似的，委托也有访问级别：public，private，protected等。</p>\n<blockquote>\n<p>注意，实际上，定义一个委托是指定义一个新类。委托实现为派生自基类System.MulticastDelegate，而System.MylticastDelegate又派生自基类System.Delegate。</p>\n</blockquote>\n<p>我们称呼类的实例为”对象”，但是委托的实例还是叫做”委托”，下面请根据上下文理解此处委托是指委托还是委托的实例啊。接下来我们就可以使用委托了。首先我们定义两个函数，一个用于血条长度控制，一个用于颜色控制：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HealthSliderController</span><span class=\"params\">(<span class=\"keyword\">float</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//血条长度逻辑</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HealthColorController</span><span class=\"params\">(<span class=\"keyword\">float</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//血条颜色控制</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后我们实例化一个委托对象，并赋初值<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> NumChange HealthNumChange;</span><br><span class=\"line\">HealthNumChange = HealthSliderController;</span><br><span class=\"line\">HealthNUmChange += HealthColorController;</span><br></pre></td></tr></table></figure></p>\n<p>调用委托<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HealthNumChange(<span class=\"number\">500.0f</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样就实现了同时调用多个方法的效果。这就是简单的委托用法，后续的魔法值，体力值逻辑我们依旧可以照葫芦画瓢就行，后续血条变化而引起的更多的UI逻辑，我们也可以再写函数新加入委托之中即可，无需对原有代码进行修改。在C#与Unity中的委托写法有点不同，另外委托可以直接使用匿名函数的方式进行赋值。</p>\n"},{"title":"陈酿","date":"2018-11-08T10:54:25.000Z","_content":"自打进入大学以来，一直有想着要写点什么东西出来...\n<br>四年前刚刚走进大学校园，对未来生活还是有着诸多美好的愿景的。从物理到如今的软件，私以为这是自己十分明智的选择——至少现在学习的东西是自己比较感兴趣的。高中三年实在磨去了我对基础数理化的兴趣而感到疲倦了，但软件这些东西终究还是吸引着我的。\n<br>自小便比较喜欢玩电子游戏，半夜起来偷玩电脑，偷摸去电玩厅这种事我从初中一直干到高中...大学调剂进了物理，确实感到绝望过一段时间，不想学而且对前途感到无比迷茫。大一一次体育课上见到了软院同学们的C++课设大作业——用cocos2d做的飞机大战...我知道那便是我的阿瓦隆了。万幸在同济转专业比较容易（不像其他高校的年级前几才能转），期末电磁学考试我写完所有会的题目后，在试卷最后写了个跪求老师让我过的话...物理的老师还是十分仁慈的放我过了...我也因为没有挂科而成功地进入了软院。回想走过来的这一步步真的都是无比惊险，那是2014年，软院转专业收18人左右而报名人数只有15个，所以最后大家都进软院了...前些天听同学们说，17级报名就80+的人数...果然自己还是占了不少便宜的。我不喜欢徐志摩，但比较喜欢他的一句话——“得之，我幸，失之，我命”，此语常在我失败不如意时安慰自己，也常在自己顺利时敲打一下内心。\n<br>进入软院后一切按部就班，我相信自己这么幸运的转专业成功，总归是要做出点什么的，不然真对不起物院了。物院每年转出去的同学都很多，物院老师倒也不刻意挂你，反而会帮你一把。最后班会的时候老师跟我们说，物院转出去多少他们都不太在意，只希望转出去的学生要比在物理时更加优秀就够了。时至今日每每想起，物院的时光都是很快乐的...当然学习有点那么痛苦。软院有着蛮好的俱乐部制度，因为学院远在嘉定，而大一新生都在四平路的本部。所以很多俱乐部的学长学姐会过来教大家一些开发技术什么的，我也在那个时候接触了下Android，IOS（因为没设备，只能听听课），同时也接触了Unity，接触了盛大游戏俱乐部。每周六学长们都会坐车回本部给我们上课，我也一直坚持着全部上完了...因为转专业后少了很多必修课，那学期真的很闲...那学期期末C++大项目依旧是一个用cocos2d开发的游戏，历史的车轮滚滚向前，我也从那个艳羡着吃饼的人，变成吃饼的人了。\n<br>我的第一个游戏是一个魔塔性质的游戏，我加入了无数彩蛋——真的把自己给惊喜的不要不要的。当然最后由于答辩的时间限制，很短暂的展示一下就结束了，之前的存粹自我高潮了，但或许这就是做自己感兴趣的东西吧。大二去了嘉定，继续参加盛大俱乐部的活动，期间也接了艺术于传媒学院的项目，日子平稳又快乐。大三成为了盛大俱乐部主席，也做了点微小的工作，到大四了，又搬回来本部。最后自己也踩着线成功保研本校了，每每回想，真的感觉这一路过来有惊无险，但至少自己不后悔了。\n<br>以前一直没写博客的习惯，但随着自己越发年长而感到愈发健忘，写下点东西总是好的，无论过去与将来，总归自己需要些东西记录下自己曾经存在的痕迹吧。\n<br>2018.11.8 于同济大学","source":"_posts/a_FirstBlog.md","raw":"---\ntitle: 陈酿\ndate: 2018-11-08 18:54:25  \ntags: 随笔\n---\n自打进入大学以来，一直有想着要写点什么东西出来...\n<br>四年前刚刚走进大学校园，对未来生活还是有着诸多美好的愿景的。从物理到如今的软件，私以为这是自己十分明智的选择——至少现在学习的东西是自己比较感兴趣的。高中三年实在磨去了我对基础数理化的兴趣而感到疲倦了，但软件这些东西终究还是吸引着我的。\n<br>自小便比较喜欢玩电子游戏，半夜起来偷玩电脑，偷摸去电玩厅这种事我从初中一直干到高中...大学调剂进了物理，确实感到绝望过一段时间，不想学而且对前途感到无比迷茫。大一一次体育课上见到了软院同学们的C++课设大作业——用cocos2d做的飞机大战...我知道那便是我的阿瓦隆了。万幸在同济转专业比较容易（不像其他高校的年级前几才能转），期末电磁学考试我写完所有会的题目后，在试卷最后写了个跪求老师让我过的话...物理的老师还是十分仁慈的放我过了...我也因为没有挂科而成功地进入了软院。回想走过来的这一步步真的都是无比惊险，那是2014年，软院转专业收18人左右而报名人数只有15个，所以最后大家都进软院了...前些天听同学们说，17级报名就80+的人数...果然自己还是占了不少便宜的。我不喜欢徐志摩，但比较喜欢他的一句话——“得之，我幸，失之，我命”，此语常在我失败不如意时安慰自己，也常在自己顺利时敲打一下内心。\n<br>进入软院后一切按部就班，我相信自己这么幸运的转专业成功，总归是要做出点什么的，不然真对不起物院了。物院每年转出去的同学都很多，物院老师倒也不刻意挂你，反而会帮你一把。最后班会的时候老师跟我们说，物院转出去多少他们都不太在意，只希望转出去的学生要比在物理时更加优秀就够了。时至今日每每想起，物院的时光都是很快乐的...当然学习有点那么痛苦。软院有着蛮好的俱乐部制度，因为学院远在嘉定，而大一新生都在四平路的本部。所以很多俱乐部的学长学姐会过来教大家一些开发技术什么的，我也在那个时候接触了下Android，IOS（因为没设备，只能听听课），同时也接触了Unity，接触了盛大游戏俱乐部。每周六学长们都会坐车回本部给我们上课，我也一直坚持着全部上完了...因为转专业后少了很多必修课，那学期真的很闲...那学期期末C++大项目依旧是一个用cocos2d开发的游戏，历史的车轮滚滚向前，我也从那个艳羡着吃饼的人，变成吃饼的人了。\n<br>我的第一个游戏是一个魔塔性质的游戏，我加入了无数彩蛋——真的把自己给惊喜的不要不要的。当然最后由于答辩的时间限制，很短暂的展示一下就结束了，之前的存粹自我高潮了，但或许这就是做自己感兴趣的东西吧。大二去了嘉定，继续参加盛大俱乐部的活动，期间也接了艺术于传媒学院的项目，日子平稳又快乐。大三成为了盛大俱乐部主席，也做了点微小的工作，到大四了，又搬回来本部。最后自己也踩着线成功保研本校了，每每回想，真的感觉这一路过来有惊无险，但至少自己不后悔了。\n<br>以前一直没写博客的习惯，但随着自己越发年长而感到愈发健忘，写下点东西总是好的，无论过去与将来，总归自己需要些东西记录下自己曾经存在的痕迹吧。\n<br>2018.11.8 于同济大学","slug":"a_FirstBlog","published":1,"updated":"2019-02-25T01:36:46.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v1y0001l8v67r02usqq","content":"<p>自打进入大学以来，一直有想着要写点什么东西出来…<br><br>四年前刚刚走进大学校园，对未来生活还是有着诸多美好的愿景的。从物理到如今的软件，私以为这是自己十分明智的选择——至少现在学习的东西是自己比较感兴趣的。高中三年实在磨去了我对基础数理化的兴趣而感到疲倦了，但软件这些东西终究还是吸引着我的。<br><br>自小便比较喜欢玩电子游戏，半夜起来偷玩电脑，偷摸去电玩厅这种事我从初中一直干到高中…大学调剂进了物理，确实感到绝望过一段时间，不想学而且对前途感到无比迷茫。大一一次体育课上见到了软院同学们的C++课设大作业——用cocos2d做的飞机大战…我知道那便是我的阿瓦隆了。万幸在同济转专业比较容易（不像其他高校的年级前几才能转），期末电磁学考试我写完所有会的题目后，在试卷最后写了个跪求老师让我过的话…物理的老师还是十分仁慈的放我过了…我也因为没有挂科而成功地进入了软院。回想走过来的这一步步真的都是无比惊险，那是2014年，软院转专业收18人左右而报名人数只有15个，所以最后大家都进软院了…前些天听同学们说，17级报名就80+的人数…果然自己还是占了不少便宜的。我不喜欢徐志摩，但比较喜欢他的一句话——“得之，我幸，失之，我命”，此语常在我失败不如意时安慰自己，也常在自己顺利时敲打一下内心。<br><br>进入软院后一切按部就班，我相信自己这么幸运的转专业成功，总归是要做出点什么的，不然真对不起物院了。物院每年转出去的同学都很多，物院老师倒也不刻意挂你，反而会帮你一把。最后班会的时候老师跟我们说，物院转出去多少他们都不太在意，只希望转出去的学生要比在物理时更加优秀就够了。时至今日每每想起，物院的时光都是很快乐的…当然学习有点那么痛苦。软院有着蛮好的俱乐部制度，因为学院远在嘉定，而大一新生都在四平路的本部。所以很多俱乐部的学长学姐会过来教大家一些开发技术什么的，我也在那个时候接触了下Android，IOS（因为没设备，只能听听课），同时也接触了Unity，接触了盛大游戏俱乐部。每周六学长们都会坐车回本部给我们上课，我也一直坚持着全部上完了…因为转专业后少了很多必修课，那学期真的很闲…那学期期末C++大项目依旧是一个用cocos2d开发的游戏，历史的车轮滚滚向前，我也从那个艳羡着吃饼的人，变成吃饼的人了。<br><br>我的第一个游戏是一个魔塔性质的游戏，我加入了无数彩蛋——真的把自己给惊喜的不要不要的。当然最后由于答辩的时间限制，很短暂的展示一下就结束了，之前的存粹自我高潮了，但或许这就是做自己感兴趣的东西吧。大二去了嘉定，继续参加盛大俱乐部的活动，期间也接了艺术于传媒学院的项目，日子平稳又快乐。大三成为了盛大俱乐部主席，也做了点微小的工作，到大四了，又搬回来本部。最后自己也踩着线成功保研本校了，每每回想，真的感觉这一路过来有惊无险，但至少自己不后悔了。<br><br>以前一直没写博客的习惯，但随着自己越发年长而感到愈发健忘，写下点东西总是好的，无论过去与将来，总归自己需要些东西记录下自己曾经存在的痕迹吧。<br><br>2018.11.8 于同济大学</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自打进入大学以来，一直有想着要写点什么东西出来…<br><br>四年前刚刚走进大学校园，对未来生活还是有着诸多美好的愿景的。从物理到如今的软件，私以为这是自己十分明智的选择——至少现在学习的东西是自己比较感兴趣的。高中三年实在磨去了我对基础数理化的兴趣而感到疲倦了，但软件这些东西终究还是吸引着我的。<br><br>自小便比较喜欢玩电子游戏，半夜起来偷玩电脑，偷摸去电玩厅这种事我从初中一直干到高中…大学调剂进了物理，确实感到绝望过一段时间，不想学而且对前途感到无比迷茫。大一一次体育课上见到了软院同学们的C++课设大作业——用cocos2d做的飞机大战…我知道那便是我的阿瓦隆了。万幸在同济转专业比较容易（不像其他高校的年级前几才能转），期末电磁学考试我写完所有会的题目后，在试卷最后写了个跪求老师让我过的话…物理的老师还是十分仁慈的放我过了…我也因为没有挂科而成功地进入了软院。回想走过来的这一步步真的都是无比惊险，那是2014年，软院转专业收18人左右而报名人数只有15个，所以最后大家都进软院了…前些天听同学们说，17级报名就80+的人数…果然自己还是占了不少便宜的。我不喜欢徐志摩，但比较喜欢他的一句话——“得之，我幸，失之，我命”，此语常在我失败不如意时安慰自己，也常在自己顺利时敲打一下内心。<br><br>进入软院后一切按部就班，我相信自己这么幸运的转专业成功，总归是要做出点什么的，不然真对不起物院了。物院每年转出去的同学都很多，物院老师倒也不刻意挂你，反而会帮你一把。最后班会的时候老师跟我们说，物院转出去多少他们都不太在意，只希望转出去的学生要比在物理时更加优秀就够了。时至今日每每想起，物院的时光都是很快乐的…当然学习有点那么痛苦。软院有着蛮好的俱乐部制度，因为学院远在嘉定，而大一新生都在四平路的本部。所以很多俱乐部的学长学姐会过来教大家一些开发技术什么的，我也在那个时候接触了下Android，IOS（因为没设备，只能听听课），同时也接触了Unity，接触了盛大游戏俱乐部。每周六学长们都会坐车回本部给我们上课，我也一直坚持着全部上完了…因为转专业后少了很多必修课，那学期真的很闲…那学期期末C++大项目依旧是一个用cocos2d开发的游戏，历史的车轮滚滚向前，我也从那个艳羡着吃饼的人，变成吃饼的人了。<br><br>我的第一个游戏是一个魔塔性质的游戏，我加入了无数彩蛋——真的把自己给惊喜的不要不要的。当然最后由于答辩的时间限制，很短暂的展示一下就结束了，之前的存粹自我高潮了，但或许这就是做自己感兴趣的东西吧。大二去了嘉定，继续参加盛大俱乐部的活动，期间也接了艺术于传媒学院的项目，日子平稳又快乐。大三成为了盛大俱乐部主席，也做了点微小的工作，到大四了，又搬回来本部。最后自己也踩着线成功保研本校了，每每回想，真的感觉这一路过来有惊无险，但至少自己不后悔了。<br><br>以前一直没写博客的习惯，但随着自己越发年长而感到愈发健忘，写下点东西总是好的，无论过去与将来，总归自己需要些东西记录下自己曾经存在的痕迹吧。<br><br>2018.11.8 于同济大学</p>\n"},{"title":"Qt5 QtCreator QGLViewer","date":"2019-02-24T16:00:00.000Z","_content":"\n \n\n毕设设计可能要做一个与雷达可视化相关的项目，学长给了我一份之前的Qt的项目来看看，因为以前一直只听说过Qt，其怎么怎么样，怎么怎么好用，但实际上却从来都并未使用过。因此正好开坑记录一下Qt的学习。\n\n### Qt\n\nQt，发音同“cute”，是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱(widget toolkits)。同时它也可以用于开发非GUI程序，比如控制台工具和服务器。Qt使用于OPIE，Skype，VLC media player，Adobe Photoshop Elements，VirtualBox与Mathematica以及被Autodesk，欧洲空间局，梦工厂，Google，HP，KDE，卢卡斯，西门子公司等所使用。\n\n它是Digia公司的产品，使用标准C++和特殊的代码生成扩展(被称为元对象编译器)以及一些宏。通过语言绑定，其他的编程语言也可以使用Qt。\n\nQt是自由开放源码的软件，在GNU宽通用公共许可证（LGPL）条款下发布。所有版本都支持广泛的编译器，包括GCC的C++编译器与Visual Studio。\n\n### Qt的安装 \n\n前往[Qt官网](https://www.qt.io/cn)下载Qt，注册一个账号，然后下载下来一个在线安装程序，点击进入安装界面\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/02.png\" />\n\n安装路径等不用说(注意不能有中文路径)，默认选择安装Qt Creator，比较重要的是选择组件这一步：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_install.png\"/> \n\n(之前我就点了个默认就没管了，然后在Qt Creator里面死活找不到Kit)，这里我选的Qt5的版本，Qt4与Qt5之间差别还是比较大的，但是既然是学习，肯定选择最新的版本了（我选的Qt 5.12.0)。<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/01.png\"/>\n\n然后是开发编译工具：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/03.png\"/>\n\n然后静待安装完成。\n\n### QGLViewer\n\n[libQGLViewer](http://libqglviewer.com/)是一个Qt的C++库，用于简化创建OpenGl 3D图像。它提供了一些非常典型的3D视图功能，包括像用鼠标移动相机，坐标轴显示，物体选择等功能。基于Qt工具包，它支持所有平台，其有商业许可，但也可用作开源软件开发。\n\nQGLViewer在上面的官网就可以下到了，官网内也详细写明了各个不同的平台该如何进行操作。我是Windows，所以下载好QGLViewer的项目后，解压后打开QGLVIewer/QGLViewer.pro项目文件(使用Qt Creator，其他工具方式详见官网)，然后点击左下角那个锤子进行构建。一般可以正确运行，如果失败的话，检查一下自己之前安装的kit是否错误，在Qt Creator上面菜单选择：工具->选项，打开后选择Kit，看是否有错误。\n\n在运行完毕之后，会得到两个dll文件：QGLViewer2.dll和QGLViewer2.dll。将其拷贝至C:\\Windows\\System32文件内，或是在要使用的项目路径下直接添加这两个dll。\n\n此时可以尝试跑一下example，就在QGLViewer文件的example文件内，可以看到QGLViewer的一些比较基本的功能演示。\n\n之后调用该库时，也可以在.pro项目文件中添加如下设置：\n\n> ```\n> TARGET = myViewer\n> CONFIG *= qt opengl release\n> QT *= opengl xml\n> \n> HEADERS = myViewer.h\n> SOURCES = myViewer.cpp main.cpp\n> \n> # Windows\n> INCLUDEPATH *= C:/Users/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -LC:/Users/login/Documents/libQGLViewer-2.7.1/QGLViewer -lQGLViewer2\n> \n> # Linux\n> INCLUDEPATH *= /home/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -L/home/login/libQGLViewer-2.7.1/QGLViewer -lQGLViewer\n> \n> # Mac \n> INCLUDEPATH *= /Users/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -F/Users/login/Library/Frameworks -framework QGLViewer\n> ```\n\n但是由于Qt5内部封装了Opengl的一些函数，如果你自己电脑之前也装过Opengl的相关东西的话，可能导致编译后链接库失败，此时可以在.pro文件中添加：\n\n>```\n>win32-g++ {\n>    LIBS += -lopengl32\n>}\n>win32-msvc*{\n>    LIBS += opengl32.lib\n>}\n>```\n\n即可编译成功。","source":"_posts/Qt5_QGLViewer.md","raw":"---\ntitle: Qt5 QtCreator QGLViewer\ndate: 2019-2-25\ntag: Qt \n---\n\n \n\n毕设设计可能要做一个与雷达可视化相关的项目，学长给了我一份之前的Qt的项目来看看，因为以前一直只听说过Qt，其怎么怎么样，怎么怎么好用，但实际上却从来都并未使用过。因此正好开坑记录一下Qt的学习。\n\n### Qt\n\nQt，发音同“cute”，是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱(widget toolkits)。同时它也可以用于开发非GUI程序，比如控制台工具和服务器。Qt使用于OPIE，Skype，VLC media player，Adobe Photoshop Elements，VirtualBox与Mathematica以及被Autodesk，欧洲空间局，梦工厂，Google，HP，KDE，卢卡斯，西门子公司等所使用。\n\n它是Digia公司的产品，使用标准C++和特殊的代码生成扩展(被称为元对象编译器)以及一些宏。通过语言绑定，其他的编程语言也可以使用Qt。\n\nQt是自由开放源码的软件，在GNU宽通用公共许可证（LGPL）条款下发布。所有版本都支持广泛的编译器，包括GCC的C++编译器与Visual Studio。\n\n### Qt的安装 \n\n前往[Qt官网](https://www.qt.io/cn)下载Qt，注册一个账号，然后下载下来一个在线安装程序，点击进入安装界面\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/02.png\" />\n\n安装路径等不用说(注意不能有中文路径)，默认选择安装Qt Creator，比较重要的是选择组件这一步：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_install.png\"/> \n\n(之前我就点了个默认就没管了，然后在Qt Creator里面死活找不到Kit)，这里我选的Qt5的版本，Qt4与Qt5之间差别还是比较大的，但是既然是学习，肯定选择最新的版本了（我选的Qt 5.12.0)。<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/01.png\"/>\n\n然后是开发编译工具：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/03.png\"/>\n\n然后静待安装完成。\n\n### QGLViewer\n\n[libQGLViewer](http://libqglviewer.com/)是一个Qt的C++库，用于简化创建OpenGl 3D图像。它提供了一些非常典型的3D视图功能，包括像用鼠标移动相机，坐标轴显示，物体选择等功能。基于Qt工具包，它支持所有平台，其有商业许可，但也可用作开源软件开发。\n\nQGLViewer在上面的官网就可以下到了，官网内也详细写明了各个不同的平台该如何进行操作。我是Windows，所以下载好QGLViewer的项目后，解压后打开QGLVIewer/QGLViewer.pro项目文件(使用Qt Creator，其他工具方式详见官网)，然后点击左下角那个锤子进行构建。一般可以正确运行，如果失败的话，检查一下自己之前安装的kit是否错误，在Qt Creator上面菜单选择：工具->选项，打开后选择Kit，看是否有错误。\n\n在运行完毕之后，会得到两个dll文件：QGLViewer2.dll和QGLViewer2.dll。将其拷贝至C:\\Windows\\System32文件内，或是在要使用的项目路径下直接添加这两个dll。\n\n此时可以尝试跑一下example，就在QGLViewer文件的example文件内，可以看到QGLViewer的一些比较基本的功能演示。\n\n之后调用该库时，也可以在.pro项目文件中添加如下设置：\n\n> ```\n> TARGET = myViewer\n> CONFIG *= qt opengl release\n> QT *= opengl xml\n> \n> HEADERS = myViewer.h\n> SOURCES = myViewer.cpp main.cpp\n> \n> # Windows\n> INCLUDEPATH *= C:/Users/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -LC:/Users/login/Documents/libQGLViewer-2.7.1/QGLViewer -lQGLViewer2\n> \n> # Linux\n> INCLUDEPATH *= /home/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -L/home/login/libQGLViewer-2.7.1/QGLViewer -lQGLViewer\n> \n> # Mac \n> INCLUDEPATH *= /Users/login/Documents/libQGLViewer-2.7.1\n> LIBS *= -F/Users/login/Library/Frameworks -framework QGLViewer\n> ```\n\n但是由于Qt5内部封装了Opengl的一些函数，如果你自己电脑之前也装过Opengl的相关东西的话，可能导致编译后链接库失败，此时可以在.pro文件中添加：\n\n>```\n>win32-g++ {\n>    LIBS += -lopengl32\n>}\n>win32-msvc*{\n>    LIBS += opengl32.lib\n>}\n>```\n\n即可编译成功。","slug":"Qt5_QGLViewer","published":1,"updated":"2019-02-25T02:46:12.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v240003l8v6l2ru25ac","content":"<p>毕设设计可能要做一个与雷达可视化相关的项目，学长给了我一份之前的Qt的项目来看看，因为以前一直只听说过Qt，其怎么怎么样，怎么怎么好用，但实际上却从来都并未使用过。因此正好开坑记录一下Qt的学习。</p>\n<h3 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h3><p>Qt，发音同“cute”，是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱(widget toolkits)。同时它也可以用于开发非GUI程序，比如控制台工具和服务器。Qt使用于OPIE，Skype，VLC media player，Adobe Photoshop Elements，VirtualBox与Mathematica以及被Autodesk，欧洲空间局，梦工厂，Google，HP，KDE，卢卡斯，西门子公司等所使用。</p>\n<p>它是Digia公司的产品，使用标准C++和特殊的代码生成扩展(被称为元对象编译器)以及一些宏。通过语言绑定，其他的编程语言也可以使用Qt。</p>\n<p>Qt是自由开放源码的软件，在GNU宽通用公共许可证（LGPL）条款下发布。所有版本都支持广泛的编译器，包括GCC的C++编译器与Visual Studio。</p>\n<h3 id=\"Qt的安装\"><a href=\"#Qt的安装\" class=\"headerlink\" title=\"Qt的安装\"></a>Qt的安装</h3><p>前往<a href=\"https://www.qt.io/cn\" target=\"_blank\" rel=\"noopener\">Qt官网</a>下载Qt，注册一个账号，然后下载下来一个在线安装程序，点击进入安装界面</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/02.png\"></p>\n<p>安装路径等不用说(注意不能有中文路径)，默认选择安装Qt Creator，比较重要的是选择组件这一步：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_install.png\"> </p>\n<p>(之前我就点了个默认就没管了，然后在Qt Creator里面死活找不到Kit)，这里我选的Qt5的版本，Qt4与Qt5之间差别还是比较大的，但是既然是学习，肯定选择最新的版本了（我选的Qt 5.12.0)。<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/01.png\"></p>\n<p>然后是开发编译工具：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/03.png\"></p>\n<p>然后静待安装完成。</p>\n<h3 id=\"QGLViewer\"><a href=\"#QGLViewer\" class=\"headerlink\" title=\"QGLViewer\"></a>QGLViewer</h3><p><a href=\"http://libqglviewer.com/\" target=\"_blank\" rel=\"noopener\">libQGLViewer</a>是一个Qt的C++库，用于简化创建OpenGl 3D图像。它提供了一些非常典型的3D视图功能，包括像用鼠标移动相机，坐标轴显示，物体选择等功能。基于Qt工具包，它支持所有平台，其有商业许可，但也可用作开源软件开发。</p>\n<p>QGLViewer在上面的官网就可以下到了，官网内也详细写明了各个不同的平台该如何进行操作。我是Windows，所以下载好QGLViewer的项目后，解压后打开QGLVIewer/QGLViewer.pro项目文件(使用Qt Creator，其他工具方式详见官网)，然后点击左下角那个锤子进行构建。一般可以正确运行，如果失败的话，检查一下自己之前安装的kit是否错误，在Qt Creator上面菜单选择：工具-&gt;选项，打开后选择Kit，看是否有错误。</p>\n<p>在运行完毕之后，会得到两个dll文件：QGLViewer2.dll和QGLViewer2.dll。将其拷贝至C:\\Windows\\System32文件内，或是在要使用的项目路径下直接添加这两个dll。</p>\n<p>此时可以尝试跑一下example，就在QGLViewer文件的example文件内，可以看到QGLViewer的一些比较基本的功能演示。</p>\n<p>之后调用该库时，也可以在.pro项目文件中添加如下设置：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; TARGET = myViewer</span><br><span class=\"line\">&gt; CONFIG *= qt opengl release</span><br><span class=\"line\">&gt; QT *= opengl xml</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; HEADERS = myViewer.h</span><br><span class=\"line\">&gt; SOURCES = myViewer.cpp main.cpp</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Windows</span><br><span class=\"line\">&gt; INCLUDEPATH *= C:/Users/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -LC:/Users/login/Documents/libQGLViewer-2.7.1/QGLViewer -lQGLViewer2</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Linux</span><br><span class=\"line\">&gt; INCLUDEPATH *= /home/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -L/home/login/libQGLViewer-2.7.1/QGLViewer -lQGLViewer</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Mac </span><br><span class=\"line\">&gt; INCLUDEPATH *= /Users/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -F/Users/login/Library/Frameworks -framework QGLViewer</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>但是由于Qt5内部封装了Opengl的一些函数，如果你自己电脑之前也装过Opengl的相关东西的话，可能导致编译后链接库失败，此时可以在.pro文件中添加：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;win32-g++ &#123;</span><br><span class=\"line\">&gt;    LIBS += -lopengl32</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;win32-msvc*&#123;</span><br><span class=\"line\">&gt;    LIBS += opengl32.lib</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>即可编译成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>毕设设计可能要做一个与雷达可视化相关的项目，学长给了我一份之前的Qt的项目来看看，因为以前一直只听说过Qt，其怎么怎么样，怎么怎么好用，但实际上却从来都并未使用过。因此正好开坑记录一下Qt的学习。</p>\n<h3 id=\"Qt\"><a href=\"#Qt\" class=\"headerlink\" title=\"Qt\"></a>Qt</h3><p>Qt，发音同“cute”，是一个跨平台的C++应用程序开发框架。广泛用于开发GUI程序，这种情况下又被称为部件工具箱(widget toolkits)。同时它也可以用于开发非GUI程序，比如控制台工具和服务器。Qt使用于OPIE，Skype，VLC media player，Adobe Photoshop Elements，VirtualBox与Mathematica以及被Autodesk，欧洲空间局，梦工厂，Google，HP，KDE，卢卡斯，西门子公司等所使用。</p>\n<p>它是Digia公司的产品，使用标准C++和特殊的代码生成扩展(被称为元对象编译器)以及一些宏。通过语言绑定，其他的编程语言也可以使用Qt。</p>\n<p>Qt是自由开放源码的软件，在GNU宽通用公共许可证（LGPL）条款下发布。所有版本都支持广泛的编译器，包括GCC的C++编译器与Visual Studio。</p>\n<h3 id=\"Qt的安装\"><a href=\"#Qt的安装\" class=\"headerlink\" title=\"Qt的安装\"></a>Qt的安装</h3><p>前往<a href=\"https://www.qt.io/cn\" target=\"_blank\" rel=\"noopener\">Qt官网</a>下载Qt，注册一个账号，然后下载下来一个在线安装程序，点击进入安装界面</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/02.png\"></p>\n<p>安装路径等不用说(注意不能有中文路径)，默认选择安装Qt Creator，比较重要的是选择组件这一步：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_install.png\"> </p>\n<p>(之前我就点了个默认就没管了，然后在Qt Creator里面死活找不到Kit)，这里我选的Qt5的版本，Qt4与Qt5之间差别还是比较大的，但是既然是学习，肯定选择最新的版本了（我选的Qt 5.12.0)。<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/01.png\"></p>\n<p>然后是开发编译工具：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Qt_Learn/03.png\"></p>\n<p>然后静待安装完成。</p>\n<h3 id=\"QGLViewer\"><a href=\"#QGLViewer\" class=\"headerlink\" title=\"QGLViewer\"></a>QGLViewer</h3><p><a href=\"http://libqglviewer.com/\" target=\"_blank\" rel=\"noopener\">libQGLViewer</a>是一个Qt的C++库，用于简化创建OpenGl 3D图像。它提供了一些非常典型的3D视图功能，包括像用鼠标移动相机，坐标轴显示，物体选择等功能。基于Qt工具包，它支持所有平台，其有商业许可，但也可用作开源软件开发。</p>\n<p>QGLViewer在上面的官网就可以下到了，官网内也详细写明了各个不同的平台该如何进行操作。我是Windows，所以下载好QGLViewer的项目后，解压后打开QGLVIewer/QGLViewer.pro项目文件(使用Qt Creator，其他工具方式详见官网)，然后点击左下角那个锤子进行构建。一般可以正确运行，如果失败的话，检查一下自己之前安装的kit是否错误，在Qt Creator上面菜单选择：工具-&gt;选项，打开后选择Kit，看是否有错误。</p>\n<p>在运行完毕之后，会得到两个dll文件：QGLViewer2.dll和QGLViewer2.dll。将其拷贝至C:\\Windows\\System32文件内，或是在要使用的项目路径下直接添加这两个dll。</p>\n<p>此时可以尝试跑一下example，就在QGLViewer文件的example文件内，可以看到QGLViewer的一些比较基本的功能演示。</p>\n<p>之后调用该库时，也可以在.pro项目文件中添加如下设置：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; TARGET = myViewer</span><br><span class=\"line\">&gt; CONFIG *= qt opengl release</span><br><span class=\"line\">&gt; QT *= opengl xml</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; HEADERS = myViewer.h</span><br><span class=\"line\">&gt; SOURCES = myViewer.cpp main.cpp</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Windows</span><br><span class=\"line\">&gt; INCLUDEPATH *= C:/Users/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -LC:/Users/login/Documents/libQGLViewer-2.7.1/QGLViewer -lQGLViewer2</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Linux</span><br><span class=\"line\">&gt; INCLUDEPATH *= /home/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -L/home/login/libQGLViewer-2.7.1/QGLViewer -lQGLViewer</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; # Mac </span><br><span class=\"line\">&gt; INCLUDEPATH *= /Users/login/Documents/libQGLViewer-2.7.1</span><br><span class=\"line\">&gt; LIBS *= -F/Users/login/Library/Frameworks -framework QGLViewer</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>但是由于Qt5内部封装了Opengl的一些函数，如果你自己电脑之前也装过Opengl的相关东西的话，可能导致编译后链接库失败，此时可以在.pro文件中添加：</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;win32-g++ &#123;</span><br><span class=\"line\">&gt;    LIBS += -lopengl32</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;win32-msvc*&#123;</span><br><span class=\"line\">&gt;    LIBS += opengl32.lib</span><br><span class=\"line\">&gt;&#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>即可编译成功。</p>\n"},{"title":"由Dota2想到的","date":"2018-11-08T16:00:00.000Z","_content":"我从dota1就开始玩起，那是家里网慢，上不了对战平台，自己又不敢去网吧，只能天天打电脑解闷，高三毕业后和几个打的非常好的同学们一起玩，再到之后的dota2，dota真的承载了太多太多过去的回忆了。\n<br>TI8 LGD不敌OG，中国失去了偶数年的荣耀之后，dota我就玩的少了很多，不过偶尔去打打10v10和丛林肉搏了。\n<br>最近重庆major要开了，看到知乎上有人说最近比赛爆出外国玩家公屏打字\"chingchong\"，大家都很气愤，但V社却一直冷处理，没有任何回应，正好重庆major要开，TI9上海在即，中国dota感觉真的有些日暮西山了。不过高兴的是看到很多玩家，俱乐部和完美官方都在积极反应，要求V社做出相应惩罚等，希望Dota2环境能变的好一点吧，种族歧视真的很过分了。\n<br>Dota玩的真的不多了，此类游戏确实是不少人的青春与回忆，也是电竞的开端吧。如今电竞市场确实极大，里面也是鱼龙混杂。我其实不是很支持电子竞技作为体育项目的，项目太受游戏公司版本限制不说，其本身所带来的积极意义确实也是不大的。现代[奥林匹克精神](https://baike.baidu.com/item/%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%B2%BE%E7%A5%9E)是指：\n>每一个人都应享有从事体育运动的可能性，而不受任何形式的歧视，并体现相互理解、友谊、团结和公平竞争的奥林匹克精神。\n\n<br>电子竞技感觉确实很有公平竞争的概念，团结也在5v5模式中有很好的体现，某种意义上而言，电子竞技确实蛮符合奥林匹克精神的。但是我认为现代体育项目还是以现实体验为主，看着一些选手瘦弱驼背的样子，很难带给人一种积极向上的感觉呀（毕竟真正\"挥洒热血\"的是游戏里面的英雄）。\n<br>确实有人的地方就少不了歧视，少不了嘲讽。自打语言出现以来，人心的距离确实越来越远了。我一般打游戏多是开黑，单排基本闭麦听歌1v9吧。游戏确实是发泄的好途径，但大家都不想成为被发泄的那个人吧。游戏门槛很低，是个人就能玩，我一直认为好的东西就应该是下里巴人而不是阳春白雪，但是其也应该担负一些教化的功能。游戏都有积极的一面，除了减压之外，不同种类游戏带给人们不同的积极意义：Dota，lol，CS这些竞技类游戏的团体意识与永不言弃；MineCraft的自由创造；RPG之类游戏带给玩家的另一段奇妙人生与感动等等...好的游戏应该是艺术品，它雅俗共赏而又颇具意义。有人说过，读书是体验另一段人生最快的方式，每个游戏都有一个其背后的故事，它应该是将这段故事以计算机为载体而呈现在玩家面前的。时下游戏真的太多过于快餐了，尤其手游一类，因为其过于方便快捷加无脑，爆肝加氪金基本就够了，本质可能是一种单机游戏或是小众社交了吧。\n<br>我以后还是想做PC大作的，或许以后可以做个游戏策划什么的，去写写剧本也是很好的吧。未来就看VR技术能不能有重大突破了，说实在的，我老是觉得现代VR不像VR该有的样子，就和当年iphone没出来时，那个时候的智能机的感觉差不多吧。我暂时还是无法一窥未来VR的模样，虽然当年想过把人脑当作大脑一样，一个有极大内存的电脑...后来发现确实好像计算力是不够的...不知道自己能不能立于这波浪潮之上呀...","source":"_posts/b_Dota2_thinking.md","raw":"---\ntitle: 由Dota2想到的\ndate: 2018-11-09\ntag: 游戏杂谈\n---\n我从dota1就开始玩起，那是家里网慢，上不了对战平台，自己又不敢去网吧，只能天天打电脑解闷，高三毕业后和几个打的非常好的同学们一起玩，再到之后的dota2，dota真的承载了太多太多过去的回忆了。\n<br>TI8 LGD不敌OG，中国失去了偶数年的荣耀之后，dota我就玩的少了很多，不过偶尔去打打10v10和丛林肉搏了。\n<br>最近重庆major要开了，看到知乎上有人说最近比赛爆出外国玩家公屏打字\"chingchong\"，大家都很气愤，但V社却一直冷处理，没有任何回应，正好重庆major要开，TI9上海在即，中国dota感觉真的有些日暮西山了。不过高兴的是看到很多玩家，俱乐部和完美官方都在积极反应，要求V社做出相应惩罚等，希望Dota2环境能变的好一点吧，种族歧视真的很过分了。\n<br>Dota玩的真的不多了，此类游戏确实是不少人的青春与回忆，也是电竞的开端吧。如今电竞市场确实极大，里面也是鱼龙混杂。我其实不是很支持电子竞技作为体育项目的，项目太受游戏公司版本限制不说，其本身所带来的积极意义确实也是不大的。现代[奥林匹克精神](https://baike.baidu.com/item/%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%B2%BE%E7%A5%9E)是指：\n>每一个人都应享有从事体育运动的可能性，而不受任何形式的歧视，并体现相互理解、友谊、团结和公平竞争的奥林匹克精神。\n\n<br>电子竞技感觉确实很有公平竞争的概念，团结也在5v5模式中有很好的体现，某种意义上而言，电子竞技确实蛮符合奥林匹克精神的。但是我认为现代体育项目还是以现实体验为主，看着一些选手瘦弱驼背的样子，很难带给人一种积极向上的感觉呀（毕竟真正\"挥洒热血\"的是游戏里面的英雄）。\n<br>确实有人的地方就少不了歧视，少不了嘲讽。自打语言出现以来，人心的距离确实越来越远了。我一般打游戏多是开黑，单排基本闭麦听歌1v9吧。游戏确实是发泄的好途径，但大家都不想成为被发泄的那个人吧。游戏门槛很低，是个人就能玩，我一直认为好的东西就应该是下里巴人而不是阳春白雪，但是其也应该担负一些教化的功能。游戏都有积极的一面，除了减压之外，不同种类游戏带给人们不同的积极意义：Dota，lol，CS这些竞技类游戏的团体意识与永不言弃；MineCraft的自由创造；RPG之类游戏带给玩家的另一段奇妙人生与感动等等...好的游戏应该是艺术品，它雅俗共赏而又颇具意义。有人说过，读书是体验另一段人生最快的方式，每个游戏都有一个其背后的故事，它应该是将这段故事以计算机为载体而呈现在玩家面前的。时下游戏真的太多过于快餐了，尤其手游一类，因为其过于方便快捷加无脑，爆肝加氪金基本就够了，本质可能是一种单机游戏或是小众社交了吧。\n<br>我以后还是想做PC大作的，或许以后可以做个游戏策划什么的，去写写剧本也是很好的吧。未来就看VR技术能不能有重大突破了，说实在的，我老是觉得现代VR不像VR该有的样子，就和当年iphone没出来时，那个时候的智能机的感觉差不多吧。我暂时还是无法一窥未来VR的模样，虽然当年想过把人脑当作大脑一样，一个有极大内存的电脑...后来发现确实好像计算力是不够的...不知道自己能不能立于这波浪潮之上呀...","slug":"b_Dota2_thinking","published":1,"updated":"2019-02-25T01:36:46.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v260004l8v6mdqaa0x0","content":"<p>我从dota1就开始玩起，那是家里网慢，上不了对战平台，自己又不敢去网吧，只能天天打电脑解闷，高三毕业后和几个打的非常好的同学们一起玩，再到之后的dota2，dota真的承载了太多太多过去的回忆了。<br><br>TI8 LGD不敌OG，中国失去了偶数年的荣耀之后，dota我就玩的少了很多，不过偶尔去打打10v10和丛林肉搏了。<br><br>最近重庆major要开了，看到知乎上有人说最近比赛爆出外国玩家公屏打字”chingchong”，大家都很气愤，但V社却一直冷处理，没有任何回应，正好重庆major要开，TI9上海在即，中国dota感觉真的有些日暮西山了。不过高兴的是看到很多玩家，俱乐部和完美官方都在积极反应，要求V社做出相应惩罚等，希望Dota2环境能变的好一点吧，种族歧视真的很过分了。<br><br>Dota玩的真的不多了，此类游戏确实是不少人的青春与回忆，也是电竞的开端吧。如今电竞市场确实极大，里面也是鱼龙混杂。我其实不是很支持电子竞技作为体育项目的，项目太受游戏公司版本限制不说，其本身所带来的积极意义确实也是不大的。现代<a href=\"https://baike.baidu.com/item/%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%B2%BE%E7%A5%9E\" target=\"_blank\" rel=\"noopener\">奥林匹克精神</a>是指：</p>\n<blockquote>\n<p>每一个人都应享有从事体育运动的可能性，而不受任何形式的歧视，并体现相互理解、友谊、团结和公平竞争的奥林匹克精神。</p>\n</blockquote>\n<p><br>电子竞技感觉确实很有公平竞争的概念，团结也在5v5模式中有很好的体现，某种意义上而言，电子竞技确实蛮符合奥林匹克精神的。但是我认为现代体育项目还是以现实体验为主，看着一些选手瘦弱驼背的样子，很难带给人一种积极向上的感觉呀（毕竟真正”挥洒热血”的是游戏里面的英雄）。<br><br>确实有人的地方就少不了歧视，少不了嘲讽。自打语言出现以来，人心的距离确实越来越远了。我一般打游戏多是开黑，单排基本闭麦听歌1v9吧。游戏确实是发泄的好途径，但大家都不想成为被发泄的那个人吧。游戏门槛很低，是个人就能玩，我一直认为好的东西就应该是下里巴人而不是阳春白雪，但是其也应该担负一些教化的功能。游戏都有积极的一面，除了减压之外，不同种类游戏带给人们不同的积极意义：Dota，lol，CS这些竞技类游戏的团体意识与永不言弃；MineCraft的自由创造；RPG之类游戏带给玩家的另一段奇妙人生与感动等等…好的游戏应该是艺术品，它雅俗共赏而又颇具意义。有人说过，读书是体验另一段人生最快的方式，每个游戏都有一个其背后的故事，它应该是将这段故事以计算机为载体而呈现在玩家面前的。时下游戏真的太多过于快餐了，尤其手游一类，因为其过于方便快捷加无脑，爆肝加氪金基本就够了，本质可能是一种单机游戏或是小众社交了吧。<br><br>我以后还是想做PC大作的，或许以后可以做个游戏策划什么的，去写写剧本也是很好的吧。未来就看VR技术能不能有重大突破了，说实在的，我老是觉得现代VR不像VR该有的样子，就和当年iphone没出来时，那个时候的智能机的感觉差不多吧。我暂时还是无法一窥未来VR的模样，虽然当年想过把人脑当作大脑一样，一个有极大内存的电脑…后来发现确实好像计算力是不够的…不知道自己能不能立于这波浪潮之上呀…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我从dota1就开始玩起，那是家里网慢，上不了对战平台，自己又不敢去网吧，只能天天打电脑解闷，高三毕业后和几个打的非常好的同学们一起玩，再到之后的dota2，dota真的承载了太多太多过去的回忆了。<br><br>TI8 LGD不敌OG，中国失去了偶数年的荣耀之后，dota我就玩的少了很多，不过偶尔去打打10v10和丛林肉搏了。<br><br>最近重庆major要开了，看到知乎上有人说最近比赛爆出外国玩家公屏打字”chingchong”，大家都很气愤，但V社却一直冷处理，没有任何回应，正好重庆major要开，TI9上海在即，中国dota感觉真的有些日暮西山了。不过高兴的是看到很多玩家，俱乐部和完美官方都在积极反应，要求V社做出相应惩罚等，希望Dota2环境能变的好一点吧，种族歧视真的很过分了。<br><br>Dota玩的真的不多了，此类游戏确实是不少人的青春与回忆，也是电竞的开端吧。如今电竞市场确实极大，里面也是鱼龙混杂。我其实不是很支持电子竞技作为体育项目的，项目太受游戏公司版本限制不说，其本身所带来的积极意义确实也是不大的。现代<a href=\"https://baike.baidu.com/item/%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E7%B2%BE%E7%A5%9E\" target=\"_blank\" rel=\"noopener\">奥林匹克精神</a>是指：</p>\n<blockquote>\n<p>每一个人都应享有从事体育运动的可能性，而不受任何形式的歧视，并体现相互理解、友谊、团结和公平竞争的奥林匹克精神。</p>\n</blockquote>\n<p><br>电子竞技感觉确实很有公平竞争的概念，团结也在5v5模式中有很好的体现，某种意义上而言，电子竞技确实蛮符合奥林匹克精神的。但是我认为现代体育项目还是以现实体验为主，看着一些选手瘦弱驼背的样子，很难带给人一种积极向上的感觉呀（毕竟真正”挥洒热血”的是游戏里面的英雄）。<br><br>确实有人的地方就少不了歧视，少不了嘲讽。自打语言出现以来，人心的距离确实越来越远了。我一般打游戏多是开黑，单排基本闭麦听歌1v9吧。游戏确实是发泄的好途径，但大家都不想成为被发泄的那个人吧。游戏门槛很低，是个人就能玩，我一直认为好的东西就应该是下里巴人而不是阳春白雪，但是其也应该担负一些教化的功能。游戏都有积极的一面，除了减压之外，不同种类游戏带给人们不同的积极意义：Dota，lol，CS这些竞技类游戏的团体意识与永不言弃；MineCraft的自由创造；RPG之类游戏带给玩家的另一段奇妙人生与感动等等…好的游戏应该是艺术品，它雅俗共赏而又颇具意义。有人说过，读书是体验另一段人生最快的方式，每个游戏都有一个其背后的故事，它应该是将这段故事以计算机为载体而呈现在玩家面前的。时下游戏真的太多过于快餐了，尤其手游一类，因为其过于方便快捷加无脑，爆肝加氪金基本就够了，本质可能是一种单机游戏或是小众社交了吧。<br><br>我以后还是想做PC大作的，或许以后可以做个游戏策划什么的，去写写剧本也是很好的吧。未来就看VR技术能不能有重大突破了，说实在的，我老是觉得现代VR不像VR该有的样子，就和当年iphone没出来时，那个时候的智能机的感觉差不多吧。我暂时还是无法一窥未来VR的模样，虽然当年想过把人脑当作大脑一样，一个有极大内存的电脑…后来发现确实好像计算力是不够的…不知道自己能不能立于这波浪潮之上呀…</p>\n"},{"title":"游戏程序员学习历程","date":"2018-11-08T16:00:00.000Z","_content":"以前在github上看到过某位大神写的[游戏程序员学习之路](https://github.com/miloyip/game-programmer/)...说实在的，真的有点太多，学前班的\"Game Programming for Kids\"就算了，这里写下未来的学习计划与打算吧。\n### Programming Languages:\n>因为Unity3d缘故，写C#比较多，但是用到的.Net版本都不高，新出的倒是比较高了，所以感觉得多学习一下C#的新特性吧，而且一些以前就有的模块我都不是特别熟，主要是委托delegate那一部分，再就是Linq，感觉也要学习一下，顺便温习一些基本语法吧。因为以前买过一本[《C#高级编程》](https://book.douban.com/subject/3344305/)打算就看这个了，再辅以一些网上博客的东西吧。\n\n### Software Development\n>这部分感觉看设计模式就比较够了，网上关于设计模式的资料博客都比较多，因为语言选择的C#所以感觉看下设计模式，对于Unity里面用的多的比如单例模式，发布者订阅者模式，抽象工厂模式等等这些，感觉需要系统的学习与多多练习，对于软件开发也是极好的。\n\n### Mathmatics for Game Programming\n>这部分的话，熟悉下基本矩阵操作吧，主要是线性代数，个人感觉暂时就够了。\n\n### Game Programming\n>一直有在学[Unity3d](https://unity3d.com/)，因此继续坚持学习Unity相关的知识吧，多写几个个人项目，多用到C#的高级特性与一些设计模式。\n\n### Game Engine Development\n>感觉这个就比较难说了，感觉可以跟着学习开发Unity的时候去了解一些游戏引擎的实现吧，看看文档，了解一些引擎源码之类的。\n\n### Computer Graphics\n>CG这块还是很重要的，感觉很多游戏大神程序员都是图形学的大牛啊，这部分倒是可以好好学习，以Unity3d Shader编程为切入点，开始学习。买了本[《Unity Shader入门精要》](https://book.douban.com/subject/26821639/),这是本蛮好的书，但是一直没深入看...这部分倒是要用到很多数学的东西，之前的Mathmatics倒是可以和这个搭配一起看。\n\n### Game Physics and Animation\n>这块跟着Unity项目时了解，了解一下Unity的rigidbody，animation这些是怎么用的，怎么实现的，animation的状态机确实很好用，感觉也可以自己写帧动画去实现一个，这个倒是可以好好研究一下。\n\n### Game Artificial Intelligence(AI)\n>这个可以从Unity的Navigation开始学习，然后时A*寻路算法这些，状态机设计等等，再一些更高级的AI学习，视需求而定吧。\n\n### Multiplayer Game Programming\n>因为以前用过Unity的Unet，做过一些局域网的联机小游戏。不过这些确实感觉坑有点多，网络同步这些问题很多，情况很负责，感觉需要辅以网络编程这些东西一起来学习。\n\n<br>吴军在[《数学之美》](https://book.douban.com/subject/10750155/)种说，人随着成长，学习能力远超以往，小时候花1个小时才能懂的知识，长大了可以10分钟就能弄明白了，所以时下是学习的最高效时期，学习一个月可抵以往两到三个月的效果，所以多多珍惜当下时光，好好学习。另外，个人真心推荐吴军博士的几本书，感觉写的都很不错，很适合大家读一读：[《浪潮之巅》](https://book.douban.com/subject/6709783/)，[《文明之光》](https://book.douban.com/subject/25902942/)，[《大学之路》](https://book.douban.com/subject/26584286/)和上面提到的《数学之美》。\n\n望与诸君共勉。\n","source":"_posts/c_LearningPlan.md","raw":"---\ntitle: 游戏程序员学习历程\ndate: 2018-11-09\ntag: 学习\n---\n以前在github上看到过某位大神写的[游戏程序员学习之路](https://github.com/miloyip/game-programmer/)...说实在的，真的有点太多，学前班的\"Game Programming for Kids\"就算了，这里写下未来的学习计划与打算吧。\n### Programming Languages:\n>因为Unity3d缘故，写C#比较多，但是用到的.Net版本都不高，新出的倒是比较高了，所以感觉得多学习一下C#的新特性吧，而且一些以前就有的模块我都不是特别熟，主要是委托delegate那一部分，再就是Linq，感觉也要学习一下，顺便温习一些基本语法吧。因为以前买过一本[《C#高级编程》](https://book.douban.com/subject/3344305/)打算就看这个了，再辅以一些网上博客的东西吧。\n\n### Software Development\n>这部分感觉看设计模式就比较够了，网上关于设计模式的资料博客都比较多，因为语言选择的C#所以感觉看下设计模式，对于Unity里面用的多的比如单例模式，发布者订阅者模式，抽象工厂模式等等这些，感觉需要系统的学习与多多练习，对于软件开发也是极好的。\n\n### Mathmatics for Game Programming\n>这部分的话，熟悉下基本矩阵操作吧，主要是线性代数，个人感觉暂时就够了。\n\n### Game Programming\n>一直有在学[Unity3d](https://unity3d.com/)，因此继续坚持学习Unity相关的知识吧，多写几个个人项目，多用到C#的高级特性与一些设计模式。\n\n### Game Engine Development\n>感觉这个就比较难说了，感觉可以跟着学习开发Unity的时候去了解一些游戏引擎的实现吧，看看文档，了解一些引擎源码之类的。\n\n### Computer Graphics\n>CG这块还是很重要的，感觉很多游戏大神程序员都是图形学的大牛啊，这部分倒是可以好好学习，以Unity3d Shader编程为切入点，开始学习。买了本[《Unity Shader入门精要》](https://book.douban.com/subject/26821639/),这是本蛮好的书，但是一直没深入看...这部分倒是要用到很多数学的东西，之前的Mathmatics倒是可以和这个搭配一起看。\n\n### Game Physics and Animation\n>这块跟着Unity项目时了解，了解一下Unity的rigidbody，animation这些是怎么用的，怎么实现的，animation的状态机确实很好用，感觉也可以自己写帧动画去实现一个，这个倒是可以好好研究一下。\n\n### Game Artificial Intelligence(AI)\n>这个可以从Unity的Navigation开始学习，然后时A*寻路算法这些，状态机设计等等，再一些更高级的AI学习，视需求而定吧。\n\n### Multiplayer Game Programming\n>因为以前用过Unity的Unet，做过一些局域网的联机小游戏。不过这些确实感觉坑有点多，网络同步这些问题很多，情况很负责，感觉需要辅以网络编程这些东西一起来学习。\n\n<br>吴军在[《数学之美》](https://book.douban.com/subject/10750155/)种说，人随着成长，学习能力远超以往，小时候花1个小时才能懂的知识，长大了可以10分钟就能弄明白了，所以时下是学习的最高效时期，学习一个月可抵以往两到三个月的效果，所以多多珍惜当下时光，好好学习。另外，个人真心推荐吴军博士的几本书，感觉写的都很不错，很适合大家读一读：[《浪潮之巅》](https://book.douban.com/subject/6709783/)，[《文明之光》](https://book.douban.com/subject/25902942/)，[《大学之路》](https://book.douban.com/subject/26584286/)和上面提到的《数学之美》。\n\n望与诸君共勉。\n","slug":"c_LearningPlan","published":1,"updated":"2019-02-25T01:36:46.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v270005l8v6ayct403z","content":"<p>以前在github上看到过某位大神写的<a href=\"https://github.com/miloyip/game-programmer/\" target=\"_blank\" rel=\"noopener\">游戏程序员学习之路</a>…说实在的，真的有点太多，学前班的”Game Programming for Kids”就算了，这里写下未来的学习计划与打算吧。</p>\n<h3 id=\"Programming-Languages\"><a href=\"#Programming-Languages\" class=\"headerlink\" title=\"Programming Languages:\"></a>Programming Languages:</h3><blockquote>\n<p>因为Unity3d缘故，写C#比较多，但是用到的.Net版本都不高，新出的倒是比较高了，所以感觉得多学习一下C#的新特性吧，而且一些以前就有的模块我都不是特别熟，主要是委托delegate那一部分，再就是Linq，感觉也要学习一下，顺便温习一些基本语法吧。因为以前买过一本<a href=\"https://book.douban.com/subject/3344305/\" target=\"_blank\" rel=\"noopener\">《C#高级编程》</a>打算就看这个了，再辅以一些网上博客的东西吧。</p>\n</blockquote>\n<h3 id=\"Software-Development\"><a href=\"#Software-Development\" class=\"headerlink\" title=\"Software Development\"></a>Software Development</h3><blockquote>\n<p>这部分感觉看设计模式就比较够了，网上关于设计模式的资料博客都比较多，因为语言选择的C#所以感觉看下设计模式，对于Unity里面用的多的比如单例模式，发布者订阅者模式，抽象工厂模式等等这些，感觉需要系统的学习与多多练习，对于软件开发也是极好的。</p>\n</blockquote>\n<h3 id=\"Mathmatics-for-Game-Programming\"><a href=\"#Mathmatics-for-Game-Programming\" class=\"headerlink\" title=\"Mathmatics for Game Programming\"></a>Mathmatics for Game Programming</h3><blockquote>\n<p>这部分的话，熟悉下基本矩阵操作吧，主要是线性代数，个人感觉暂时就够了。</p>\n</blockquote>\n<h3 id=\"Game-Programming\"><a href=\"#Game-Programming\" class=\"headerlink\" title=\"Game Programming\"></a>Game Programming</h3><blockquote>\n<p>一直有在学<a href=\"https://unity3d.com/\" target=\"_blank\" rel=\"noopener\">Unity3d</a>，因此继续坚持学习Unity相关的知识吧，多写几个个人项目，多用到C#的高级特性与一些设计模式。</p>\n</blockquote>\n<h3 id=\"Game-Engine-Development\"><a href=\"#Game-Engine-Development\" class=\"headerlink\" title=\"Game Engine Development\"></a>Game Engine Development</h3><blockquote>\n<p>感觉这个就比较难说了，感觉可以跟着学习开发Unity的时候去了解一些游戏引擎的实现吧，看看文档，了解一些引擎源码之类的。</p>\n</blockquote>\n<h3 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h3><blockquote>\n<p>CG这块还是很重要的，感觉很多游戏大神程序员都是图形学的大牛啊，这部分倒是可以好好学习，以Unity3d Shader编程为切入点，开始学习。买了本<a href=\"https://book.douban.com/subject/26821639/\" target=\"_blank\" rel=\"noopener\">《Unity Shader入门精要》</a>,这是本蛮好的书，但是一直没深入看…这部分倒是要用到很多数学的东西，之前的Mathmatics倒是可以和这个搭配一起看。</p>\n</blockquote>\n<h3 id=\"Game-Physics-and-Animation\"><a href=\"#Game-Physics-and-Animation\" class=\"headerlink\" title=\"Game Physics and Animation\"></a>Game Physics and Animation</h3><blockquote>\n<p>这块跟着Unity项目时了解，了解一下Unity的rigidbody，animation这些是怎么用的，怎么实现的，animation的状态机确实很好用，感觉也可以自己写帧动画去实现一个，这个倒是可以好好研究一下。</p>\n</blockquote>\n<h3 id=\"Game-Artificial-Intelligence-AI\"><a href=\"#Game-Artificial-Intelligence-AI\" class=\"headerlink\" title=\"Game Artificial Intelligence(AI)\"></a>Game Artificial Intelligence(AI)</h3><blockquote>\n<p>这个可以从Unity的Navigation开始学习，然后时A*寻路算法这些，状态机设计等等，再一些更高级的AI学习，视需求而定吧。</p>\n</blockquote>\n<h3 id=\"Multiplayer-Game-Programming\"><a href=\"#Multiplayer-Game-Programming\" class=\"headerlink\" title=\"Multiplayer Game Programming\"></a>Multiplayer Game Programming</h3><blockquote>\n<p>因为以前用过Unity的Unet，做过一些局域网的联机小游戏。不过这些确实感觉坑有点多，网络同步这些问题很多，情况很负责，感觉需要辅以网络编程这些东西一起来学习。</p>\n</blockquote>\n<p><br>吴军在<a href=\"https://book.douban.com/subject/10750155/\" target=\"_blank\" rel=\"noopener\">《数学之美》</a>种说，人随着成长，学习能力远超以往，小时候花1个小时才能懂的知识，长大了可以10分钟就能弄明白了，所以时下是学习的最高效时期，学习一个月可抵以往两到三个月的效果，所以多多珍惜当下时光，好好学习。另外，个人真心推荐吴军博士的几本书，感觉写的都很不错，很适合大家读一读：<a href=\"https://book.douban.com/subject/6709783/\" target=\"_blank\" rel=\"noopener\">《浪潮之巅》</a>，<a href=\"https://book.douban.com/subject/25902942/\" target=\"_blank\" rel=\"noopener\">《文明之光》</a>，<a href=\"https://book.douban.com/subject/26584286/\" target=\"_blank\" rel=\"noopener\">《大学之路》</a>和上面提到的《数学之美》。</p>\n<p>望与诸君共勉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前在github上看到过某位大神写的<a href=\"https://github.com/miloyip/game-programmer/\" target=\"_blank\" rel=\"noopener\">游戏程序员学习之路</a>…说实在的，真的有点太多，学前班的”Game Programming for Kids”就算了，这里写下未来的学习计划与打算吧。</p>\n<h3 id=\"Programming-Languages\"><a href=\"#Programming-Languages\" class=\"headerlink\" title=\"Programming Languages:\"></a>Programming Languages:</h3><blockquote>\n<p>因为Unity3d缘故，写C#比较多，但是用到的.Net版本都不高，新出的倒是比较高了，所以感觉得多学习一下C#的新特性吧，而且一些以前就有的模块我都不是特别熟，主要是委托delegate那一部分，再就是Linq，感觉也要学习一下，顺便温习一些基本语法吧。因为以前买过一本<a href=\"https://book.douban.com/subject/3344305/\" target=\"_blank\" rel=\"noopener\">《C#高级编程》</a>打算就看这个了，再辅以一些网上博客的东西吧。</p>\n</blockquote>\n<h3 id=\"Software-Development\"><a href=\"#Software-Development\" class=\"headerlink\" title=\"Software Development\"></a>Software Development</h3><blockquote>\n<p>这部分感觉看设计模式就比较够了，网上关于设计模式的资料博客都比较多，因为语言选择的C#所以感觉看下设计模式，对于Unity里面用的多的比如单例模式，发布者订阅者模式，抽象工厂模式等等这些，感觉需要系统的学习与多多练习，对于软件开发也是极好的。</p>\n</blockquote>\n<h3 id=\"Mathmatics-for-Game-Programming\"><a href=\"#Mathmatics-for-Game-Programming\" class=\"headerlink\" title=\"Mathmatics for Game Programming\"></a>Mathmatics for Game Programming</h3><blockquote>\n<p>这部分的话，熟悉下基本矩阵操作吧，主要是线性代数，个人感觉暂时就够了。</p>\n</blockquote>\n<h3 id=\"Game-Programming\"><a href=\"#Game-Programming\" class=\"headerlink\" title=\"Game Programming\"></a>Game Programming</h3><blockquote>\n<p>一直有在学<a href=\"https://unity3d.com/\" target=\"_blank\" rel=\"noopener\">Unity3d</a>，因此继续坚持学习Unity相关的知识吧，多写几个个人项目，多用到C#的高级特性与一些设计模式。</p>\n</blockquote>\n<h3 id=\"Game-Engine-Development\"><a href=\"#Game-Engine-Development\" class=\"headerlink\" title=\"Game Engine Development\"></a>Game Engine Development</h3><blockquote>\n<p>感觉这个就比较难说了，感觉可以跟着学习开发Unity的时候去了解一些游戏引擎的实现吧，看看文档，了解一些引擎源码之类的。</p>\n</blockquote>\n<h3 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h3><blockquote>\n<p>CG这块还是很重要的，感觉很多游戏大神程序员都是图形学的大牛啊，这部分倒是可以好好学习，以Unity3d Shader编程为切入点，开始学习。买了本<a href=\"https://book.douban.com/subject/26821639/\" target=\"_blank\" rel=\"noopener\">《Unity Shader入门精要》</a>,这是本蛮好的书，但是一直没深入看…这部分倒是要用到很多数学的东西，之前的Mathmatics倒是可以和这个搭配一起看。</p>\n</blockquote>\n<h3 id=\"Game-Physics-and-Animation\"><a href=\"#Game-Physics-and-Animation\" class=\"headerlink\" title=\"Game Physics and Animation\"></a>Game Physics and Animation</h3><blockquote>\n<p>这块跟着Unity项目时了解，了解一下Unity的rigidbody，animation这些是怎么用的，怎么实现的，animation的状态机确实很好用，感觉也可以自己写帧动画去实现一个，这个倒是可以好好研究一下。</p>\n</blockquote>\n<h3 id=\"Game-Artificial-Intelligence-AI\"><a href=\"#Game-Artificial-Intelligence-AI\" class=\"headerlink\" title=\"Game Artificial Intelligence(AI)\"></a>Game Artificial Intelligence(AI)</h3><blockquote>\n<p>这个可以从Unity的Navigation开始学习，然后时A*寻路算法这些，状态机设计等等，再一些更高级的AI学习，视需求而定吧。</p>\n</blockquote>\n<h3 id=\"Multiplayer-Game-Programming\"><a href=\"#Multiplayer-Game-Programming\" class=\"headerlink\" title=\"Multiplayer Game Programming\"></a>Multiplayer Game Programming</h3><blockquote>\n<p>因为以前用过Unity的Unet，做过一些局域网的联机小游戏。不过这些确实感觉坑有点多，网络同步这些问题很多，情况很负责，感觉需要辅以网络编程这些东西一起来学习。</p>\n</blockquote>\n<p><br>吴军在<a href=\"https://book.douban.com/subject/10750155/\" target=\"_blank\" rel=\"noopener\">《数学之美》</a>种说，人随着成长，学习能力远超以往，小时候花1个小时才能懂的知识，长大了可以10分钟就能弄明白了，所以时下是学习的最高效时期，学习一个月可抵以往两到三个月的效果，所以多多珍惜当下时光，好好学习。另外，个人真心推荐吴军博士的几本书，感觉写的都很不错，很适合大家读一读：<a href=\"https://book.douban.com/subject/6709783/\" target=\"_blank\" rel=\"noopener\">《浪潮之巅》</a>，<a href=\"https://book.douban.com/subject/25902942/\" target=\"_blank\" rel=\"noopener\">《文明之光》</a>，<a href=\"https://book.douban.com/subject/26584286/\" target=\"_blank\" rel=\"noopener\">《大学之路》</a>和上面提到的《数学之美》。</p>\n<p>望与诸君共勉。</p>\n"},{"title":"浅谈文字冒险类游戏","date":"2018-11-11T16:00:00.000Z","_content":"最近有点小迷日式恐怖游戏啊，一直有在[b站](https://www.bilibili.com)看Up主[靖菌命](https://space.bilibili.com/4059920/#/)做的一些恐怖游戏，感觉这些游戏确实剧本相当的优秀啊。这种古老而传统的游戏，即便是在3A大作频出的今天，依旧有着独特的魅力。没有酷炫的打斗设计与3D效果，这种平面2.5D的游戏多是以优质剧情而吸引着一批忠实的玩家。理论上，文字小说都能够改编成为文字冒险游戏，这种游戏制作成本较低，往往也是很多游戏制作者们做出的第一款完整的角色扮演游戏了。文字冒险后期的变种有很多，但我还是习惯称它们都为文字冒险游戏，毕竟它们的核心都是剧情导向的。\n### 文字冒险游戏\n>文字冒险游戏是以精彩的剧情为卖点的游戏。它以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。它也被称为电子小说。此类型游戏以软件模拟情境，令玩家使用文字指令控制角色，以影响周边的情境。其运作方式可以理解成是用电脑游戏来做文学叙事。\n### 文字冒险游戏发展历程\n>* 电脑文字游戏最开始是个人电脑初始时候作为一种角色扮演游戏而出现的，变体不多。基本上全是冒险游戏。而后来的日式文字冒险游戏和所谓的“文字游戏”涵义是不一样的。而其最早想法出自于美国，后来随贴图游戏的崛起而没落。文字冒险游戏借由阅读故事内文(或角色间的对话)并从中进行选择，进而达成某些目标并完成剧情的游戏，即AVG游戏。这类游戏源自日本，经过多年来的发展已经成为日本个人计算机游戏市场上不可或缺的存在。\n>* 文字冒险游戏是以精彩的剧情为卖点的游戏，以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。是冒险游戏的一个分支，简称ADV，也叫电子小说，甚至也有直接使用AVG来作为缩写。目前几乎只有日本的游戏公司制作。\n>* 我们常说的恋爱游戏通常是文字冒险游戏的一个子类，而且也算是本类游戏的大宗。不过也有例外，例如KID公司的infinity系列是把科幻题材与恋爱混合起来，还有SEGA的樱花大战把文字冒险以及回合战略结合等等。\n### 文字冒险游戏的魅力\n>* 说实在的，剧情与优秀的插画是文字冒险游戏不至于消亡的最后支柱了。固然，剧情与美术还有程序是任何优秀游戏都不能缺少的。而这类文字冒险游戏战斗偏少，多是关键选择而决定最后剧情的走向。一般此类优秀都会有多个结局：包括true end,happy end,bad end等等。恋爱类可能根据攻略对象的不同而有不同的结局线，玩家常说的\"XX线\"啊什么的，多来源于此。\n>* 文字冒险游戏比读一款小说更加让人印象深刻，因为多结局的存在让故事有了更多的可能，也让玩家对游戏中的各个角色，人物等有着更加深刻的认识与印象。此类游戏轻量便捷，难度也不会太大，辅以较为精致的插画，还是很受到玩家喜爱的。\n### 文字冒险游戏的未来\n>* 现代游戏，手游自成一方，氪金，对战，的的确确是恐怖的吸金工具。主机端多3A大作，但国内普及没有外界高，PC端单机与网游相辅相成，构成了整个现代的游戏世界。当年大家极爱的小霸王的那些优秀冒险类游戏，如今在手机或是电脑上装上一个模拟器，基本上都是可以玩一玩的。\n>* 传统小作坊类的小单机多是没落了，今年出来的《太吾绘卷》与《中国式家长》倒是未来精致文字冒险游戏的一个发展方向了，结局更加开发，玩法更加多样化，由玩家\"看剧情\"变成玩家自己\"写剧情\"，这倒是一个极好的发展方向。\n>* 传统文字类冒险游戏里，感觉也就恋爱类的GalGame有着比较好的发展了。毕竟现在画面越做越精美，愿意去玩那种比较老式的文字冒险的玩家也不多了。实际上，我一直觉得色情游戏啥的确实有着极大的市场，参考一下PornHub的数据就知道全世界有多少人荷尔蒙分泌过剩了...steam上更有\"你给我看奶子，我给你钱\"这种直白无比的玩家。大厂往往只可能打一些色情的擦边球去吸引玩家，而衍生各种本子则是同人创作的事情了。部分愿意做色情游戏的，多半也是做点文字冒险之类的小作坊了。3D的也有，但真的辣眼睛，建模太差了...在下年轻时也玩过\n<span id=\"mm\" style=\"background:black;color:black\" title=\"(>_<)\" onmouseenter=\"mouseEnter()\" onmouseleave=\"mouseLeave()\">《勇者大战魔物娘》</span>这种，感觉这是我体验最好的\"小游戏\"了。\n\n<br>优质的剧情与新颖的玩法是游戏的生命之泉，看Up玩[《鬼子母神之梦》](https://www.bilibili.com/video/av35722226)时就感觉很不错，游戏UI设计与剧情提示等都做的相当优秀，音乐与画面都将恐怖的氛围渲染的极好。感觉很适合游戏程序员一个人拿来练练手做一个简单小巧的RPG的小游戏。[RPG制作大师](http://www.rpgmakerweb.com/)确实是一个很快捷简单的工具，感觉其入门制作剧情向的小游戏如用按键精灵做一些小脚本一般方便快捷。我之前有段时间用Unity的UGUI做过一段时间的RPG小游戏，其感觉也是相当不错的，未来有时间的可以拿出来分享一下。\n\n<script>\n    function mouseEnter(){\n        document.getElementById(\"mm\").style.background=\"white\";\n    }\n    function mouseLeave(){\n        document.getElementById(\"mm\").style.background=\"black\";\n    }\n</script>\n","source":"_posts/e_TextAdventureGame.md","raw":"---\ntitle: 浅谈文字冒险类游戏\ndate: 2018-11-12\ntag: 游戏观后感\n---\n最近有点小迷日式恐怖游戏啊，一直有在[b站](https://www.bilibili.com)看Up主[靖菌命](https://space.bilibili.com/4059920/#/)做的一些恐怖游戏，感觉这些游戏确实剧本相当的优秀啊。这种古老而传统的游戏，即便是在3A大作频出的今天，依旧有着独特的魅力。没有酷炫的打斗设计与3D效果，这种平面2.5D的游戏多是以优质剧情而吸引着一批忠实的玩家。理论上，文字小说都能够改编成为文字冒险游戏，这种游戏制作成本较低，往往也是很多游戏制作者们做出的第一款完整的角色扮演游戏了。文字冒险后期的变种有很多，但我还是习惯称它们都为文字冒险游戏，毕竟它们的核心都是剧情导向的。\n### 文字冒险游戏\n>文字冒险游戏是以精彩的剧情为卖点的游戏。它以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。它也被称为电子小说。此类型游戏以软件模拟情境，令玩家使用文字指令控制角色，以影响周边的情境。其运作方式可以理解成是用电脑游戏来做文学叙事。\n### 文字冒险游戏发展历程\n>* 电脑文字游戏最开始是个人电脑初始时候作为一种角色扮演游戏而出现的，变体不多。基本上全是冒险游戏。而后来的日式文字冒险游戏和所谓的“文字游戏”涵义是不一样的。而其最早想法出自于美国，后来随贴图游戏的崛起而没落。文字冒险游戏借由阅读故事内文(或角色间的对话)并从中进行选择，进而达成某些目标并完成剧情的游戏，即AVG游戏。这类游戏源自日本，经过多年来的发展已经成为日本个人计算机游戏市场上不可或缺的存在。\n>* 文字冒险游戏是以精彩的剧情为卖点的游戏，以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。是冒险游戏的一个分支，简称ADV，也叫电子小说，甚至也有直接使用AVG来作为缩写。目前几乎只有日本的游戏公司制作。\n>* 我们常说的恋爱游戏通常是文字冒险游戏的一个子类，而且也算是本类游戏的大宗。不过也有例外，例如KID公司的infinity系列是把科幻题材与恋爱混合起来，还有SEGA的樱花大战把文字冒险以及回合战略结合等等。\n### 文字冒险游戏的魅力\n>* 说实在的，剧情与优秀的插画是文字冒险游戏不至于消亡的最后支柱了。固然，剧情与美术还有程序是任何优秀游戏都不能缺少的。而这类文字冒险游戏战斗偏少，多是关键选择而决定最后剧情的走向。一般此类优秀都会有多个结局：包括true end,happy end,bad end等等。恋爱类可能根据攻略对象的不同而有不同的结局线，玩家常说的\"XX线\"啊什么的，多来源于此。\n>* 文字冒险游戏比读一款小说更加让人印象深刻，因为多结局的存在让故事有了更多的可能，也让玩家对游戏中的各个角色，人物等有着更加深刻的认识与印象。此类游戏轻量便捷，难度也不会太大，辅以较为精致的插画，还是很受到玩家喜爱的。\n### 文字冒险游戏的未来\n>* 现代游戏，手游自成一方，氪金，对战，的的确确是恐怖的吸金工具。主机端多3A大作，但国内普及没有外界高，PC端单机与网游相辅相成，构成了整个现代的游戏世界。当年大家极爱的小霸王的那些优秀冒险类游戏，如今在手机或是电脑上装上一个模拟器，基本上都是可以玩一玩的。\n>* 传统小作坊类的小单机多是没落了，今年出来的《太吾绘卷》与《中国式家长》倒是未来精致文字冒险游戏的一个发展方向了，结局更加开发，玩法更加多样化，由玩家\"看剧情\"变成玩家自己\"写剧情\"，这倒是一个极好的发展方向。\n>* 传统文字类冒险游戏里，感觉也就恋爱类的GalGame有着比较好的发展了。毕竟现在画面越做越精美，愿意去玩那种比较老式的文字冒险的玩家也不多了。实际上，我一直觉得色情游戏啥的确实有着极大的市场，参考一下PornHub的数据就知道全世界有多少人荷尔蒙分泌过剩了...steam上更有\"你给我看奶子，我给你钱\"这种直白无比的玩家。大厂往往只可能打一些色情的擦边球去吸引玩家，而衍生各种本子则是同人创作的事情了。部分愿意做色情游戏的，多半也是做点文字冒险之类的小作坊了。3D的也有，但真的辣眼睛，建模太差了...在下年轻时也玩过\n<span id=\"mm\" style=\"background:black;color:black\" title=\"(>_<)\" onmouseenter=\"mouseEnter()\" onmouseleave=\"mouseLeave()\">《勇者大战魔物娘》</span>这种，感觉这是我体验最好的\"小游戏\"了。\n\n<br>优质的剧情与新颖的玩法是游戏的生命之泉，看Up玩[《鬼子母神之梦》](https://www.bilibili.com/video/av35722226)时就感觉很不错，游戏UI设计与剧情提示等都做的相当优秀，音乐与画面都将恐怖的氛围渲染的极好。感觉很适合游戏程序员一个人拿来练练手做一个简单小巧的RPG的小游戏。[RPG制作大师](http://www.rpgmakerweb.com/)确实是一个很快捷简单的工具，感觉其入门制作剧情向的小游戏如用按键精灵做一些小脚本一般方便快捷。我之前有段时间用Unity的UGUI做过一段时间的RPG小游戏，其感觉也是相当不错的，未来有时间的可以拿出来分享一下。\n\n<script>\n    function mouseEnter(){\n        document.getElementById(\"mm\").style.background=\"white\";\n    }\n    function mouseLeave(){\n        document.getElementById(\"mm\").style.background=\"black\";\n    }\n</script>\n","slug":"e_TextAdventureGame","published":1,"updated":"2019-02-25T01:36:46.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v2b0008l8v6wyqhsmn8","content":"<p>最近有点小迷日式恐怖游戏啊，一直有在<a href=\"https://www.bilibili.com\" target=\"_blank\" rel=\"noopener\">b站</a>看Up主<a href=\"https://space.bilibili.com/4059920/#/\" target=\"_blank\" rel=\"noopener\">靖菌命</a>做的一些恐怖游戏，感觉这些游戏确实剧本相当的优秀啊。这种古老而传统的游戏，即便是在3A大作频出的今天，依旧有着独特的魅力。没有酷炫的打斗设计与3D效果，这种平面2.5D的游戏多是以优质剧情而吸引着一批忠实的玩家。理论上，文字小说都能够改编成为文字冒险游戏，这种游戏制作成本较低，往往也是很多游戏制作者们做出的第一款完整的角色扮演游戏了。文字冒险后期的变种有很多，但我还是习惯称它们都为文字冒险游戏，毕竟它们的核心都是剧情导向的。</p>\n<h3 id=\"文字冒险游戏\"><a href=\"#文字冒险游戏\" class=\"headerlink\" title=\"文字冒险游戏\"></a>文字冒险游戏</h3><blockquote>\n<p>文字冒险游戏是以精彩的剧情为卖点的游戏。它以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。它也被称为电子小说。此类型游戏以软件模拟情境，令玩家使用文字指令控制角色，以影响周边的情境。其运作方式可以理解成是用电脑游戏来做文学叙事。</p>\n</blockquote>\n<h3 id=\"文字冒险游戏发展历程\"><a href=\"#文字冒险游戏发展历程\" class=\"headerlink\" title=\"文字冒险游戏发展历程\"></a>文字冒险游戏发展历程</h3><blockquote>\n<ul>\n<li>电脑文字游戏最开始是个人电脑初始时候作为一种角色扮演游戏而出现的，变体不多。基本上全是冒险游戏。而后来的日式文字冒险游戏和所谓的“文字游戏”涵义是不一样的。而其最早想法出自于美国，后来随贴图游戏的崛起而没落。文字冒险游戏借由阅读故事内文(或角色间的对话)并从中进行选择，进而达成某些目标并完成剧情的游戏，即AVG游戏。这类游戏源自日本，经过多年来的发展已经成为日本个人计算机游戏市场上不可或缺的存在。</li>\n<li>文字冒险游戏是以精彩的剧情为卖点的游戏，以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。是冒险游戏的一个分支，简称ADV，也叫电子小说，甚至也有直接使用AVG来作为缩写。目前几乎只有日本的游戏公司制作。</li>\n<li>我们常说的恋爱游戏通常是文字冒险游戏的一个子类，而且也算是本类游戏的大宗。不过也有例外，例如KID公司的infinity系列是把科幻题材与恋爱混合起来，还有SEGA的樱花大战把文字冒险以及回合战略结合等等。</li>\n</ul>\n</blockquote>\n<h3 id=\"文字冒险游戏的魅力\"><a href=\"#文字冒险游戏的魅力\" class=\"headerlink\" title=\"文字冒险游戏的魅力\"></a>文字冒险游戏的魅力</h3><blockquote>\n<ul>\n<li>说实在的，剧情与优秀的插画是文字冒险游戏不至于消亡的最后支柱了。固然，剧情与美术还有程序是任何优秀游戏都不能缺少的。而这类文字冒险游戏战斗偏少，多是关键选择而决定最后剧情的走向。一般此类优秀都会有多个结局：包括true end,happy end,bad end等等。恋爱类可能根据攻略对象的不同而有不同的结局线，玩家常说的”XX线”啊什么的，多来源于此。</li>\n<li>文字冒险游戏比读一款小说更加让人印象深刻，因为多结局的存在让故事有了更多的可能，也让玩家对游戏中的各个角色，人物等有着更加深刻的认识与印象。此类游戏轻量便捷，难度也不会太大，辅以较为精致的插画，还是很受到玩家喜爱的。</li>\n</ul>\n</blockquote>\n<h3 id=\"文字冒险游戏的未来\"><a href=\"#文字冒险游戏的未来\" class=\"headerlink\" title=\"文字冒险游戏的未来\"></a>文字冒险游戏的未来</h3><blockquote>\n<ul>\n<li>现代游戏，手游自成一方，氪金，对战，的的确确是恐怖的吸金工具。主机端多3A大作，但国内普及没有外界高，PC端单机与网游相辅相成，构成了整个现代的游戏世界。当年大家极爱的小霸王的那些优秀冒险类游戏，如今在手机或是电脑上装上一个模拟器，基本上都是可以玩一玩的。</li>\n<li>传统小作坊类的小单机多是没落了，今年出来的《太吾绘卷》与《中国式家长》倒是未来精致文字冒险游戏的一个发展方向了，结局更加开发，玩法更加多样化，由玩家”看剧情”变成玩家自己”写剧情”，这倒是一个极好的发展方向。</li>\n<li>传统文字类冒险游戏里，感觉也就恋爱类的GalGame有着比较好的发展了。毕竟现在画面越做越精美，愿意去玩那种比较老式的文字冒险的玩家也不多了。实际上，我一直觉得色情游戏啥的确实有着极大的市场，参考一下PornHub的数据就知道全世界有多少人荷尔蒙分泌过剩了…steam上更有”你给我看奶子，我给你钱”这种直白无比的玩家。大厂往往只可能打一些色情的擦边球去吸引玩家，而衍生各种本子则是同人创作的事情了。部分愿意做色情游戏的，多半也是做点文字冒险之类的小作坊了。3D的也有，但真的辣眼睛，建模太差了…在下年轻时也玩过<br><span id=\"mm\" style=\"background:black;color:black\" title=\"(>_<)\" onmouseenter=\"mouseEnter()\" onmouseleave=\"mouseLeave()\">《勇者大战魔物娘》</span>这种，感觉这是我体验最好的”小游戏”了。</li>\n</ul>\n</blockquote>\n<p><br>优质的剧情与新颖的玩法是游戏的生命之泉，看Up玩<a href=\"https://www.bilibili.com/video/av35722226\" target=\"_blank\" rel=\"noopener\">《鬼子母神之梦》</a>时就感觉很不错，游戏UI设计与剧情提示等都做的相当优秀，音乐与画面都将恐怖的氛围渲染的极好。感觉很适合游戏程序员一个人拿来练练手做一个简单小巧的RPG的小游戏。<a href=\"http://www.rpgmakerweb.com/\" target=\"_blank\" rel=\"noopener\">RPG制作大师</a>确实是一个很快捷简单的工具，感觉其入门制作剧情向的小游戏如用按键精灵做一些小脚本一般方便快捷。我之前有段时间用Unity的UGUI做过一段时间的RPG小游戏，其感觉也是相当不错的，未来有时间的可以拿出来分享一下。</p>\n<script>\n    function mouseEnter(){\n        document.getElementById(\"mm\").style.background=\"white\";\n    }\n    function mouseLeave(){\n        document.getElementById(\"mm\").style.background=\"black\";\n    }\n</script>\n","site":{"data":{}},"excerpt":"","more":"<p>最近有点小迷日式恐怖游戏啊，一直有在<a href=\"https://www.bilibili.com\" target=\"_blank\" rel=\"noopener\">b站</a>看Up主<a href=\"https://space.bilibili.com/4059920/#/\" target=\"_blank\" rel=\"noopener\">靖菌命</a>做的一些恐怖游戏，感觉这些游戏确实剧本相当的优秀啊。这种古老而传统的游戏，即便是在3A大作频出的今天，依旧有着独特的魅力。没有酷炫的打斗设计与3D效果，这种平面2.5D的游戏多是以优质剧情而吸引着一批忠实的玩家。理论上，文字小说都能够改编成为文字冒险游戏，这种游戏制作成本较低，往往也是很多游戏制作者们做出的第一款完整的角色扮演游戏了。文字冒险后期的变种有很多，但我还是习惯称它们都为文字冒险游戏，毕竟它们的核心都是剧情导向的。</p>\n<h3 id=\"文字冒险游戏\"><a href=\"#文字冒险游戏\" class=\"headerlink\" title=\"文字冒险游戏\"></a>文字冒险游戏</h3><blockquote>\n<p>文字冒险游戏是以精彩的剧情为卖点的游戏。它以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。它也被称为电子小说。此类型游戏以软件模拟情境，令玩家使用文字指令控制角色，以影响周边的情境。其运作方式可以理解成是用电脑游戏来做文学叙事。</p>\n</blockquote>\n<h3 id=\"文字冒险游戏发展历程\"><a href=\"#文字冒险游戏发展历程\" class=\"headerlink\" title=\"文字冒险游戏发展历程\"></a>文字冒险游戏发展历程</h3><blockquote>\n<ul>\n<li>电脑文字游戏最开始是个人电脑初始时候作为一种角色扮演游戏而出现的，变体不多。基本上全是冒险游戏。而后来的日式文字冒险游戏和所谓的“文字游戏”涵义是不一样的。而其最早想法出自于美国，后来随贴图游戏的崛起而没落。文字冒险游戏借由阅读故事内文(或角色间的对话)并从中进行选择，进而达成某些目标并完成剧情的游戏，即AVG游戏。这类游戏源自日本，经过多年来的发展已经成为日本个人计算机游戏市场上不可或缺的存在。</li>\n<li>文字冒险游戏是以精彩的剧情为卖点的游戏，以文字叙述为主，并以CG或动画为辅演出剧情，并设有分支和多个结局。是冒险游戏的一个分支，简称ADV，也叫电子小说，甚至也有直接使用AVG来作为缩写。目前几乎只有日本的游戏公司制作。</li>\n<li>我们常说的恋爱游戏通常是文字冒险游戏的一个子类，而且也算是本类游戏的大宗。不过也有例外，例如KID公司的infinity系列是把科幻题材与恋爱混合起来，还有SEGA的樱花大战把文字冒险以及回合战略结合等等。</li>\n</ul>\n</blockquote>\n<h3 id=\"文字冒险游戏的魅力\"><a href=\"#文字冒险游戏的魅力\" class=\"headerlink\" title=\"文字冒险游戏的魅力\"></a>文字冒险游戏的魅力</h3><blockquote>\n<ul>\n<li>说实在的，剧情与优秀的插画是文字冒险游戏不至于消亡的最后支柱了。固然，剧情与美术还有程序是任何优秀游戏都不能缺少的。而这类文字冒险游戏战斗偏少，多是关键选择而决定最后剧情的走向。一般此类优秀都会有多个结局：包括true end,happy end,bad end等等。恋爱类可能根据攻略对象的不同而有不同的结局线，玩家常说的”XX线”啊什么的，多来源于此。</li>\n<li>文字冒险游戏比读一款小说更加让人印象深刻，因为多结局的存在让故事有了更多的可能，也让玩家对游戏中的各个角色，人物等有着更加深刻的认识与印象。此类游戏轻量便捷，难度也不会太大，辅以较为精致的插画，还是很受到玩家喜爱的。</li>\n</ul>\n</blockquote>\n<h3 id=\"文字冒险游戏的未来\"><a href=\"#文字冒险游戏的未来\" class=\"headerlink\" title=\"文字冒险游戏的未来\"></a>文字冒险游戏的未来</h3><blockquote>\n<ul>\n<li>现代游戏，手游自成一方，氪金，对战，的的确确是恐怖的吸金工具。主机端多3A大作，但国内普及没有外界高，PC端单机与网游相辅相成，构成了整个现代的游戏世界。当年大家极爱的小霸王的那些优秀冒险类游戏，如今在手机或是电脑上装上一个模拟器，基本上都是可以玩一玩的。</li>\n<li>传统小作坊类的小单机多是没落了，今年出来的《太吾绘卷》与《中国式家长》倒是未来精致文字冒险游戏的一个发展方向了，结局更加开发，玩法更加多样化，由玩家”看剧情”变成玩家自己”写剧情”，这倒是一个极好的发展方向。</li>\n<li>传统文字类冒险游戏里，感觉也就恋爱类的GalGame有着比较好的发展了。毕竟现在画面越做越精美，愿意去玩那种比较老式的文字冒险的玩家也不多了。实际上，我一直觉得色情游戏啥的确实有着极大的市场，参考一下PornHub的数据就知道全世界有多少人荷尔蒙分泌过剩了…steam上更有”你给我看奶子，我给你钱”这种直白无比的玩家。大厂往往只可能打一些色情的擦边球去吸引玩家，而衍生各种本子则是同人创作的事情了。部分愿意做色情游戏的，多半也是做点文字冒险之类的小作坊了。3D的也有，但真的辣眼睛，建模太差了…在下年轻时也玩过<br><span id=\"mm\" style=\"background:black;color:black\" title=\"(>_<)\" onmouseenter=\"mouseEnter()\" onmouseleave=\"mouseLeave()\">《勇者大战魔物娘》</span>这种，感觉这是我体验最好的”小游戏”了。</li>\n</ul>\n</blockquote>\n<p><br>优质的剧情与新颖的玩法是游戏的生命之泉，看Up玩<a href=\"https://www.bilibili.com/video/av35722226\" target=\"_blank\" rel=\"noopener\">《鬼子母神之梦》</a>时就感觉很不错，游戏UI设计与剧情提示等都做的相当优秀，音乐与画面都将恐怖的氛围渲染的极好。感觉很适合游戏程序员一个人拿来练练手做一个简单小巧的RPG的小游戏。<a href=\"http://www.rpgmakerweb.com/\" target=\"_blank\" rel=\"noopener\">RPG制作大师</a>确实是一个很快捷简单的工具，感觉其入门制作剧情向的小游戏如用按键精灵做一些小脚本一般方便快捷。我之前有段时间用Unity的UGUI做过一段时间的RPG小游戏，其感觉也是相当不错的，未来有时间的可以拿出来分享一下。</p>\n<script>\n    function mouseEnter(){\n        document.getElementById(\"mm\").style.background=\"white\";\n    }\n    function mouseLeave(){\n        document.getElementById(\"mm\").style.background=\"black\";\n    }\n</script>\n"},{"title":"《鬼子母神之梦》","date":"2018-11-11T16:00:00.000Z","_content":"今天在[b站](https://www.bilibili.com)看完了Up主[靖菌命](https://space.bilibili.com/4059920/#/)做的一款恐怖游戏录播[《鬼子母神之梦》](https://www.bilibili.com/video/av35722226)，讲道理，很久没看到这么棒的游戏剧本了，相较于传统的RPG里面一些打魔王，拯救世界的游戏剧情，《鬼子母神之梦》剧情要短很多，但真的十分精彩，它完美融合怪诞传说与伦理，确实给人带来极大的震撼。<br>\n(此部分含游戏剧情透露)《鬼子母神之梦》讲述的是一个\"鬼母\"的故事，这个鬼母某种意义上可以对应于众所周知的\"鬼父\"(别怀疑，剧情真的有点\"鬼父\"情节)。有的母亲深爱着自己的孩子，有的母亲偏爱着自己的孩子，有的母亲为了自己的孩子而去献祭其他的孩子...一如人世间所有的感情，感情偏执了便会让人变得疯狂，最终自以为到极致的感情表达，往往带给被施加之人的是痛苦与绝望。<br>\n在佛教中便有鬼子母神：\n>鬼子母，鬼子母神(Hariti)，又称为欢喜母、暴恶母或爱子母，梵文音译诃利帝母。原为婆罗门教中的恶神，护法二十诸天之一，专吃人间小孩，称之为“母夜叉”。被佛法教化后，成为专司护持儿童的护法神。\n\n佛教中的鬼子母神与这部游戏的鬼子母神有一定类似的地方：\n>传说，鬼子母生了五百个儿子，她天天还要吃王舍城里别家的男女小孩。佛尊得知此事，规劝不从，遂以法力藏起她的一个儿子，鬼子母想念她的孩子，急得她又哭又闹到处寻找。当她知道孩子在佛身边，便求佛还给她。佛说：你有五百个儿子，少一个就着急，你不想想，人家只有一两个孩子，被你吃了，那有怎么办呢？鬼子母幡然悔悟，归依了佛门，并被吸收为护法神。\n\n但是这部游戏的鬼子母神让人更加印象深刻。传说在很久以前，有个村子有着\"活人祭\"的习俗，面对天灾，村民会献祭一个年幼的孩子给上天，祈求宽恕与原谅，被献祭孩子的母亲因此而疯狂——既然我的孩子可以理所当然地被你们献祭，那为了复活我的孩子而献祭你们地孩子也是理所应当的吧。最后这位母亲被村民讨伐，并作为鬼而供奉——人们相信，给与大怨念的人以神一样的供奉，她就不会变成鬼来危害人间...<br>\n若干年后，一位深爱着丈夫的妻子无法接受丈夫离世的事实，对于自己的两个儿子，对其中长相酷似其父的孩子施加了其对丈夫的爱，对另一个孩子施加的则是其作为母亲的爱，年幼无知的孩子们无法理解而相互羡慕着母亲给与对方的爱。而当他们同时认识了新的朋友时而产生的误会让他们疯狂，长年积压的不满导致冲突而让其中一个孩子死去...疯狂的母亲残害生命以复活自己的孩子...成为了鬼母...这部游戏讲述的就是这些孩子的故事。<br>\n游戏内容很紧凑，处处扣题，以上不过基本剧情基础与介绍，游戏内神展开颇多——都是点睛之笔，让人愈发唏嘘。总视频长度3小时左右，Up主打出了happy end与true end两个结局，两个结局首尾呼应，将这个故事讲述的更加具体。有兴趣的朋友可以尝试去看看，Up主解说很精彩，恐怖氛围不错而又不会过分吓人。<br>","source":"_posts/f_HorribleGameFeeling.md","raw":"---\ntitle: 《鬼子母神之梦》\ndate: 2018-11-12\ntag: 游戏观后感\n---\n今天在[b站](https://www.bilibili.com)看完了Up主[靖菌命](https://space.bilibili.com/4059920/#/)做的一款恐怖游戏录播[《鬼子母神之梦》](https://www.bilibili.com/video/av35722226)，讲道理，很久没看到这么棒的游戏剧本了，相较于传统的RPG里面一些打魔王，拯救世界的游戏剧情，《鬼子母神之梦》剧情要短很多，但真的十分精彩，它完美融合怪诞传说与伦理，确实给人带来极大的震撼。<br>\n(此部分含游戏剧情透露)《鬼子母神之梦》讲述的是一个\"鬼母\"的故事，这个鬼母某种意义上可以对应于众所周知的\"鬼父\"(别怀疑，剧情真的有点\"鬼父\"情节)。有的母亲深爱着自己的孩子，有的母亲偏爱着自己的孩子，有的母亲为了自己的孩子而去献祭其他的孩子...一如人世间所有的感情，感情偏执了便会让人变得疯狂，最终自以为到极致的感情表达，往往带给被施加之人的是痛苦与绝望。<br>\n在佛教中便有鬼子母神：\n>鬼子母，鬼子母神(Hariti)，又称为欢喜母、暴恶母或爱子母，梵文音译诃利帝母。原为婆罗门教中的恶神，护法二十诸天之一，专吃人间小孩，称之为“母夜叉”。被佛法教化后，成为专司护持儿童的护法神。\n\n佛教中的鬼子母神与这部游戏的鬼子母神有一定类似的地方：\n>传说，鬼子母生了五百个儿子，她天天还要吃王舍城里别家的男女小孩。佛尊得知此事，规劝不从，遂以法力藏起她的一个儿子，鬼子母想念她的孩子，急得她又哭又闹到处寻找。当她知道孩子在佛身边，便求佛还给她。佛说：你有五百个儿子，少一个就着急，你不想想，人家只有一两个孩子，被你吃了，那有怎么办呢？鬼子母幡然悔悟，归依了佛门，并被吸收为护法神。\n\n但是这部游戏的鬼子母神让人更加印象深刻。传说在很久以前，有个村子有着\"活人祭\"的习俗，面对天灾，村民会献祭一个年幼的孩子给上天，祈求宽恕与原谅，被献祭孩子的母亲因此而疯狂——既然我的孩子可以理所当然地被你们献祭，那为了复活我的孩子而献祭你们地孩子也是理所应当的吧。最后这位母亲被村民讨伐，并作为鬼而供奉——人们相信，给与大怨念的人以神一样的供奉，她就不会变成鬼来危害人间...<br>\n若干年后，一位深爱着丈夫的妻子无法接受丈夫离世的事实，对于自己的两个儿子，对其中长相酷似其父的孩子施加了其对丈夫的爱，对另一个孩子施加的则是其作为母亲的爱，年幼无知的孩子们无法理解而相互羡慕着母亲给与对方的爱。而当他们同时认识了新的朋友时而产生的误会让他们疯狂，长年积压的不满导致冲突而让其中一个孩子死去...疯狂的母亲残害生命以复活自己的孩子...成为了鬼母...这部游戏讲述的就是这些孩子的故事。<br>\n游戏内容很紧凑，处处扣题，以上不过基本剧情基础与介绍，游戏内神展开颇多——都是点睛之笔，让人愈发唏嘘。总视频长度3小时左右，Up主打出了happy end与true end两个结局，两个结局首尾呼应，将这个故事讲述的更加具体。有兴趣的朋友可以尝试去看看，Up主解说很精彩，恐怖氛围不错而又不会过分吓人。<br>","slug":"f_HorribleGameFeeling","published":1,"updated":"2019-02-25T01:36:46.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v2d0009l8v6xtcuq1i9","content":"<p>今天在<a href=\"https://www.bilibili.com\" target=\"_blank\" rel=\"noopener\">b站</a>看完了Up主<a href=\"https://space.bilibili.com/4059920/#/\" target=\"_blank\" rel=\"noopener\">靖菌命</a>做的一款恐怖游戏录播<a href=\"https://www.bilibili.com/video/av35722226\" target=\"_blank\" rel=\"noopener\">《鬼子母神之梦》</a>，讲道理，很久没看到这么棒的游戏剧本了，相较于传统的RPG里面一些打魔王，拯救世界的游戏剧情，《鬼子母神之梦》剧情要短很多，但真的十分精彩，它完美融合怪诞传说与伦理，确实给人带来极大的震撼。<br><br>(此部分含游戏剧情透露)《鬼子母神之梦》讲述的是一个”鬼母”的故事，这个鬼母某种意义上可以对应于众所周知的”鬼父”(别怀疑，剧情真的有点”鬼父”情节)。有的母亲深爱着自己的孩子，有的母亲偏爱着自己的孩子，有的母亲为了自己的孩子而去献祭其他的孩子…一如人世间所有的感情，感情偏执了便会让人变得疯狂，最终自以为到极致的感情表达，往往带给被施加之人的是痛苦与绝望。<br><br>在佛教中便有鬼子母神：</p>\n<blockquote>\n<p>鬼子母，鬼子母神(Hariti)，又称为欢喜母、暴恶母或爱子母，梵文音译诃利帝母。原为婆罗门教中的恶神，护法二十诸天之一，专吃人间小孩，称之为“母夜叉”。被佛法教化后，成为专司护持儿童的护法神。</p>\n</blockquote>\n<p>佛教中的鬼子母神与这部游戏的鬼子母神有一定类似的地方：</p>\n<blockquote>\n<p>传说，鬼子母生了五百个儿子，她天天还要吃王舍城里别家的男女小孩。佛尊得知此事，规劝不从，遂以法力藏起她的一个儿子，鬼子母想念她的孩子，急得她又哭又闹到处寻找。当她知道孩子在佛身边，便求佛还给她。佛说：你有五百个儿子，少一个就着急，你不想想，人家只有一两个孩子，被你吃了，那有怎么办呢？鬼子母幡然悔悟，归依了佛门，并被吸收为护法神。</p>\n</blockquote>\n<p>但是这部游戏的鬼子母神让人更加印象深刻。传说在很久以前，有个村子有着”活人祭”的习俗，面对天灾，村民会献祭一个年幼的孩子给上天，祈求宽恕与原谅，被献祭孩子的母亲因此而疯狂——既然我的孩子可以理所当然地被你们献祭，那为了复活我的孩子而献祭你们地孩子也是理所应当的吧。最后这位母亲被村民讨伐，并作为鬼而供奉——人们相信，给与大怨念的人以神一样的供奉，她就不会变成鬼来危害人间…<br><br>若干年后，一位深爱着丈夫的妻子无法接受丈夫离世的事实，对于自己的两个儿子，对其中长相酷似其父的孩子施加了其对丈夫的爱，对另一个孩子施加的则是其作为母亲的爱，年幼无知的孩子们无法理解而相互羡慕着母亲给与对方的爱。而当他们同时认识了新的朋友时而产生的误会让他们疯狂，长年积压的不满导致冲突而让其中一个孩子死去…疯狂的母亲残害生命以复活自己的孩子…成为了鬼母…这部游戏讲述的就是这些孩子的故事。<br><br>游戏内容很紧凑，处处扣题，以上不过基本剧情基础与介绍，游戏内神展开颇多——都是点睛之笔，让人愈发唏嘘。总视频长度3小时左右，Up主打出了happy end与true end两个结局，两个结局首尾呼应，将这个故事讲述的更加具体。有兴趣的朋友可以尝试去看看，Up主解说很精彩，恐怖氛围不错而又不会过分吓人。<br></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在<a href=\"https://www.bilibili.com\" target=\"_blank\" rel=\"noopener\">b站</a>看完了Up主<a href=\"https://space.bilibili.com/4059920/#/\" target=\"_blank\" rel=\"noopener\">靖菌命</a>做的一款恐怖游戏录播<a href=\"https://www.bilibili.com/video/av35722226\" target=\"_blank\" rel=\"noopener\">《鬼子母神之梦》</a>，讲道理，很久没看到这么棒的游戏剧本了，相较于传统的RPG里面一些打魔王，拯救世界的游戏剧情，《鬼子母神之梦》剧情要短很多，但真的十分精彩，它完美融合怪诞传说与伦理，确实给人带来极大的震撼。<br><br>(此部分含游戏剧情透露)《鬼子母神之梦》讲述的是一个”鬼母”的故事，这个鬼母某种意义上可以对应于众所周知的”鬼父”(别怀疑，剧情真的有点”鬼父”情节)。有的母亲深爱着自己的孩子，有的母亲偏爱着自己的孩子，有的母亲为了自己的孩子而去献祭其他的孩子…一如人世间所有的感情，感情偏执了便会让人变得疯狂，最终自以为到极致的感情表达，往往带给被施加之人的是痛苦与绝望。<br><br>在佛教中便有鬼子母神：</p>\n<blockquote>\n<p>鬼子母，鬼子母神(Hariti)，又称为欢喜母、暴恶母或爱子母，梵文音译诃利帝母。原为婆罗门教中的恶神，护法二十诸天之一，专吃人间小孩，称之为“母夜叉”。被佛法教化后，成为专司护持儿童的护法神。</p>\n</blockquote>\n<p>佛教中的鬼子母神与这部游戏的鬼子母神有一定类似的地方：</p>\n<blockquote>\n<p>传说，鬼子母生了五百个儿子，她天天还要吃王舍城里别家的男女小孩。佛尊得知此事，规劝不从，遂以法力藏起她的一个儿子，鬼子母想念她的孩子，急得她又哭又闹到处寻找。当她知道孩子在佛身边，便求佛还给她。佛说：你有五百个儿子，少一个就着急，你不想想，人家只有一两个孩子，被你吃了，那有怎么办呢？鬼子母幡然悔悟，归依了佛门，并被吸收为护法神。</p>\n</blockquote>\n<p>但是这部游戏的鬼子母神让人更加印象深刻。传说在很久以前，有个村子有着”活人祭”的习俗，面对天灾，村民会献祭一个年幼的孩子给上天，祈求宽恕与原谅，被献祭孩子的母亲因此而疯狂——既然我的孩子可以理所当然地被你们献祭，那为了复活我的孩子而献祭你们地孩子也是理所应当的吧。最后这位母亲被村民讨伐，并作为鬼而供奉——人们相信，给与大怨念的人以神一样的供奉，她就不会变成鬼来危害人间…<br><br>若干年后，一位深爱着丈夫的妻子无法接受丈夫离世的事实，对于自己的两个儿子，对其中长相酷似其父的孩子施加了其对丈夫的爱，对另一个孩子施加的则是其作为母亲的爱，年幼无知的孩子们无法理解而相互羡慕着母亲给与对方的爱。而当他们同时认识了新的朋友时而产生的误会让他们疯狂，长年积压的不满导致冲突而让其中一个孩子死去…疯狂的母亲残害生命以复活自己的孩子…成为了鬼母…这部游戏讲述的就是这些孩子的故事。<br><br>游戏内容很紧凑，处处扣题，以上不过基本剧情基础与介绍，游戏内神展开颇多——都是点睛之笔，让人愈发唏嘘。总视频长度3小时左右，Up主打出了happy end与true end两个结局，两个结局首尾呼应，将这个故事讲述的更加具体。有兴趣的朋友可以尝试去看看，Up主解说很精彩，恐怖氛围不错而又不会过分吓人。<br></p>\n"},{"title":"恐怖游戏","date":"2018-11-12T16:00:00.000Z","_content":"自小就有点幽闭恐惧症，对于深海，封闭与未知都感到有些恐惧。动漫我基本都只看小清新与治愈系列，对于黑深残与致郁我则是向来拒而远之的。<br>\n大学最开始与室友们一起玩的游戏是《Minecraft》(我的世界)，有个同学接了学校的一个项目，然后把这个项目的服务器作为MC的服务器，大家一起在世界里面造房子打僵尸，从地狱打到末影龙，几乎记录了我们整个大二的时光。即便如此，每当我一个人上线时，面对我们造的大房子与圈养的牛羊，孤独感依旧迎面而来，一个人玩这个游戏，玩久了就真的让人感到十分压抑了...\n<br>后来我们转去一起玩《left 4 dead》(求生之路)了，这是一个人的我绝对不会玩的游戏(纵使这个游戏AI做的很棒)，宿舍四人天天打，开始还有点害怕，玩多了就感觉无所谓了...后来我们打各种mod，去对战服等...可谓是把这个游戏玩了个遍吧。后来我又去补了一下求生之路的漫画剧情，对于V社不出求生之路3，我还是心有怨念的。\n<br>那之后我好像对于丧尸，深海这些东西的抵抗力强了很多？以前偶尔看到什么\"复旦十大灵异事件\"，\"光华楼13层\"，\"同济天佑楼停尸房\"的时候还会被吓到不行，现在看一些什么\"世界4大灵异地点\"，\"奥特曼中的童年阴影\"的时候，感觉就是些毛毛雨了。后来还会有意识去看看丧尸题材电影与恐怖游戏直播，动漫也把《学园默示录》与《甲铁城的卡巴内瑞》这些给补掉了。果然自己的抗性是越来越高了哈哈。\n<br>有些恐怖游戏确实看起来很爽，但玩起来感觉却一般，因为往往这些游戏涉及到大量解密类元素，而这些元素往往又在一个狭小阴暗的房间中——要知道，我玩《上古卷轴》钻地下墓穴时都搞不清东南西北，各种撞墙，更不要说在狭小房间中玩什么躲避战与解密探索了。个人一直觉得，恐怖游戏是各种游戏种类中最难的一种游戏，其解密，战斗等元素，即使是新手级，往往也对玩家有很高的挑战——既要防止突如其来的\"高能\"，又要找到关键解密点。所以观看高端Up主们打恐怖游戏确实是一个像我这样的\"云恐怖迷\"的最好选择了。\n<br>《黎明杀机》是我见到的比较好的对战形式的恐怖游戏，音乐，氛围都渲染的极好。手游版的《第五人格》确实做的不错，但毕竟要符合社会主义核心价值观嘛，已经不算恐怖游戏了。\n<br>后来又有看SCP的一些东西，感觉网友们是真的人才，最开始编的我都以为是真的了...当然，毕竟著名的几个SCP确实很有恐怖吓人的感觉，但后来那些感觉就越来越逗比了...末日题材的小说有看过疯丢子的《末世齐祭》(在下一直男频女频不忌)，个人感觉是她所有作品中写的最好的...其他感觉都一般...\n<br>虽然大学都已经临近毕业了，但自己中二病依旧，以前看《遮天》的时候，看到源天师晚年遭遇不详的时候还是感觉有点怕怕的，后来就只觉得\"不详\"这个词真的太酷了...以致于我后来觉得自己倒霉的时候都不说自己倒霉，而说\"自己遭遇了不详\"...嘛，反正自己觉得很嗨就是了哈哈。\n<br>据说恐怖游戏制作团队多出抑郁症患者，确实这种特殊题材的游戏，要吓到玩家们的制作者们自己估计也不好受，\"我吓我自己\",\"我抑郁我自己\"这种事不在少数。我不推崇为了吓人而吓人的\"黑深残\"，有些别有用心的游戏中确实有很多猎奇变态的东西，这些我还是很讨厌与厌恶的，混入这些东西的游戏不能称之为恐怖游戏了，它们只能被称为\"遭遇不详\"的游戏。我一直觉得游戏本质就是一种艺术形式，它也应该给人们带来真善美的体验，吓人只是元素，恐怖游戏带给人的应该是对人生意义的思考与对人性黑暗面的省视。我们可以在十个小时内过完游戏主角的一生，这是我们体验另一段人生最为便捷的方式之一了(其他方式还包括读书与电视电影)。毕竟，套路见的多了，也就不会再恐惧未知了。","source":"_posts/g_HorribleGameThinking.md","raw":"---\ntitle: 恐怖游戏\ndate: 2018-11-13\ntag: 游戏杂谈\n---\n自小就有点幽闭恐惧症，对于深海，封闭与未知都感到有些恐惧。动漫我基本都只看小清新与治愈系列，对于黑深残与致郁我则是向来拒而远之的。<br>\n大学最开始与室友们一起玩的游戏是《Minecraft》(我的世界)，有个同学接了学校的一个项目，然后把这个项目的服务器作为MC的服务器，大家一起在世界里面造房子打僵尸，从地狱打到末影龙，几乎记录了我们整个大二的时光。即便如此，每当我一个人上线时，面对我们造的大房子与圈养的牛羊，孤独感依旧迎面而来，一个人玩这个游戏，玩久了就真的让人感到十分压抑了...\n<br>后来我们转去一起玩《left 4 dead》(求生之路)了，这是一个人的我绝对不会玩的游戏(纵使这个游戏AI做的很棒)，宿舍四人天天打，开始还有点害怕，玩多了就感觉无所谓了...后来我们打各种mod，去对战服等...可谓是把这个游戏玩了个遍吧。后来我又去补了一下求生之路的漫画剧情，对于V社不出求生之路3，我还是心有怨念的。\n<br>那之后我好像对于丧尸，深海这些东西的抵抗力强了很多？以前偶尔看到什么\"复旦十大灵异事件\"，\"光华楼13层\"，\"同济天佑楼停尸房\"的时候还会被吓到不行，现在看一些什么\"世界4大灵异地点\"，\"奥特曼中的童年阴影\"的时候，感觉就是些毛毛雨了。后来还会有意识去看看丧尸题材电影与恐怖游戏直播，动漫也把《学园默示录》与《甲铁城的卡巴内瑞》这些给补掉了。果然自己的抗性是越来越高了哈哈。\n<br>有些恐怖游戏确实看起来很爽，但玩起来感觉却一般，因为往往这些游戏涉及到大量解密类元素，而这些元素往往又在一个狭小阴暗的房间中——要知道，我玩《上古卷轴》钻地下墓穴时都搞不清东南西北，各种撞墙，更不要说在狭小房间中玩什么躲避战与解密探索了。个人一直觉得，恐怖游戏是各种游戏种类中最难的一种游戏，其解密，战斗等元素，即使是新手级，往往也对玩家有很高的挑战——既要防止突如其来的\"高能\"，又要找到关键解密点。所以观看高端Up主们打恐怖游戏确实是一个像我这样的\"云恐怖迷\"的最好选择了。\n<br>《黎明杀机》是我见到的比较好的对战形式的恐怖游戏，音乐，氛围都渲染的极好。手游版的《第五人格》确实做的不错，但毕竟要符合社会主义核心价值观嘛，已经不算恐怖游戏了。\n<br>后来又有看SCP的一些东西，感觉网友们是真的人才，最开始编的我都以为是真的了...当然，毕竟著名的几个SCP确实很有恐怖吓人的感觉，但后来那些感觉就越来越逗比了...末日题材的小说有看过疯丢子的《末世齐祭》(在下一直男频女频不忌)，个人感觉是她所有作品中写的最好的...其他感觉都一般...\n<br>虽然大学都已经临近毕业了，但自己中二病依旧，以前看《遮天》的时候，看到源天师晚年遭遇不详的时候还是感觉有点怕怕的，后来就只觉得\"不详\"这个词真的太酷了...以致于我后来觉得自己倒霉的时候都不说自己倒霉，而说\"自己遭遇了不详\"...嘛，反正自己觉得很嗨就是了哈哈。\n<br>据说恐怖游戏制作团队多出抑郁症患者，确实这种特殊题材的游戏，要吓到玩家们的制作者们自己估计也不好受，\"我吓我自己\",\"我抑郁我自己\"这种事不在少数。我不推崇为了吓人而吓人的\"黑深残\"，有些别有用心的游戏中确实有很多猎奇变态的东西，这些我还是很讨厌与厌恶的，混入这些东西的游戏不能称之为恐怖游戏了，它们只能被称为\"遭遇不详\"的游戏。我一直觉得游戏本质就是一种艺术形式，它也应该给人们带来真善美的体验，吓人只是元素，恐怖游戏带给人的应该是对人生意义的思考与对人性黑暗面的省视。我们可以在十个小时内过完游戏主角的一生，这是我们体验另一段人生最为便捷的方式之一了(其他方式还包括读书与电视电影)。毕竟，套路见的多了，也就不会再恐惧未知了。","slug":"g_HorribleGameThinking","published":1,"updated":"2019-02-25T01:36:46.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v2f000bl8v6e7a24i86","content":"<p>自小就有点幽闭恐惧症，对于深海，封闭与未知都感到有些恐惧。动漫我基本都只看小清新与治愈系列，对于黑深残与致郁我则是向来拒而远之的。<br><br>大学最开始与室友们一起玩的游戏是《Minecraft》(我的世界)，有个同学接了学校的一个项目，然后把这个项目的服务器作为MC的服务器，大家一起在世界里面造房子打僵尸，从地狱打到末影龙，几乎记录了我们整个大二的时光。即便如此，每当我一个人上线时，面对我们造的大房子与圈养的牛羊，孤独感依旧迎面而来，一个人玩这个游戏，玩久了就真的让人感到十分压抑了…<br><br>后来我们转去一起玩《left 4 dead》(求生之路)了，这是一个人的我绝对不会玩的游戏(纵使这个游戏AI做的很棒)，宿舍四人天天打，开始还有点害怕，玩多了就感觉无所谓了…后来我们打各种mod，去对战服等…可谓是把这个游戏玩了个遍吧。后来我又去补了一下求生之路的漫画剧情，对于V社不出求生之路3，我还是心有怨念的。<br><br>那之后我好像对于丧尸，深海这些东西的抵抗力强了很多？以前偶尔看到什么”复旦十大灵异事件”，”光华楼13层”，”同济天佑楼停尸房”的时候还会被吓到不行，现在看一些什么”世界4大灵异地点”，”奥特曼中的童年阴影”的时候，感觉就是些毛毛雨了。后来还会有意识去看看丧尸题材电影与恐怖游戏直播，动漫也把《学园默示录》与《甲铁城的卡巴内瑞》这些给补掉了。果然自己的抗性是越来越高了哈哈。<br><br>有些恐怖游戏确实看起来很爽，但玩起来感觉却一般，因为往往这些游戏涉及到大量解密类元素，而这些元素往往又在一个狭小阴暗的房间中——要知道，我玩《上古卷轴》钻地下墓穴时都搞不清东南西北，各种撞墙，更不要说在狭小房间中玩什么躲避战与解密探索了。个人一直觉得，恐怖游戏是各种游戏种类中最难的一种游戏，其解密，战斗等元素，即使是新手级，往往也对玩家有很高的挑战——既要防止突如其来的”高能”，又要找到关键解密点。所以观看高端Up主们打恐怖游戏确实是一个像我这样的”云恐怖迷”的最好选择了。<br><br>《黎明杀机》是我见到的比较好的对战形式的恐怖游戏，音乐，氛围都渲染的极好。手游版的《第五人格》确实做的不错，但毕竟要符合社会主义核心价值观嘛，已经不算恐怖游戏了。<br><br>后来又有看SCP的一些东西，感觉网友们是真的人才，最开始编的我都以为是真的了…当然，毕竟著名的几个SCP确实很有恐怖吓人的感觉，但后来那些感觉就越来越逗比了…末日题材的小说有看过疯丢子的《末世齐祭》(在下一直男频女频不忌)，个人感觉是她所有作品中写的最好的…其他感觉都一般…<br><br>虽然大学都已经临近毕业了，但自己中二病依旧，以前看《遮天》的时候，看到源天师晚年遭遇不详的时候还是感觉有点怕怕的，后来就只觉得”不详”这个词真的太酷了…以致于我后来觉得自己倒霉的时候都不说自己倒霉，而说”自己遭遇了不详”…嘛，反正自己觉得很嗨就是了哈哈。<br><br>据说恐怖游戏制作团队多出抑郁症患者，确实这种特殊题材的游戏，要吓到玩家们的制作者们自己估计也不好受，”我吓我自己”,”我抑郁我自己”这种事不在少数。我不推崇为了吓人而吓人的”黑深残”，有些别有用心的游戏中确实有很多猎奇变态的东西，这些我还是很讨厌与厌恶的，混入这些东西的游戏不能称之为恐怖游戏了，它们只能被称为”遭遇不详”的游戏。我一直觉得游戏本质就是一种艺术形式，它也应该给人们带来真善美的体验，吓人只是元素，恐怖游戏带给人的应该是对人生意义的思考与对人性黑暗面的省视。我们可以在十个小时内过完游戏主角的一生，这是我们体验另一段人生最为便捷的方式之一了(其他方式还包括读书与电视电影)。毕竟，套路见的多了，也就不会再恐惧未知了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>自小就有点幽闭恐惧症，对于深海，封闭与未知都感到有些恐惧。动漫我基本都只看小清新与治愈系列，对于黑深残与致郁我则是向来拒而远之的。<br><br>大学最开始与室友们一起玩的游戏是《Minecraft》(我的世界)，有个同学接了学校的一个项目，然后把这个项目的服务器作为MC的服务器，大家一起在世界里面造房子打僵尸，从地狱打到末影龙，几乎记录了我们整个大二的时光。即便如此，每当我一个人上线时，面对我们造的大房子与圈养的牛羊，孤独感依旧迎面而来，一个人玩这个游戏，玩久了就真的让人感到十分压抑了…<br><br>后来我们转去一起玩《left 4 dead》(求生之路)了，这是一个人的我绝对不会玩的游戏(纵使这个游戏AI做的很棒)，宿舍四人天天打，开始还有点害怕，玩多了就感觉无所谓了…后来我们打各种mod，去对战服等…可谓是把这个游戏玩了个遍吧。后来我又去补了一下求生之路的漫画剧情，对于V社不出求生之路3，我还是心有怨念的。<br><br>那之后我好像对于丧尸，深海这些东西的抵抗力强了很多？以前偶尔看到什么”复旦十大灵异事件”，”光华楼13层”，”同济天佑楼停尸房”的时候还会被吓到不行，现在看一些什么”世界4大灵异地点”，”奥特曼中的童年阴影”的时候，感觉就是些毛毛雨了。后来还会有意识去看看丧尸题材电影与恐怖游戏直播，动漫也把《学园默示录》与《甲铁城的卡巴内瑞》这些给补掉了。果然自己的抗性是越来越高了哈哈。<br><br>有些恐怖游戏确实看起来很爽，但玩起来感觉却一般，因为往往这些游戏涉及到大量解密类元素，而这些元素往往又在一个狭小阴暗的房间中——要知道，我玩《上古卷轴》钻地下墓穴时都搞不清东南西北，各种撞墙，更不要说在狭小房间中玩什么躲避战与解密探索了。个人一直觉得，恐怖游戏是各种游戏种类中最难的一种游戏，其解密，战斗等元素，即使是新手级，往往也对玩家有很高的挑战——既要防止突如其来的”高能”，又要找到关键解密点。所以观看高端Up主们打恐怖游戏确实是一个像我这样的”云恐怖迷”的最好选择了。<br><br>《黎明杀机》是我见到的比较好的对战形式的恐怖游戏，音乐，氛围都渲染的极好。手游版的《第五人格》确实做的不错，但毕竟要符合社会主义核心价值观嘛，已经不算恐怖游戏了。<br><br>后来又有看SCP的一些东西，感觉网友们是真的人才，最开始编的我都以为是真的了…当然，毕竟著名的几个SCP确实很有恐怖吓人的感觉，但后来那些感觉就越来越逗比了…末日题材的小说有看过疯丢子的《末世齐祭》(在下一直男频女频不忌)，个人感觉是她所有作品中写的最好的…其他感觉都一般…<br><br>虽然大学都已经临近毕业了，但自己中二病依旧，以前看《遮天》的时候，看到源天师晚年遭遇不详的时候还是感觉有点怕怕的，后来就只觉得”不详”这个词真的太酷了…以致于我后来觉得自己倒霉的时候都不说自己倒霉，而说”自己遭遇了不详”…嘛，反正自己觉得很嗨就是了哈哈。<br><br>据说恐怖游戏制作团队多出抑郁症患者，确实这种特殊题材的游戏，要吓到玩家们的制作者们自己估计也不好受，”我吓我自己”,”我抑郁我自己”这种事不在少数。我不推崇为了吓人而吓人的”黑深残”，有些别有用心的游戏中确实有很多猎奇变态的东西，这些我还是很讨厌与厌恶的，混入这些东西的游戏不能称之为恐怖游戏了，它们只能被称为”遭遇不详”的游戏。我一直觉得游戏本质就是一种艺术形式，它也应该给人们带来真善美的体验，吓人只是元素，恐怖游戏带给人的应该是对人生意义的思考与对人性黑暗面的省视。我们可以在十个小时内过完游戏主角的一生，这是我们体验另一段人生最为便捷的方式之一了(其他方式还包括读书与电视电影)。毕竟，套路见的多了，也就不会再恐惧未知了。</p>\n"},{"title":"Unity Shader入门(二)","date":"2018-11-14T16:00:00.000Z","_content":"在[Unity Shader入门(一)](https://nature-god.github.io/2018/11/09/d_shaderLearning01/)里面，我们了解了Unity Shader的一些基本概念与结构，也就是说，我们学会了1+1=2了，接下来就让我们去解非齐次线性方程组吧...好吧开玩笑的，就和大家经常调侃的，平时上课学会受力分析，期末让你造大桥，平时上课学会增删改查，期末让你设计数据库的吐槽一般，学习曲线不能太过陡峭。本来打算这章来说一下Unity Shader学习中所必须的线性代数知识，后来想了一下，学会线代并不就是能写shader了，还是要和shader结合起来看，记忆更深，本节会简要介绍一下shader学习中必备的数学概念，具体的计算公式等会结合Unity Shader例子进行详解。\n\n说实在的，做一个程序员并不需要太多专业数学知识——因为很多时候我们调用标准库的一些函数就足够日常的开发使用了，当然这是很低级的程序员，俗称\"搬运工\"。而算法工程师对数学就要敏感的多，但有一部分也不会用到太多高等数学的东西，多是数据结构加一些优化分析。但是如果公司业务有着特殊需求——比如Adobe公司，它的PhotoShop需要对图片进行大量处理，再比如AutoDesk公司，它们的Maya建模，涉及到各个坐标系之间的变换，UV映射等更加复杂的数学运算等，又或者是时下超火的机器学习，计算机视觉这块，各种卷积微分多次偏导，这些\"很难\"的项目往往就是需要比较高的数学水平才能解决了。\n\n>计算机图形学之所以深奥难懂，很大原因在于它是建立在虚拟世界上的模型。\n\n说实在的，凡是与高等数学，线代集合概率论这些东西相关了的科目，都有点难，所以说数学系是万金油的说法也就此而来——数学水平高，啥都能干。\n### 1.笛卡尔坐标系\n#### 1.1二维笛卡尔坐标系\n>传说笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察，笛卡尔发现可以使用苍蝇离不同墙面之间的距离来描述它的当前位置。\n\n只要是接受过九年义务教育的人，就使用过笛卡尔坐标系。一个二维的笛卡尔坐标系包含了两部分的信息：\n* 一个特殊的位置，即原点，它是整个坐标系的中心\n* 两条互相垂直的矢量，即X轴与Y轴，也称为该坐标的基矢量。\n  \n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/dikaer.png\"/>\n\n原点位置是任意的，互相垂直的矢量也是任意的，因此不同的设定就会有不同的坐标表示：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/DiffCoordinate.png\"/>\n\n由于一个原点在左上，一个原点在右上，所以坐标变换计算时就可能有不同的结果。\n#### 1.2三维笛卡尔坐标系\n>人类生活在三维世界里，所以人类对低维度的空间(一维与二维)是比较容易理解的，对于同等维度(三维)理解起来就稍困难一些，而对于更高维度(四维等)的理解难度就更大了。\n\n三维笛卡尔坐标系中，我们需要定义3个坐标轴和一个原点：\n* 一个特殊的位置，即原点，它是整个坐标系的中心\n* 三条互相垂直的矢量，也称为正交基。如果它们长度为1，则称之为标准正交基(orthonormal basis)\n\n与二维笛卡尔坐标系类似，三维笛卡尔坐标系中坐标轴的方向也不是固定的，但是二维的笛卡尔坐标，你总是可以通过一系列操作：选择，翻转等将一个二维笛卡尔坐标变成一个x轴水平朝右，y轴竖直向上的坐标系。因此理论上所有二维笛卡尔坐标系都是等价的。\n\n但是三维笛卡尔坐标系不行，在某些情况下，你只能重叠x,y轴，但是z轴始终相反——由此区分出来两种坐标系：左手坐标系(Left-handed coordinate space)和右手坐标系(right-handed coordinate space)。\n<img src=\"LeftAndRight.png\">\n对于开发者而言，使用左手坐标系还是右手坐标系都可以，此间并无优劣之分。其只是在映射到视觉时会有差别。\n#### 1.3Unity中的坐标系\n在Unity中，模型空间与世界空间(简单而言就是局部坐标系与世界坐标系，原点位置不同罢了)，Unity使用的左手坐标系，即右方，上方，前方对应于x，y，z轴的正方向。但对于观察空间而言(就是摄像机为原点的坐标系)，Unity使用的时右手坐标系。即右方，上方，后方对应于x，y，z轴的正方向(面朝电脑)。因此这意味，摄像机的正前方是z轴的负方向，即z轴坐标的减少意味着场景深度的增加\n### 2.点和矢量\n矢量(vector，也就是向量)，此处需要的知识点包括：\n* 矢量的定义：n维空间中包含了模(magnitude)与方向(direction)的有向线段\n* 矢量的加减法：三角形定则\n* 矢量的模\n* 矢量与标量的乘积与除法\n* 单位矢量\n* 零矢量\n* 矢量的点积\n* 矢量的叉积\n基本知识点差不多这些了，多是初高中就学过的内容，若是有些许忘记，建议适当查下资料就够了。这些概念都还没还给老师的话，就可以继续看下下一个知识点。\n### 3.矩阵\n>矩阵，英文名matrix。matrix除去矩阵含义外，还有母体的意思，大名鼎鼎的《黑客帝国》，英文名就叫《The Matrix》\n\n矩阵的定义不用多说，用个大括号扩起来一些数字那就是了。矩阵麻烦的是和向量结合...矢量和矩阵都是一个数组，因此矢量可以看作n x 1的列矩阵或是1 x n的行矩阵了。为何要这么做呢，因为矩阵有很多好的操作与性质，很方便计算机处理。\n\n矩阵的一些基本概念：\n* 矩阵和标量的乘法\n* 矩阵和矩阵的乘法\n* 特殊矩阵：对角矩阵，方块矩阵(方阵)，单位矩阵，转置矩阵，逆矩阵，正交矩阵\n这些基本概念了解之后就行了，忘记了的多baidu或是google一下。\n### 4.Hello Unity Shader\n#### 4.1一个最简单的顶点/片元着色器\n在前面我们已经看到了Unity Shader的基本结构：\n```C\nShader \"MyShaderName\"{\n    Properties{\n        //属性\n    }\n    SubShader{\n        //针对显卡A的SubShader\n        \n        Pass{\n            //设置渲染状态与标签\n            //开始CG代码片段\n            CGPROGRAM\n            //该代码片段的编译指令\n            #pragma vertex vert\n            #pragma fragment frag\n            //CG代码\n            ENDCG\n            //其他设置\n        }\n        //其他的Pass\n    }\n    SubShader{\n        //针对显卡B的SubShader\n    }\n    //默认回掉的Unity Shader\n    Fallback \"VertexLit\"\n}\n```\nOK，现在我们进入Unity中进行实战吧！我的Unity版本：Unity 2018.2.4f1，基本各版本问题不大，但如果遇到问题，请检查下是否和Unity版本相关。\n\n1. 新建一个场景，并去掉天空盒(skybox)：删除场景中的direct light，然后选择坐上tool bar里面:Window->Rendering->LightingSetting，将Skybox material设置为none:\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/unityscreen.png\"/>\n\n2. 新建一个Unity Shader(Standrad Surface Shader)，命名为HelloShader。\n3. 新建一个Material，命名为HelloMaterial，并把第二步中新建的Unity Shader赋给它。\n4. 新建一个球体，第三步中的Material赋给它。\n5. 在HelloShader中，删除所有默认初始代码，写入以下代码\n```C\nShader \"HelloShader\"{\n\tSubShader{\n\t\tPass{\n\t\t\tCGPROGRAM\n\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\tfloat4 vert(float4 v : POSITION) : SV_POSITION{\n\t\t\t\treturn UnityObjectToClipPos (v);\n\t\t\t}\n\n\t\t\tfixed4 frag() : SV_Target {\n\t\t\t\treturn fixed4(1.0,1.0,1.0,1.0);\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/ShaderAndMaterial.png\"/>\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/HelloShader.png\"/>\n\nOk，现在我们来详细对其进行剖析：\n>Shader \"HelloShader\"\n\n此句十分简单，即是对我们自定义的Shader取名，支持\"xx/xx/xx\"的形式，良好的命名习惯有利于我们快速找到目标Shader。\n接下来是一些基本的结构，包括SubShader, Pass块等，此处代码无Properties。然后就是最为关键的CG代码块了。\n>#pragma vertex vert\n>#pragma fragment frag\n\n它们告诉Unity，哪个函数包含了顶点着色器代码，哪个函数包含了片元着色器代码。通用形式如下：\n>pragma vertex name\n>pragma fragment name\n\nname就是我们所指定的函数名，但这两个函数的名字不一定是vert和frag，但一般多用这两个，因为十分直观。\n```C\nfloat4 vert(float4 v : POSITION) : SV_POSITION{\n    return mul (UNITY_MATRIX_MVP, v);    \n}\n```\n这就是vert函数了，即我们所使用的顶点着色器代码，它是逐顶点执行的。vert函数的输入v包含了这个顶点的位置——这是通过POSITION语义指定的。\n>语义，是两个处理阶段（顶点程序、片段程序）之间的输入 / 输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如 POSITION 一般表示参数种存放的数据是顶点位置。\n\nvert函数的返回值是一个float4类型的变量，它是该顶点在裁剪空间中的位置。POSITION和SV_POSITION都是CG/HLSL中的语义(se'mantics)，这些语义将会告诉系统用户哪些需要输入值，以及用户的输出是什么。如此处POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v中，SV_POSITION将告诉Unity，顶点着色器的输出是输出是裁剪空间中的顶点坐标。\n","source":"_posts/d_shaderLearning02.md","raw":"---\ntitle: Unity Shader入门(二)\ndate: 2018-11-15\ntag: Unity Shader\n---\n在[Unity Shader入门(一)](https://nature-god.github.io/2018/11/09/d_shaderLearning01/)里面，我们了解了Unity Shader的一些基本概念与结构，也就是说，我们学会了1+1=2了，接下来就让我们去解非齐次线性方程组吧...好吧开玩笑的，就和大家经常调侃的，平时上课学会受力分析，期末让你造大桥，平时上课学会增删改查，期末让你设计数据库的吐槽一般，学习曲线不能太过陡峭。本来打算这章来说一下Unity Shader学习中所必须的线性代数知识，后来想了一下，学会线代并不就是能写shader了，还是要和shader结合起来看，记忆更深，本节会简要介绍一下shader学习中必备的数学概念，具体的计算公式等会结合Unity Shader例子进行详解。\n\n说实在的，做一个程序员并不需要太多专业数学知识——因为很多时候我们调用标准库的一些函数就足够日常的开发使用了，当然这是很低级的程序员，俗称\"搬运工\"。而算法工程师对数学就要敏感的多，但有一部分也不会用到太多高等数学的东西，多是数据结构加一些优化分析。但是如果公司业务有着特殊需求——比如Adobe公司，它的PhotoShop需要对图片进行大量处理，再比如AutoDesk公司，它们的Maya建模，涉及到各个坐标系之间的变换，UV映射等更加复杂的数学运算等，又或者是时下超火的机器学习，计算机视觉这块，各种卷积微分多次偏导，这些\"很难\"的项目往往就是需要比较高的数学水平才能解决了。\n\n>计算机图形学之所以深奥难懂，很大原因在于它是建立在虚拟世界上的模型。\n\n说实在的，凡是与高等数学，线代集合概率论这些东西相关了的科目，都有点难，所以说数学系是万金油的说法也就此而来——数学水平高，啥都能干。\n### 1.笛卡尔坐标系\n#### 1.1二维笛卡尔坐标系\n>传说笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察，笛卡尔发现可以使用苍蝇离不同墙面之间的距离来描述它的当前位置。\n\n只要是接受过九年义务教育的人，就使用过笛卡尔坐标系。一个二维的笛卡尔坐标系包含了两部分的信息：\n* 一个特殊的位置，即原点，它是整个坐标系的中心\n* 两条互相垂直的矢量，即X轴与Y轴，也称为该坐标的基矢量。\n  \n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/dikaer.png\"/>\n\n原点位置是任意的，互相垂直的矢量也是任意的，因此不同的设定就会有不同的坐标表示：\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/DiffCoordinate.png\"/>\n\n由于一个原点在左上，一个原点在右上，所以坐标变换计算时就可能有不同的结果。\n#### 1.2三维笛卡尔坐标系\n>人类生活在三维世界里，所以人类对低维度的空间(一维与二维)是比较容易理解的，对于同等维度(三维)理解起来就稍困难一些，而对于更高维度(四维等)的理解难度就更大了。\n\n三维笛卡尔坐标系中，我们需要定义3个坐标轴和一个原点：\n* 一个特殊的位置，即原点，它是整个坐标系的中心\n* 三条互相垂直的矢量，也称为正交基。如果它们长度为1，则称之为标准正交基(orthonormal basis)\n\n与二维笛卡尔坐标系类似，三维笛卡尔坐标系中坐标轴的方向也不是固定的，但是二维的笛卡尔坐标，你总是可以通过一系列操作：选择，翻转等将一个二维笛卡尔坐标变成一个x轴水平朝右，y轴竖直向上的坐标系。因此理论上所有二维笛卡尔坐标系都是等价的。\n\n但是三维笛卡尔坐标系不行，在某些情况下，你只能重叠x,y轴，但是z轴始终相反——由此区分出来两种坐标系：左手坐标系(Left-handed coordinate space)和右手坐标系(right-handed coordinate space)。\n<img src=\"LeftAndRight.png\">\n对于开发者而言，使用左手坐标系还是右手坐标系都可以，此间并无优劣之分。其只是在映射到视觉时会有差别。\n#### 1.3Unity中的坐标系\n在Unity中，模型空间与世界空间(简单而言就是局部坐标系与世界坐标系，原点位置不同罢了)，Unity使用的左手坐标系，即右方，上方，前方对应于x，y，z轴的正方向。但对于观察空间而言(就是摄像机为原点的坐标系)，Unity使用的时右手坐标系。即右方，上方，后方对应于x，y，z轴的正方向(面朝电脑)。因此这意味，摄像机的正前方是z轴的负方向，即z轴坐标的减少意味着场景深度的增加\n### 2.点和矢量\n矢量(vector，也就是向量)，此处需要的知识点包括：\n* 矢量的定义：n维空间中包含了模(magnitude)与方向(direction)的有向线段\n* 矢量的加减法：三角形定则\n* 矢量的模\n* 矢量与标量的乘积与除法\n* 单位矢量\n* 零矢量\n* 矢量的点积\n* 矢量的叉积\n基本知识点差不多这些了，多是初高中就学过的内容，若是有些许忘记，建议适当查下资料就够了。这些概念都还没还给老师的话，就可以继续看下下一个知识点。\n### 3.矩阵\n>矩阵，英文名matrix。matrix除去矩阵含义外，还有母体的意思，大名鼎鼎的《黑客帝国》，英文名就叫《The Matrix》\n\n矩阵的定义不用多说，用个大括号扩起来一些数字那就是了。矩阵麻烦的是和向量结合...矢量和矩阵都是一个数组，因此矢量可以看作n x 1的列矩阵或是1 x n的行矩阵了。为何要这么做呢，因为矩阵有很多好的操作与性质，很方便计算机处理。\n\n矩阵的一些基本概念：\n* 矩阵和标量的乘法\n* 矩阵和矩阵的乘法\n* 特殊矩阵：对角矩阵，方块矩阵(方阵)，单位矩阵，转置矩阵，逆矩阵，正交矩阵\n这些基本概念了解之后就行了，忘记了的多baidu或是google一下。\n### 4.Hello Unity Shader\n#### 4.1一个最简单的顶点/片元着色器\n在前面我们已经看到了Unity Shader的基本结构：\n```C\nShader \"MyShaderName\"{\n    Properties{\n        //属性\n    }\n    SubShader{\n        //针对显卡A的SubShader\n        \n        Pass{\n            //设置渲染状态与标签\n            //开始CG代码片段\n            CGPROGRAM\n            //该代码片段的编译指令\n            #pragma vertex vert\n            #pragma fragment frag\n            //CG代码\n            ENDCG\n            //其他设置\n        }\n        //其他的Pass\n    }\n    SubShader{\n        //针对显卡B的SubShader\n    }\n    //默认回掉的Unity Shader\n    Fallback \"VertexLit\"\n}\n```\nOK，现在我们进入Unity中进行实战吧！我的Unity版本：Unity 2018.2.4f1，基本各版本问题不大，但如果遇到问题，请检查下是否和Unity版本相关。\n\n1. 新建一个场景，并去掉天空盒(skybox)：删除场景中的direct light，然后选择坐上tool bar里面:Window->Rendering->LightingSetting，将Skybox material设置为none:\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/unityscreen.png\"/>\n\n2. 新建一个Unity Shader(Standrad Surface Shader)，命名为HelloShader。\n3. 新建一个Material，命名为HelloMaterial，并把第二步中新建的Unity Shader赋给它。\n4. 新建一个球体，第三步中的Material赋给它。\n5. 在HelloShader中，删除所有默认初始代码，写入以下代码\n```C\nShader \"HelloShader\"{\n\tSubShader{\n\t\tPass{\n\t\t\tCGPROGRAM\n\n\t\t\t#pragma vertex vert\n\t\t\t#pragma fragment frag\n\n\t\t\tfloat4 vert(float4 v : POSITION) : SV_POSITION{\n\t\t\t\treturn UnityObjectToClipPos (v);\n\t\t\t}\n\n\t\t\tfixed4 frag() : SV_Target {\n\t\t\t\treturn fixed4(1.0,1.0,1.0,1.0);\n\t\t\t}\n\t\t\tENDCG\n\t\t}\n\t}\n}\n```\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/ShaderAndMaterial.png\"/>\n\n<img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/HelloShader.png\"/>\n\nOk，现在我们来详细对其进行剖析：\n>Shader \"HelloShader\"\n\n此句十分简单，即是对我们自定义的Shader取名，支持\"xx/xx/xx\"的形式，良好的命名习惯有利于我们快速找到目标Shader。\n接下来是一些基本的结构，包括SubShader, Pass块等，此处代码无Properties。然后就是最为关键的CG代码块了。\n>#pragma vertex vert\n>#pragma fragment frag\n\n它们告诉Unity，哪个函数包含了顶点着色器代码，哪个函数包含了片元着色器代码。通用形式如下：\n>pragma vertex name\n>pragma fragment name\n\nname就是我们所指定的函数名，但这两个函数的名字不一定是vert和frag，但一般多用这两个，因为十分直观。\n```C\nfloat4 vert(float4 v : POSITION) : SV_POSITION{\n    return mul (UNITY_MATRIX_MVP, v);    \n}\n```\n这就是vert函数了，即我们所使用的顶点着色器代码，它是逐顶点执行的。vert函数的输入v包含了这个顶点的位置——这是通过POSITION语义指定的。\n>语义，是两个处理阶段（顶点程序、片段程序）之间的输入 / 输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如 POSITION 一般表示参数种存放的数据是顶点位置。\n\nvert函数的返回值是一个float4类型的变量，它是该顶点在裁剪空间中的位置。POSITION和SV_POSITION都是CG/HLSL中的语义(se'mantics)，这些语义将会告诉系统用户哪些需要输入值，以及用户的输出是什么。如此处POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v中，SV_POSITION将告诉Unity，顶点着色器的输出是输出是裁剪空间中的顶点坐标。\n","slug":"d_shaderLearning02","published":1,"updated":"2019-02-25T01:36:46.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v37000ol8v6w17q4588","content":"<p>在<a href=\"https://nature-god.github.io/2018/11/09/d_shaderLearning01/\" target=\"_blank\" rel=\"noopener\">Unity Shader入门(一)</a>里面，我们了解了Unity Shader的一些基本概念与结构，也就是说，我们学会了1+1=2了，接下来就让我们去解非齐次线性方程组吧…好吧开玩笑的，就和大家经常调侃的，平时上课学会受力分析，期末让你造大桥，平时上课学会增删改查，期末让你设计数据库的吐槽一般，学习曲线不能太过陡峭。本来打算这章来说一下Unity Shader学习中所必须的线性代数知识，后来想了一下，学会线代并不就是能写shader了，还是要和shader结合起来看，记忆更深，本节会简要介绍一下shader学习中必备的数学概念，具体的计算公式等会结合Unity Shader例子进行详解。</p>\n<p>说实在的，做一个程序员并不需要太多专业数学知识——因为很多时候我们调用标准库的一些函数就足够日常的开发使用了，当然这是很低级的程序员，俗称”搬运工”。而算法工程师对数学就要敏感的多，但有一部分也不会用到太多高等数学的东西，多是数据结构加一些优化分析。但是如果公司业务有着特殊需求——比如Adobe公司，它的PhotoShop需要对图片进行大量处理，再比如AutoDesk公司，它们的Maya建模，涉及到各个坐标系之间的变换，UV映射等更加复杂的数学运算等，又或者是时下超火的机器学习，计算机视觉这块，各种卷积微分多次偏导，这些”很难”的项目往往就是需要比较高的数学水平才能解决了。</p>\n<blockquote>\n<p>计算机图形学之所以深奥难懂，很大原因在于它是建立在虚拟世界上的模型。</p>\n</blockquote>\n<p>说实在的，凡是与高等数学，线代集合概率论这些东西相关了的科目，都有点难，所以说数学系是万金油的说法也就此而来——数学水平高，啥都能干。</p>\n<h3 id=\"1-笛卡尔坐标系\"><a href=\"#1-笛卡尔坐标系\" class=\"headerlink\" title=\"1.笛卡尔坐标系\"></a>1.笛卡尔坐标系</h3><h4 id=\"1-1二维笛卡尔坐标系\"><a href=\"#1-1二维笛卡尔坐标系\" class=\"headerlink\" title=\"1.1二维笛卡尔坐标系\"></a>1.1二维笛卡尔坐标系</h4><blockquote>\n<p>传说笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察，笛卡尔发现可以使用苍蝇离不同墙面之间的距离来描述它的当前位置。</p>\n</blockquote>\n<p>只要是接受过九年义务教育的人，就使用过笛卡尔坐标系。一个二维的笛卡尔坐标系包含了两部分的信息：</p>\n<ul>\n<li>一个特殊的位置，即原点，它是整个坐标系的中心</li>\n<li>两条互相垂直的矢量，即X轴与Y轴，也称为该坐标的基矢量。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/dikaer.png\"></p>\n<p>原点位置是任意的，互相垂直的矢量也是任意的，因此不同的设定就会有不同的坐标表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/DiffCoordinate.png\"></p>\n<p>由于一个原点在左上，一个原点在右上，所以坐标变换计算时就可能有不同的结果。</p>\n<h4 id=\"1-2三维笛卡尔坐标系\"><a href=\"#1-2三维笛卡尔坐标系\" class=\"headerlink\" title=\"1.2三维笛卡尔坐标系\"></a>1.2三维笛卡尔坐标系</h4><blockquote>\n<p>人类生活在三维世界里，所以人类对低维度的空间(一维与二维)是比较容易理解的，对于同等维度(三维)理解起来就稍困难一些，而对于更高维度(四维等)的理解难度就更大了。</p>\n</blockquote>\n<p>三维笛卡尔坐标系中，我们需要定义3个坐标轴和一个原点：</p>\n<ul>\n<li>一个特殊的位置，即原点，它是整个坐标系的中心</li>\n<li>三条互相垂直的矢量，也称为正交基。如果它们长度为1，则称之为标准正交基(orthonormal basis)</li>\n</ul>\n<p>与二维笛卡尔坐标系类似，三维笛卡尔坐标系中坐标轴的方向也不是固定的，但是二维的笛卡尔坐标，你总是可以通过一系列操作：选择，翻转等将一个二维笛卡尔坐标变成一个x轴水平朝右，y轴竖直向上的坐标系。因此理论上所有二维笛卡尔坐标系都是等价的。</p>\n<p>但是三维笛卡尔坐标系不行，在某些情况下，你只能重叠x,y轴，但是z轴始终相反——由此区分出来两种坐标系：左手坐标系(Left-handed coordinate space)和右手坐标系(right-handed coordinate space)。<br><img src=\"LeftAndRight.png\"><br>对于开发者而言，使用左手坐标系还是右手坐标系都可以，此间并无优劣之分。其只是在映射到视觉时会有差别。</p>\n<h4 id=\"1-3Unity中的坐标系\"><a href=\"#1-3Unity中的坐标系\" class=\"headerlink\" title=\"1.3Unity中的坐标系\"></a>1.3Unity中的坐标系</h4><p>在Unity中，模型空间与世界空间(简单而言就是局部坐标系与世界坐标系，原点位置不同罢了)，Unity使用的左手坐标系，即右方，上方，前方对应于x，y，z轴的正方向。但对于观察空间而言(就是摄像机为原点的坐标系)，Unity使用的时右手坐标系。即右方，上方，后方对应于x，y，z轴的正方向(面朝电脑)。因此这意味，摄像机的正前方是z轴的负方向，即z轴坐标的减少意味着场景深度的增加</p>\n<h3 id=\"2-点和矢量\"><a href=\"#2-点和矢量\" class=\"headerlink\" title=\"2.点和矢量\"></a>2.点和矢量</h3><p>矢量(vector，也就是向量)，此处需要的知识点包括：</p>\n<ul>\n<li>矢量的定义：n维空间中包含了模(magnitude)与方向(direction)的有向线段</li>\n<li>矢量的加减法：三角形定则</li>\n<li>矢量的模</li>\n<li>矢量与标量的乘积与除法</li>\n<li>单位矢量</li>\n<li>零矢量</li>\n<li>矢量的点积</li>\n<li>矢量的叉积<br>基本知识点差不多这些了，多是初高中就学过的内容，若是有些许忘记，建议适当查下资料就够了。这些概念都还没还给老师的话，就可以继续看下下一个知识点。<h3 id=\"3-矩阵\"><a href=\"#3-矩阵\" class=\"headerlink\" title=\"3.矩阵\"></a>3.矩阵</h3><blockquote>\n<p>矩阵，英文名matrix。matrix除去矩阵含义外，还有母体的意思，大名鼎鼎的《黑客帝国》，英文名就叫《The Matrix》</p>\n</blockquote>\n</li>\n</ul>\n<p>矩阵的定义不用多说，用个大括号扩起来一些数字那就是了。矩阵麻烦的是和向量结合…矢量和矩阵都是一个数组，因此矢量可以看作n x 1的列矩阵或是1 x n的行矩阵了。为何要这么做呢，因为矩阵有很多好的操作与性质，很方便计算机处理。</p>\n<p>矩阵的一些基本概念：</p>\n<ul>\n<li>矩阵和标量的乘法</li>\n<li>矩阵和矩阵的乘法</li>\n<li>特殊矩阵：对角矩阵，方块矩阵(方阵)，单位矩阵，转置矩阵，逆矩阵，正交矩阵<br>这些基本概念了解之后就行了，忘记了的多baidu或是google一下。<h3 id=\"4-Hello-Unity-Shader\"><a href=\"#4-Hello-Unity-Shader\" class=\"headerlink\" title=\"4.Hello Unity Shader\"></a>4.Hello Unity Shader</h3><h4 id=\"4-1一个最简单的顶点-片元着色器\"><a href=\"#4-1一个最简单的顶点-片元着色器\" class=\"headerlink\" title=\"4.1一个最简单的顶点/片元着色器\"></a>4.1一个最简单的顶点/片元着色器</h4>在前面我们已经看到了Unity Shader的基本结构：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"MyShaderName\"</span>&#123;</span><br><span class=\"line\">    Properties&#123;</span><br><span class=\"line\">        <span class=\"comment\">//属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        <span class=\"comment\">//针对显卡A的SubShader</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Pass&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置渲染状态与标签</span></span><br><span class=\"line\">            <span class=\"comment\">//开始CG代码片段</span></span><br><span class=\"line\">            CGPROGRAM</span><br><span class=\"line\">            <span class=\"comment\">//该代码片段的编译指令</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\">            <span class=\"comment\">//CG代码</span></span><br><span class=\"line\">            ENDCG</span><br><span class=\"line\">            <span class=\"comment\">//其他设置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//其他的Pass</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        <span class=\"comment\">//针对显卡B的SubShader</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//默认回掉的Unity Shader</span></span><br><span class=\"line\">    Fallback <span class=\"string\">\"VertexLit\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>OK，现在我们进入Unity中进行实战吧！我的Unity版本：Unity 2018.2.4f1，基本各版本问题不大，但如果遇到问题，请检查下是否和Unity版本相关。</p>\n<ol>\n<li>新建一个场景，并去掉天空盒(skybox)：删除场景中的direct light，然后选择坐上tool bar里面:Window-&gt;Rendering-&gt;LightingSetting，将Skybox material设置为none:</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/unityscreen.png\"></p>\n<ol start=\"2\">\n<li>新建一个Unity Shader(Standrad Surface Shader)，命名为HelloShader。</li>\n<li>新建一个Material，命名为HelloMaterial，并把第二步中新建的Unity Shader赋给它。</li>\n<li>新建一个球体，第三步中的Material赋给它。</li>\n<li>在HelloShader中，删除所有默认初始代码，写入以下代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"HelloShader\"</span>&#123;</span><br><span class=\"line\">\tSubShader&#123;</span><br><span class=\"line\">\t\tPass&#123;</span><br><span class=\"line\">\t\t\tCGPROGRAM</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfloat4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> UnityObjectToClipPos (v);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfixed4 frag() : SV_Target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fixed4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tENDCG</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/ShaderAndMaterial.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/HelloShader.png\"></p>\n<p>Ok，现在我们来详细对其进行剖析：</p>\n<blockquote>\n<p>Shader “HelloShader”</p>\n</blockquote>\n<p>此句十分简单，即是对我们自定义的Shader取名，支持”xx/xx/xx”的形式，良好的命名习惯有利于我们快速找到目标Shader。<br>接下来是一些基本的结构，包括SubShader, Pass块等，此处代码无Properties。然后就是最为关键的CG代码块了。</p>\n<blockquote>\n<p>#pragma vertex vert</p>\n<p>#pragma fragment frag</p>\n</blockquote>\n<p>它们告诉Unity，哪个函数包含了顶点着色器代码，哪个函数包含了片元着色器代码。通用形式如下：</p>\n<blockquote>\n<p>pragma vertex name<br>pragma fragment name</p>\n</blockquote>\n<p>name就是我们所指定的函数名，但这两个函数的名字不一定是vert和frag，但一般多用这两个，因为十分直观。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mul (UNITY_MATRIX_MVP, v);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是vert函数了，即我们所使用的顶点着色器代码，它是逐顶点执行的。vert函数的输入v包含了这个顶点的位置——这是通过POSITION语义指定的。</p>\n<blockquote>\n<p>语义，是两个处理阶段（顶点程序、片段程序）之间的输入 / 输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如 POSITION 一般表示参数种存放的数据是顶点位置。</p>\n</blockquote>\n<p>vert函数的返回值是一个float4类型的变量，它是该顶点在裁剪空间中的位置。POSITION和SV_POSITION都是CG/HLSL中的语义(se’mantics)，这些语义将会告诉系统用户哪些需要输入值，以及用户的输出是什么。如此处POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v中，SV_POSITION将告诉Unity，顶点着色器的输出是输出是裁剪空间中的顶点坐标。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://nature-god.github.io/2018/11/09/d_shaderLearning01/\" target=\"_blank\" rel=\"noopener\">Unity Shader入门(一)</a>里面，我们了解了Unity Shader的一些基本概念与结构，也就是说，我们学会了1+1=2了，接下来就让我们去解非齐次线性方程组吧…好吧开玩笑的，就和大家经常调侃的，平时上课学会受力分析，期末让你造大桥，平时上课学会增删改查，期末让你设计数据库的吐槽一般，学习曲线不能太过陡峭。本来打算这章来说一下Unity Shader学习中所必须的线性代数知识，后来想了一下，学会线代并不就是能写shader了，还是要和shader结合起来看，记忆更深，本节会简要介绍一下shader学习中必备的数学概念，具体的计算公式等会结合Unity Shader例子进行详解。</p>\n<p>说实在的，做一个程序员并不需要太多专业数学知识——因为很多时候我们调用标准库的一些函数就足够日常的开发使用了，当然这是很低级的程序员，俗称”搬运工”。而算法工程师对数学就要敏感的多，但有一部分也不会用到太多高等数学的东西，多是数据结构加一些优化分析。但是如果公司业务有着特殊需求——比如Adobe公司，它的PhotoShop需要对图片进行大量处理，再比如AutoDesk公司，它们的Maya建模，涉及到各个坐标系之间的变换，UV映射等更加复杂的数学运算等，又或者是时下超火的机器学习，计算机视觉这块，各种卷积微分多次偏导，这些”很难”的项目往往就是需要比较高的数学水平才能解决了。</p>\n<blockquote>\n<p>计算机图形学之所以深奥难懂，很大原因在于它是建立在虚拟世界上的模型。</p>\n</blockquote>\n<p>说实在的，凡是与高等数学，线代集合概率论这些东西相关了的科目，都有点难，所以说数学系是万金油的说法也就此而来——数学水平高，啥都能干。</p>\n<h3 id=\"1-笛卡尔坐标系\"><a href=\"#1-笛卡尔坐标系\" class=\"headerlink\" title=\"1.笛卡尔坐标系\"></a>1.笛卡尔坐标系</h3><h4 id=\"1-1二维笛卡尔坐标系\"><a href=\"#1-1二维笛卡尔坐标系\" class=\"headerlink\" title=\"1.1二维笛卡尔坐标系\"></a>1.1二维笛卡尔坐标系</h4><blockquote>\n<p>传说笛卡尔坐标系来源于笛卡尔对天花板上一只苍蝇的运动轨迹的观察，笛卡尔发现可以使用苍蝇离不同墙面之间的距离来描述它的当前位置。</p>\n</blockquote>\n<p>只要是接受过九年义务教育的人，就使用过笛卡尔坐标系。一个二维的笛卡尔坐标系包含了两部分的信息：</p>\n<ul>\n<li>一个特殊的位置，即原点，它是整个坐标系的中心</li>\n<li>两条互相垂直的矢量，即X轴与Y轴，也称为该坐标的基矢量。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/dikaer.png\"></p>\n<p>原点位置是任意的，互相垂直的矢量也是任意的，因此不同的设定就会有不同的坐标表示：</p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/DiffCoordinate.png\"></p>\n<p>由于一个原点在左上，一个原点在右上，所以坐标变换计算时就可能有不同的结果。</p>\n<h4 id=\"1-2三维笛卡尔坐标系\"><a href=\"#1-2三维笛卡尔坐标系\" class=\"headerlink\" title=\"1.2三维笛卡尔坐标系\"></a>1.2三维笛卡尔坐标系</h4><blockquote>\n<p>人类生活在三维世界里，所以人类对低维度的空间(一维与二维)是比较容易理解的，对于同等维度(三维)理解起来就稍困难一些，而对于更高维度(四维等)的理解难度就更大了。</p>\n</blockquote>\n<p>三维笛卡尔坐标系中，我们需要定义3个坐标轴和一个原点：</p>\n<ul>\n<li>一个特殊的位置，即原点，它是整个坐标系的中心</li>\n<li>三条互相垂直的矢量，也称为正交基。如果它们长度为1，则称之为标准正交基(orthonormal basis)</li>\n</ul>\n<p>与二维笛卡尔坐标系类似，三维笛卡尔坐标系中坐标轴的方向也不是固定的，但是二维的笛卡尔坐标，你总是可以通过一系列操作：选择，翻转等将一个二维笛卡尔坐标变成一个x轴水平朝右，y轴竖直向上的坐标系。因此理论上所有二维笛卡尔坐标系都是等价的。</p>\n<p>但是三维笛卡尔坐标系不行，在某些情况下，你只能重叠x,y轴，但是z轴始终相反——由此区分出来两种坐标系：左手坐标系(Left-handed coordinate space)和右手坐标系(right-handed coordinate space)。<br><img src=\"LeftAndRight.png\"><br>对于开发者而言，使用左手坐标系还是右手坐标系都可以，此间并无优劣之分。其只是在映射到视觉时会有差别。</p>\n<h4 id=\"1-3Unity中的坐标系\"><a href=\"#1-3Unity中的坐标系\" class=\"headerlink\" title=\"1.3Unity中的坐标系\"></a>1.3Unity中的坐标系</h4><p>在Unity中，模型空间与世界空间(简单而言就是局部坐标系与世界坐标系，原点位置不同罢了)，Unity使用的左手坐标系，即右方，上方，前方对应于x，y，z轴的正方向。但对于观察空间而言(就是摄像机为原点的坐标系)，Unity使用的时右手坐标系。即右方，上方，后方对应于x，y，z轴的正方向(面朝电脑)。因此这意味，摄像机的正前方是z轴的负方向，即z轴坐标的减少意味着场景深度的增加</p>\n<h3 id=\"2-点和矢量\"><a href=\"#2-点和矢量\" class=\"headerlink\" title=\"2.点和矢量\"></a>2.点和矢量</h3><p>矢量(vector，也就是向量)，此处需要的知识点包括：</p>\n<ul>\n<li>矢量的定义：n维空间中包含了模(magnitude)与方向(direction)的有向线段</li>\n<li>矢量的加减法：三角形定则</li>\n<li>矢量的模</li>\n<li>矢量与标量的乘积与除法</li>\n<li>单位矢量</li>\n<li>零矢量</li>\n<li>矢量的点积</li>\n<li>矢量的叉积<br>基本知识点差不多这些了，多是初高中就学过的内容，若是有些许忘记，建议适当查下资料就够了。这些概念都还没还给老师的话，就可以继续看下下一个知识点。<h3 id=\"3-矩阵\"><a href=\"#3-矩阵\" class=\"headerlink\" title=\"3.矩阵\"></a>3.矩阵</h3><blockquote>\n<p>矩阵，英文名matrix。matrix除去矩阵含义外，还有母体的意思，大名鼎鼎的《黑客帝国》，英文名就叫《The Matrix》</p>\n</blockquote>\n</li>\n</ul>\n<p>矩阵的定义不用多说，用个大括号扩起来一些数字那就是了。矩阵麻烦的是和向量结合…矢量和矩阵都是一个数组，因此矢量可以看作n x 1的列矩阵或是1 x n的行矩阵了。为何要这么做呢，因为矩阵有很多好的操作与性质，很方便计算机处理。</p>\n<p>矩阵的一些基本概念：</p>\n<ul>\n<li>矩阵和标量的乘法</li>\n<li>矩阵和矩阵的乘法</li>\n<li>特殊矩阵：对角矩阵，方块矩阵(方阵)，单位矩阵，转置矩阵，逆矩阵，正交矩阵<br>这些基本概念了解之后就行了，忘记了的多baidu或是google一下。<h3 id=\"4-Hello-Unity-Shader\"><a href=\"#4-Hello-Unity-Shader\" class=\"headerlink\" title=\"4.Hello Unity Shader\"></a>4.Hello Unity Shader</h3><h4 id=\"4-1一个最简单的顶点-片元着色器\"><a href=\"#4-1一个最简单的顶点-片元着色器\" class=\"headerlink\" title=\"4.1一个最简单的顶点/片元着色器\"></a>4.1一个最简单的顶点/片元着色器</h4>在前面我们已经看到了Unity Shader的基本结构：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"MyShaderName\"</span>&#123;</span><br><span class=\"line\">    Properties&#123;</span><br><span class=\"line\">        <span class=\"comment\">//属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        <span class=\"comment\">//针对显卡A的SubShader</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        Pass&#123;</span><br><span class=\"line\">            <span class=\"comment\">//设置渲染状态与标签</span></span><br><span class=\"line\">            <span class=\"comment\">//开始CG代码片段</span></span><br><span class=\"line\">            CGPROGRAM</span><br><span class=\"line\">            <span class=\"comment\">//该代码片段的编译指令</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\">            <span class=\"comment\">//CG代码</span></span><br><span class=\"line\">            ENDCG</span><br><span class=\"line\">            <span class=\"comment\">//其他设置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//其他的Pass</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        <span class=\"comment\">//针对显卡B的SubShader</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//默认回掉的Unity Shader</span></span><br><span class=\"line\">    Fallback <span class=\"string\">\"VertexLit\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>OK，现在我们进入Unity中进行实战吧！我的Unity版本：Unity 2018.2.4f1，基本各版本问题不大，但如果遇到问题，请检查下是否和Unity版本相关。</p>\n<ol>\n<li>新建一个场景，并去掉天空盒(skybox)：删除场景中的direct light，然后选择坐上tool bar里面:Window-&gt;Rendering-&gt;LightingSetting，将Skybox material设置为none:</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/unityscreen.png\"></p>\n<ol start=\"2\">\n<li>新建一个Unity Shader(Standrad Surface Shader)，命名为HelloShader。</li>\n<li>新建一个Material，命名为HelloMaterial，并把第二步中新建的Unity Shader赋给它。</li>\n<li>新建一个球体，第三步中的Material赋给它。</li>\n<li>在HelloShader中，删除所有默认初始代码，写入以下代码<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"HelloShader\"</span>&#123;</span><br><span class=\"line\">\tSubShader&#123;</span><br><span class=\"line\">\t\tPass&#123;</span><br><span class=\"line\">\t\t\tCGPROGRAM</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">\t\t\t<span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfloat4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> UnityObjectToClipPos (v);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tfixed4 frag() : SV_Target &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fixed4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tENDCG</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/ShaderAndMaterial.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader02/HelloShader.png\"></p>\n<p>Ok，现在我们来详细对其进行剖析：</p>\n<blockquote>\n<p>Shader “HelloShader”</p>\n</blockquote>\n<p>此句十分简单，即是对我们自定义的Shader取名，支持”xx/xx/xx”的形式，良好的命名习惯有利于我们快速找到目标Shader。<br>接下来是一些基本的结构，包括SubShader, Pass块等，此处代码无Properties。然后就是最为关键的CG代码块了。</p>\n<blockquote>\n<p>#pragma vertex vert</p>\n<p>#pragma fragment frag</p>\n</blockquote>\n<p>它们告诉Unity，哪个函数包含了顶点着色器代码，哪个函数包含了片元着色器代码。通用形式如下：</p>\n<blockquote>\n<p>pragma vertex name<br>pragma fragment name</p>\n</blockquote>\n<p>name就是我们所指定的函数名，但这两个函数的名字不一定是vert和frag，但一般多用这两个，因为十分直观。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mul (UNITY_MATRIX_MVP, v);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是vert函数了，即我们所使用的顶点着色器代码，它是逐顶点执行的。vert函数的输入v包含了这个顶点的位置——这是通过POSITION语义指定的。</p>\n<blockquote>\n<p>语义，是两个处理阶段（顶点程序、片段程序）之间的输入 / 输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如 POSITION 一般表示参数种存放的数据是顶点位置。</p>\n</blockquote>\n<p>vert函数的返回值是一个float4类型的变量，它是该顶点在裁剪空间中的位置。POSITION和SV_POSITION都是CG/HLSL中的语义(se’mantics)，这些语义将会告诉系统用户哪些需要输入值，以及用户的输出是什么。如此处POSITION将告诉Unity，把模型的顶点坐标填充到输入参数v中，SV_POSITION将告诉Unity，顶点着色器的输出是输出是裁剪空间中的顶点坐标。</p>\n"},{"title":"Mono与C#","date":"2018-12-19T16:00:00.000Z","_content":"聊一聊Mono与C#的关系等等","source":"_posts/h_UnityAndC#.md","raw":"---\ntitle: Mono与C#\ndate: 2018-12-20\ntag: Unity\n---\n聊一聊Mono与C#的关系等等","slug":"h_UnityAndC#","published":1,"updated":"2019-02-25T01:36:46.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v38000pl8v6wtp656iq","content":"<p>聊一聊Mono与C#的关系等等</p>\n","site":{"data":{}},"excerpt":"","more":"<p>聊一聊Mono与C#的关系等等</p>\n"},{"title":"从零开始的2048","date":"2018-12-19T16:00:00.000Z","_content":"2048是一个非常有意思的小游戏，它基本不需要美工，又有一定的可玩性，很适合练练手。\n### 游戏玩法与规则\n>2048的玩法很简单，它由一个4X4的方块阵列所组成，玩家可以通过\"上下左右\"键进行格子的移动。每次操作会让所有的格子都向\"上/下/左/右\"进行移动，相同数字的格子会合并成为一个新的格子，数字为合并格子数字之和。每次操作之后，会在空白的格子处随机生成一个2或4，最终得到一个2048的方块，则就算胜利了。如果16个格子全部填满并且相邻格子都不相同，也就是无法移动的话，则游戏结束，game over。","source":"_posts/i_2048Game.md","raw":"---\ntitle: 从零开始的2048\ndate: 2018-12-20\ntag: Unity\n---\n2048是一个非常有意思的小游戏，它基本不需要美工，又有一定的可玩性，很适合练练手。\n### 游戏玩法与规则\n>2048的玩法很简单，它由一个4X4的方块阵列所组成，玩家可以通过\"上下左右\"键进行格子的移动。每次操作会让所有的格子都向\"上/下/左/右\"进行移动，相同数字的格子会合并成为一个新的格子，数字为合并格子数字之和。每次操作之后，会在空白的格子处随机生成一个2或4，最终得到一个2048的方块，则就算胜利了。如果16个格子全部填满并且相邻格子都不相同，也就是无法移动的话，则游戏结束，game over。","slug":"i_2048Game","published":1,"updated":"2019-02-25T01:39:53.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v3f000rl8v660s7vw6s","content":"<p>2048是一个非常有意思的小游戏，它基本不需要美工，又有一定的可玩性，很适合练练手。</p>\n<h3 id=\"游戏玩法与规则\"><a href=\"#游戏玩法与规则\" class=\"headerlink\" title=\"游戏玩法与规则\"></a>游戏玩法与规则</h3><blockquote>\n<p>2048的玩法很简单，它由一个4X4的方块阵列所组成，玩家可以通过”上下左右”键进行格子的移动。每次操作会让所有的格子都向”上/下/左/右”进行移动，相同数字的格子会合并成为一个新的格子，数字为合并格子数字之和。每次操作之后，会在空白的格子处随机生成一个2或4，最终得到一个2048的方块，则就算胜利了。如果16个格子全部填满并且相邻格子都不相同，也就是无法移动的话，则游戏结束，game over。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>2048是一个非常有意思的小游戏，它基本不需要美工，又有一定的可玩性，很适合练练手。</p>\n<h3 id=\"游戏玩法与规则\"><a href=\"#游戏玩法与规则\" class=\"headerlink\" title=\"游戏玩法与规则\"></a>游戏玩法与规则</h3><blockquote>\n<p>2048的玩法很简单，它由一个4X4的方块阵列所组成，玩家可以通过”上下左右”键进行格子的移动。每次操作会让所有的格子都向”上/下/左/右”进行移动，相同数字的格子会合并成为一个新的格子，数字为合并格子数字之和。每次操作之后，会在空白的格子处随机生成一个2或4，最终得到一个2048的方块，则就算胜利了。如果16个格子全部填满并且相邻格子都不相同，也就是无法移动的话，则游戏结束，game over。</p>\n</blockquote>\n"},{"title":"Unity Shader入门(一)","date":"2018-11-08T16:00:00.000Z","_content":"这是自己开的第一篇技术帖，主要讲述下基本的shader入门知识。预计在这个寒假结束之前写完吧。\n<br/>参考书籍：《Unity Shader入门精要》\n<br/>Unity版本: Unity 2018.2.4f1\n<br/>有人说过，程序员的三大浪漫是：编译原理，操作系统和计算机图形学。诚然，我认为这几门技术都是难度比较大的，或许再加上计算机网络与数据库系统？游戏中的美术是无比重要的，没有好的美术，纵使你的玩法再完美，受众玩家都不会多——毕竟控制台的游戏感官实在要差很多。美术只是贴图，而那些光照，反射与现实下的物理模拟，则是我们程序员的事情，shader便是解决这些问题的工具(当然，美术画出这些真实场景的情况也有——部分精致的动漫中，画师细节把握实在到位，观众往往会发出\"啊，这光，啊这水\"的惊讶感叹)，但是对实时要求极高的游戏而言，画师的画画速度则是远远不够了。\n### 1.渲染流水线\n渲染，顾名思义，将东西(我们定义好的信息)画(渲染)在纸(屏幕)上，这一部分要用到很多的数学计算，由CPU和GPU共同完成。\n《Render-Time Rendering》中将渲染流程分为三个阶段：应用阶段(Application Stage),几何阶段(Geometry Stage)，光栅化阶段(Rasterizer Stage)。\n简单而言:\n>* 应用阶段：准备好要场景数据，包括摄像机位置，视锥体，光源等信息。就像是画画，先想一下自己想要画什么东西。(大脑(CPU)负责)\n>* 几何阶段：应用阶段告诉了我们场景中有啥，而这些基本图形是点，线，三角形这些东西构成，几何阶段便是画出这些东西，但是没有颜色和其他信息，就像是一幅画的线稿一样。(速写笔(GPU)负责))\n>* 光栅化阶段：根据上个几何阶段传递过来的数据，来产生屏幕上的像素，并最终渲染出最终的图像，就像画画，线稿画好了，根据我们最开始设定好的颜色，考虑下光照之类的信息，用我们的画笔给这副画上好色。(画笔(GPU)负责))\n\n此外，我们场景中的东西可能很多，但能看到的只有摄像机视野范围那一块，因此，运用\"裁剪\"技术剔除掉那些不在视野范围内的物体。此外，我们如何把一个现实中的物体画到纸上呢？我们都知道透视几何画3D物体，像我们学过的立体几何那些。因此计算机渲染也需要这么个操作，将世界坐标映射到屏幕之上：\n>屏幕映射(Screen Mapping)的任务是把每个物体的x和y坐标转换到屏幕坐标系(Screen Coordinate)下。屏幕坐标系是一个二维坐标系，与显示画面的分辨率有很大关系。物体的Z坐标不做处理，其代表深度值。\n\n映射就涉及到坐标系的转换了，这部分是基本的数学操作。此外，开发者直接访问GPU是很麻烦的事情，因此使用一个中间的图像编程接口是十分有必要的，由于使用的屏幕坐标系可能不同，造成这部分的数学操作也不一样：\n>* OpenGL\n>* DirectX\n### 2.Unity Shader 与 ShaderLab\nUnity使用Materials，Shaders和Textures来进行渲染，它们之间联系紧密，最终渲染出美轮美奂的画面。\n>* Material: Material通过它包含的贴图，布局与颜色等信息来定义一个表面应该如何被渲染。一个Material根据其使用的shader来使用不同的可选项。\n>* Shader：Shader是一种基于光照输入和Material配置来进行数学运算并计算出每个像素点(pixel)渲染颜色的脚本。\n>* Texture: Texture是一种位图图像。一个Material包含对textures的引用，所以Material的Shader就可以使用Texture去计算一个物体(GameObject)的表面颜色了。除了游戏对象表面的基本颜色(albedo)外，纹理还可以表示材质表面的许多其他方面，如反射率，粗糙度等等。\n\n一个Material对应于一个Shader，这个Shader决定了这个Material种哪些可用的选项。一个Shader则对应了一个或多个Texture，在Unity的Inspector面板你可以直接拖拽Texture资源给Shader。总体而言，在Unity中，常见的使用流程是：\n> 1. 创建一个Material  \n> 2. 创建一个Unity Shader，并把它赋给上一步的Material  \n> 3. 把材质赋给要渲染的对象(GameObject)\n\n在Unity中，上诉操作都可以在Unity菜单栏中选择Asset->Create->Shader/Material等实现。\n<div style=\"text-align:left\"><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/shaderCapture.png\"/></div>\n\n其中有四种模板的Unity Shader供我们选择:\n>* Standard Surface Shader：产生一个包含了标准光照模型的表面着色器模板\n>* Unlit Shader：产生一个不含光照效果(但含雾效果)的基本的顶点/片元着色器\n>* Image Effect Shader：提供一个屏幕后处理效果的基本模板\n>* Computer Shader：特殊Shader文件，旨在利用GPU的并行性来计算一些与常规渲染流水线无关的计算\n\n创建好Shader文件后，我们就可以开始我们的Unity Shader编程工作了。在Unity中，所有的Unity Shader都是由ShaderLib来编写的:\n>ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。它使用一些嵌套在花括号内部的语义(syntax)来描述一个Unity Shader文件的结构。\n一个Unity Shader的基础结构如下所示：\n\n``` C\nShader \"ShaderName\"{\n    Properties {\n        //Shader Properties\n    }\n    SubShader {\n        //Subshader A\n    }\n    SubShader {\n        //Subshader B\n    }\n}\n```\nUnity在背后会根据所使用的平台来把这些结构编译为真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可，这就像我们使用C/C++等编程语言，而编译器会编译为机器语言。在这里，我们使用Unity Shader进行编程，Unity将其翻译为真正的Shader文件。\n\n在没有Unity这类编辑器的情况下，如果我们想要对某个模型设置渲染状态，需要十分复杂的代码，有了解过OpenGL的同学可能会有感受：\n``` C++\nvoid Initialization()\n{\n    //初始化渲染设置\n    //从硬盘加载顶点着色器代码\n    //从硬盘加载片元着色器代码\n    //把顶点着色器加载到GPU\n    //把片元着色器加载到GPU\n    string vertexShaderCode = LoadShaderFromFile(VertexShader.shader);\n    string fragmentShaderCode = LoadShaderFromFile(FragmentShader.shader);\n    LoadVertexShaderFromString(vertextShaderCode);\n    LoadFragmentShaderFromString(fragmentShaderCode);\n\n    //设置模型顶点坐标\n    //加载纹理图片\n    //加载预处理的变换矩阵\n    SetVertexShaderProperty(\"vertexPosition\",vertices);\n    SetVertexShaderProperty(\"MainTex\",someTexture);\n    SetVertexShaderProperty(\"MVP\",MVP);\n\n    //关闭混合\n    Disable(Blend);\n    //设置深度测试\n    Enable(ZTest);\n    SetZTestFunction(LessOrEqual);\n\n    //其他设置\n    ...\n}\n\n//每一帧进行渲染\nvoid OnRendering()\n{\n    DrawCall();\n    //其他渲染设置\n    ...\n}\n```\n上诉是渲染的流程，一般都用C/C++实现，而真正的shader文件则像下面样子:\n\n顶点着色器 VertexShader.shader\n``` C++\n//输入:顶点位置，纹理，MVP变换矩阵\nin float3 vertexPosition;\nin sample2D MainTex;\nin Matrix4x4 MVP;\n\n//输出:顶点经过MVP变换后的位置\nout float4 position;\n\nvoid main()\n{\n    position = MVP * vertexPosition;\n}\n```\n片元着色器 FragmentShader.shader\n``` C++\n//输入:VertexShader输出的position,光栅化程序插值后的position\nin float4 position;\n\n//输出:片元颜色值\nout float4 fragColor;\n\nvoid main()\n{\n    //片元设置为白色\n    fragColor = float4(1.0,1.0,1.0,1.0);\n}\n```\n这仅仅是超级简化版本了，除去许多冗长的函数名(函数功能还是很清晰的)之外，执行顺序，渲染数目的增多会让过程变得更加负责。幸运的是，使用Unity shader，我们便可以十分简单的实现上述的所有步骤了——这也就是抽象的好处：\"计算机中的任何问题都可以增加一层抽象来解决\"。\n\n从设计上而言，ShaderLab类似于CgFX和Direct3D Effects(.FX)语言。接下来，我们简要学习一下Unity Shader的基本结构，写出个\"Hello Shader\"来吧。\n### 3.Unity Shader Structure\n#### 3.1 Shader Name\n就和所有的编程一样，首先我们要为Unity Shader文件中定义的Shader取一个名字：\n```\nShader \"Customer/MyShader\"\n{\n    ...\n}\n```\n这样，当Material需要使用该shader时，就可以在下拉列表内找到。\n#### 3.2 Properties\nProperties语义块包含了许多的属性(property)\n```\nProperties\n{\n    Name (\"display name\", PropertyType) = DefaultValue\n    Name (\"display name\", PropertyType) = DefaultValue\n    //更多属性\n}\n```\n声明这些属性就像声明一个Public的变量一样，我们可以在材质面板中很方便地调整各种材质属性等。\n<br/>Properties 中字段含义:\n* Name 是我们在shader中要访问该变量时使用的名字，约定俗成一般以下划线开始\n* display name 是出现在材质面板上的名字\n* PropertyType 是属性的类型\n* DefaultValue 是属性默认值\n\nProperties所支持的PropertyType:\n\n|属性类型|默认值的定义语法|例子\n|:-|:-|:-|\n|Int|number|_Int(\"Int\",Int)=2\n|Float|number|_Float(\"Float\",Float)=1.5\n|Range(min,max)|number|_Range(\"Range\",Range(0.0,5.0))=3.0\n|Color|(number,number,number,number)|_Color(\"Color\",Color)=(1,1,1,1)\n|Vector|(number,number,number,number)|_Vector(\"Vector\",Vector)=(2,3,6,1)\n|2D|\"defaulttexture\"{}|_2d(\"2D\",2D)=\"\"{}\n|Cube|\"defaulttexture\"{}|_Cube(\"Cube\",Cube)=\"white\"{}\n|3D|\"defaulttexture\"{}|_3D(\"3D\",3D)=\"black\"{}\n<br/>对于Int,Float,Range这些属性，其默认值就是一个单独的数字\n<br/>对于Color,Vector这些属性，默认值是一个四维向量\n<br/>对于2D,Cube,3D这些属性，由一个字符串加{}组成，前面字符串要么为空，要么是内置的纹理名称，如\"whit\",\"black\",\"gray\"或\"bump\"这些，{}中指定一些纹理属性\n<br/>最后我们可以得到一个超级简单的\"Hello Shader\"的例子：\n``` C\nShader \"Custom/NewSurfaceShader\" {\n    Properties {\n        _Int(\"Int\",Int) = 2\n        _Float(\"Float\",Float) = 1.5\n        _Range(\"Range\",Range(0.0,5.0)) = 1.5\n        _Color(\"Color\", Color) = (1,1,1,1)\n        _Vector(\"Vector\",Vector) = (2,3,6,1)\n        _2D(\"2D\",2D)=\"\"{}\n        _Cube(\"Cuben\",Cube)=\"White\"{}\n        _3D(\"3D\",3D)=\"black\"{}\n    }\n    FallBack \"Diffuse\"\n}\n```\n<br/>在Unity编辑器中如下图所示:\n<div><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/Material_Shader_Show.png\"/></div>\n\n此外一些其他类型的变量若是想显示出来，Unity允许我们重载默认的材质编辑面板，流程与Customer Editor那套自定义Inspector的方式类似，只不过现在是Shader材质面板了，有兴趣了解的同学可以参考官方[Custome Shader GUI](http://docs.unity3d.com/Manual/SL-CustomShaderGUI)。\n#### 3.3 SubShader\n>每一个Unity Shader文件可以包含多个SubShader语义块，但至少要有一个。当Unity需要运行这个Unity Shader时，会依次扫描所有的SubShader，然后选择第一个可以在目标平台运行的SubShader。如果都不支持的话，会使用FallBack语义所指定的Unity Shader。\n\n之所这么设计的原因，是因为用户的显卡能力不同，为提供更加流畅与精美的画面，对高性能显卡的用户就是用较高计算复杂度的着色器，低性能的就使用较低计算复杂度的着色器。\n\nSubShader语义块形式如下：\n``` C\nSubShader {\n    //可选\n    [Tags]\n\n    //可选\n    [RenderSetup]\n\n    Pass{}\n    //other passes\n}\n```\n字段描述：\n* Pass: 每个Pass定义了一次完整的渲染流程,但如果Pass数量过多会造成渲染性能下降\n* RenderSetup: 渲染状态设置指令，可以设置显卡的各种状态，例如是否开启混合/深度测试等，设置之后会作用于所有的Pass块，常见RenderSetup设置见下表。\n* Tags: 标签(tags)时一个键值对，它的键和值都是字符串类型。常见Tags支持类型见下表。\n\n常见的RenderSetup设置选项：\n\n|状态名称|设置指令|解释\n|:---|:---|:---\n|Cull|Cull Back/Font/Off|设置剔除模式:剔除背面/正面/关闭剔除\n|ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数\n|ZWrite|ZWrite On/Off|开启/关闭深度写入\n|Blend|Blend SrcFactor DstFactor|开启并设置混合模式\n\n>当在SubShader中设置了上述渲染状态时，将会应用到所有的Pass上去。\n\nTags支持类型\n\n|标签类别|说明|例子\n|:---|:---|:---\n|Queue|控制渲染顺序，可以指定该物体属于哪个渲染队列，通过这种方式可以保证所有透明物体都可以在不透明物体之后被渲染|Tags{\"Queue\"=\"Transparent\"}\n|RenderType|对着色器进行分类，例如这是个不透明的着色器，或是一个透明的着色器，可以用于着色器替换功能(Shader Replacement)|Tags{\"RenderType\"=\"Opaque\"}\n|DisableBatching|是否对该SubShader使用批处理|Tags{\"DisableBatching\"=\"True\"}\n|ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影|Tags{\"ForceNoShadowCasting\"=\"True\"}\n|IgnoreProjector|控制使用该SubShader的物体是否会受到Projector的影响，通常用于半透明物体|Tags{\"Ignore'Projector\"=\"True\"}\n|CanUseSpriteAtlas|当该SubShader是用于精灵(sprite)时，将该标签设为\"False\"|Tags{\"CanUseSpriteAtlas\"=\"False\"}\n|PreviewType|指明材质面板将如何预览该材质，默认情况下，材质将显示为一个球形，我们可以通过把该标签设置为\"Plane\"，\"SkyBox\"来改变预览模型|Tags{\"PreviewType\"=\"Plane\"}\n\n上诉Tags仅可以在SubShader中声明，而不可以在Pass中声明。Pass块中也有标签可以定义，但它们不同于SubShader的标签类型。\n>Pass语义块\n\n``` C\nPass {\n    [Name]\n    [Tags]\n    [RenderSetup]\n    //other Code\n}\n```\n>Name \"MyPassName\"\n\n通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass。如：\n>UsePass \"MyShader/MYPASSNAME\"\n\n这样可以提高代码复用率，但需要注意的是，Unity内部会把所有Pass名字转换为大写字母表示，因此使用UsePass命令时，必须使用大写形式的名字。\n\n其次，Pass也可以设置渲染状态(RenderSetup)与标签(Tags)，渲染状态可以使用SubShader中支持的渲染状态，还可以使用固定管线的着色器命令。\n\nPass同样可以设置标签，但其标签不同于SubShader标签，Pass中支持的标签如下：\n\n|标签类型 | 说明 | 例子 |\n|:--- | :---- | :-------- |\n|LightMode | 定义该Pass在Unity渲染流水线中的角色 | Tags{\"LightMode\"=\"ForwardBase\"} |\n|RequireOptions | 用于指定当满足某些条件时才渲染该Pass | Tags{\"RequireOptions\"=\"SoftVegetation\"} |\n#### 3.4 Fallback\n紧跟在Unity Shader后面的是一个Fallback语句，它是最后一道保险，即如果所有的SubShader都不能用的话，就使用这个吧。语义如下：\n``` C\nFallback \"name\"\n// or\nFallback off\n```\n综上所述，我们可以通过一个字符串来指明这个\"最后的Shader\"，当然你也可以\"宁缺毋滥\"——不能按我的意思渲染的话，那就不要管它了。但是啊，FallBack还会影响阴影的投射，在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投影的Pass，通常情况下我们不需要自己去实现一个这样的Pass，这是因为Fallback使用的内置Shader中往往包含了一个这样的通用Pass，因此为每个Unity Shader设置好Fallback还是十分重要的。\n\n### 4.CG/HLSL\n目前，我们基本理解了一个Unity Shader的结构了，Properties里面定义属性，在SubShader中写真正的着色器代码。\n\n好了，还记得Unity提供给我们的四种Unity Shader模板么？实际上那便对应了Unity Shader的两个不同类型：表面着色器(Surface Shader)与顶点/片元着色器(Vertex/Fragment Shader)\n\n我们来看一个非常简单的表面着色器代码(Surface Shader)\n``` C\nShader \"Custom/Simple Surface Shader\"{\n    SubShader{\n        Tags{\"RenderType\"=\"Opaque\"}\n        CGPROGRAM\n        #Pragma surface surf Lambert\n        struct Input{\n            float4 color : COLOR;\n        };\n        void surf (Input IN,inout surfaceOutput o){\n            o.Albedo = 1;\n        }\n        ENDCG\n    }\n    Fallback \"Diffuse\"\n}\n```\n再来看一个非常简单的顶点/片元着色器(Vertex/Fragment Shader)\n``` C\nShader \"Custom/Simple VertexFragment Shader\"{\n    SubShader{\n        Pass{\n            CGProGRAM\n            \n            #pragma vertex vert\n            #pragma fragment frag\n\n            float4 vert(float4 v : POSITION) : SV_POSITION{\n                return mul (UNITY_MATRIX_MVP, v);\n            }\n\n            fixed4 frag() : SV_Target{\n                return fixed4(1.0,0.0,0.0,1.0);\n            }\n\n            ENDCG\n        }\n    }\n}\n```\n这就是Unity Shader的两种不同形式\n* 表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型，其所需要的代码量很少，Unity在背后做了很多工作，但渲染的代价比较大。其本质还是顶点/片元着色器，实际上就是顶点/片元着色器更高一层的抽象。它存在的价值在于为开发者处理了很多很多的光照细节，使得开发者不需要操心这些事情。\n  \n>表面着色器被定义在**SubShader语义块(而非Pass语义块)**中的CGPROGRAM与ENDCG之间，原因是表面着色器不关心开发者用多少个Pass，每个Pass如何渲染等问题，Unity会在背后做好这些事情。开发者所需要做的，就只是简单地告诉Surface Shader用\"这个纹理\"去填充颜色，用\"这个法线纹理\"去填充法线，使用光照模型等。具体细节不用关系。\n\n* 顶点/片元着色器(Vertex/Fragment Shader)则更加复杂，灵活性也更高。\n\n>和表面着色器类似，顶点/片元着色器地代码也需要定义在CGPROGRAM与ENDCG之间，但不同地是，顶点/片元着色器是写在**Pass语义块内(而非SubShader内)**。因此，我们需要自己定义每个Pass需要使用地Shader代码，可以控制渲染的实现细节。\n\n那么CGPROGRAM与ENDCG之间是什么呢？首先我们要了解一下当下主流的几种Shader Language(SL):\n>目前主流的Shader Language有3种语言\n* GLSL：基于OpenGL的OpenGL Shading Language，简称GLSL\n* HLSL: 基于DirectX的High Level Shading Language,简称HLSL\n* Cg语言: NVIDIA公司的C for Graphic，简称Cg语言。\n\n因此，我们需要把CG/HLSL的语言嵌套在ShaderLab语言之中，值得注意的是，此处的CG/HLSL是Unity经过封装后的，但其语法和标准的CG/HLSL语法几乎一模一样，只有部分原生的函数和用法没有支持，感觉和当时的JavaScript和UnityScript感觉很类似。而且由于CG与DX9风格的HLSL从写法上而言几乎是同一种语言，因此在Unity里CG与HLSL是等价的。同样的，ShaderLab也支持内嵌GLSL的！\n``` C\nCGPROGRAM\n    // CG/HLSL代码\n    // 支持平台：PC，Xbox360等等\nENDCG\n\nGLSLPROGRAM\n    // GLSL代码\n    // 支持平台：Mac OS X，OpenGL ES2.0，Linux\nENDGLSL\n```\nOK，现在基本的Unity Shader知识储备就差不多了，欢迎进入Shader的世界~\n### 5.几大SL的爱恨情仇\n摘抄自《GPU Programming And Cg Language Primer 1rd Edition》 中文名《GPU编程与CG语言之阳春白雪下里巴人》\n>Shader language目前有3种主流语言：基于OpenGL的GLSL（OpenGL Shading Language，也称为GLslang），基于Direct3D的HLSL（High Level Shading Language），还有NVIDIA公司的Cg （C for Graphic）语言。\n>GLSL与HLSL分别提基于OpenGL和Direct3D的接口，两者不能混用，事实上OpenGL和Direct3D一直都是冤家对头，曹操和刘备还有一段和平共处的甜美时光，但OpenGL和Direct3D各自的东家则从来都是争斗不休。争斗良久，既然没有分出胜负，那么必然是两败俱伤的局面。\n\n>首先ATI系列显卡对OpenGL扩展支持不够，例如我在使用OSG（Open Scene Graphic）开源图形引擎时，由于该引擎完全基于OpenGL，导致其上编写的3D仿真程序在较老的显卡上常常出现纹理无法显示的问题。其次GLSL 的语法体系自成一家，而HLSL和Cg语言的语法基本相同，这就意味着，只要学习HLSL和Cg中的任何一种，就等同于学习了两种语言。不过OpenGL 毕竟图形API的曾经领袖，通常介绍OpenGL都会附加上一句“事实上的工业标准”，所以在其长期发展中积累下的用户群庞大，这些用户当然会选择 GLSL学习。此外，GLSL继承了OpenGL的良好移植性，一度在unix等操作系统上独领风骚（已是曾经的往事）。\n\n>微软的HLSL移植性较差，在windows平台上可谓一家独大，可一出自己的院子（还好院子够大），就是落地凤凰不如鸡。这一点在很大程度上限制了 HLSL的推广和发展。目前HLSL多半都是用于游戏领域。我可以负责任的断言，在Shader language领域，HLSL可以凭借微软的老本成为割据一方的诸侯，但，决不可能成为君临天下的霸主。这和微软现在的局面很像，就是一个被带刺鲜花簇拥着的大财主，富贵已极，寸步难行。\n\n>上面两个大佬打的很热烈，在这种情况下可以用一句俗话来形容，“鹬蚌相争，渔翁得利”。NVIDIA是现在当之无愧的显卡之王（尤其在AMD兼并ATI之后），是GPU编程理论的奠基者，GeForce系列显卡早已深入人心，它推出的Cg语言已经取得了巨大的成功，生生形成了三足鼎立之势。NVIDIA公司深通广告之道，目前最流行的GPU编程精粹一书就出自该公司，书中不但介绍了大量的GPU前沿知识，最重要的是大部分都用Cg语言实现。凭借该系列的书籍，NVIDIA不光确定了在青年学子间的学术地位，而且成功的推广了Cg语言。\n\n### 6.Unity与Cg/HLSL\n>Unity官方手册上讲Shader程序嵌入的小片段是用Cg/HLSL编写的，从“CGPROGRAM”开始，到“CGEND”结束。所以，Unity官方主要是用Cg/HLSL编写Shader程序片段。Unity官方手册也说明对于Cg/HLSL程序进行扩展也可以使用GLSL，不过Unity官方建议使用原生的GLSL进行编写和测试。如果不使用原生GLSL，你就需要知道你的平台必须是Mac OS X、OpenGL ES 2.0以上的移动设备或者是Linux。在一般情况下Unity会把Cg/HLSL交叉编译成优化过的GLSL。因此我们有多种选择，我们既可以考虑使用Cg/HLSL，也可以使用GLSL。不过由于Cg/HLSL更好的跨平台性，更倾向于使用Cg/HLSL编写Shader程序。\n\n","source":"_posts/d_shaderLearning01.md","raw":"---\ntitle: Unity Shader入门(一)\ndate: 2018-11-09\ntag: Unity Shader\n---\n这是自己开的第一篇技术帖，主要讲述下基本的shader入门知识。预计在这个寒假结束之前写完吧。\n<br/>参考书籍：《Unity Shader入门精要》\n<br/>Unity版本: Unity 2018.2.4f1\n<br/>有人说过，程序员的三大浪漫是：编译原理，操作系统和计算机图形学。诚然，我认为这几门技术都是难度比较大的，或许再加上计算机网络与数据库系统？游戏中的美术是无比重要的，没有好的美术，纵使你的玩法再完美，受众玩家都不会多——毕竟控制台的游戏感官实在要差很多。美术只是贴图，而那些光照，反射与现实下的物理模拟，则是我们程序员的事情，shader便是解决这些问题的工具(当然，美术画出这些真实场景的情况也有——部分精致的动漫中，画师细节把握实在到位，观众往往会发出\"啊，这光，啊这水\"的惊讶感叹)，但是对实时要求极高的游戏而言，画师的画画速度则是远远不够了。\n### 1.渲染流水线\n渲染，顾名思义，将东西(我们定义好的信息)画(渲染)在纸(屏幕)上，这一部分要用到很多的数学计算，由CPU和GPU共同完成。\n《Render-Time Rendering》中将渲染流程分为三个阶段：应用阶段(Application Stage),几何阶段(Geometry Stage)，光栅化阶段(Rasterizer Stage)。\n简单而言:\n>* 应用阶段：准备好要场景数据，包括摄像机位置，视锥体，光源等信息。就像是画画，先想一下自己想要画什么东西。(大脑(CPU)负责)\n>* 几何阶段：应用阶段告诉了我们场景中有啥，而这些基本图形是点，线，三角形这些东西构成，几何阶段便是画出这些东西，但是没有颜色和其他信息，就像是一幅画的线稿一样。(速写笔(GPU)负责))\n>* 光栅化阶段：根据上个几何阶段传递过来的数据，来产生屏幕上的像素，并最终渲染出最终的图像，就像画画，线稿画好了，根据我们最开始设定好的颜色，考虑下光照之类的信息，用我们的画笔给这副画上好色。(画笔(GPU)负责))\n\n此外，我们场景中的东西可能很多，但能看到的只有摄像机视野范围那一块，因此，运用\"裁剪\"技术剔除掉那些不在视野范围内的物体。此外，我们如何把一个现实中的物体画到纸上呢？我们都知道透视几何画3D物体，像我们学过的立体几何那些。因此计算机渲染也需要这么个操作，将世界坐标映射到屏幕之上：\n>屏幕映射(Screen Mapping)的任务是把每个物体的x和y坐标转换到屏幕坐标系(Screen Coordinate)下。屏幕坐标系是一个二维坐标系，与显示画面的分辨率有很大关系。物体的Z坐标不做处理，其代表深度值。\n\n映射就涉及到坐标系的转换了，这部分是基本的数学操作。此外，开发者直接访问GPU是很麻烦的事情，因此使用一个中间的图像编程接口是十分有必要的，由于使用的屏幕坐标系可能不同，造成这部分的数学操作也不一样：\n>* OpenGL\n>* DirectX\n### 2.Unity Shader 与 ShaderLab\nUnity使用Materials，Shaders和Textures来进行渲染，它们之间联系紧密，最终渲染出美轮美奂的画面。\n>* Material: Material通过它包含的贴图，布局与颜色等信息来定义一个表面应该如何被渲染。一个Material根据其使用的shader来使用不同的可选项。\n>* Shader：Shader是一种基于光照输入和Material配置来进行数学运算并计算出每个像素点(pixel)渲染颜色的脚本。\n>* Texture: Texture是一种位图图像。一个Material包含对textures的引用，所以Material的Shader就可以使用Texture去计算一个物体(GameObject)的表面颜色了。除了游戏对象表面的基本颜色(albedo)外，纹理还可以表示材质表面的许多其他方面，如反射率，粗糙度等等。\n\n一个Material对应于一个Shader，这个Shader决定了这个Material种哪些可用的选项。一个Shader则对应了一个或多个Texture，在Unity的Inspector面板你可以直接拖拽Texture资源给Shader。总体而言，在Unity中，常见的使用流程是：\n> 1. 创建一个Material  \n> 2. 创建一个Unity Shader，并把它赋给上一步的Material  \n> 3. 把材质赋给要渲染的对象(GameObject)\n\n在Unity中，上诉操作都可以在Unity菜单栏中选择Asset->Create->Shader/Material等实现。\n<div style=\"text-align:left\"><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/shaderCapture.png\"/></div>\n\n其中有四种模板的Unity Shader供我们选择:\n>* Standard Surface Shader：产生一个包含了标准光照模型的表面着色器模板\n>* Unlit Shader：产生一个不含光照效果(但含雾效果)的基本的顶点/片元着色器\n>* Image Effect Shader：提供一个屏幕后处理效果的基本模板\n>* Computer Shader：特殊Shader文件，旨在利用GPU的并行性来计算一些与常规渲染流水线无关的计算\n\n创建好Shader文件后，我们就可以开始我们的Unity Shader编程工作了。在Unity中，所有的Unity Shader都是由ShaderLib来编写的:\n>ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。它使用一些嵌套在花括号内部的语义(syntax)来描述一个Unity Shader文件的结构。\n一个Unity Shader的基础结构如下所示：\n\n``` C\nShader \"ShaderName\"{\n    Properties {\n        //Shader Properties\n    }\n    SubShader {\n        //Subshader A\n    }\n    SubShader {\n        //Subshader B\n    }\n}\n```\nUnity在背后会根据所使用的平台来把这些结构编译为真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可，这就像我们使用C/C++等编程语言，而编译器会编译为机器语言。在这里，我们使用Unity Shader进行编程，Unity将其翻译为真正的Shader文件。\n\n在没有Unity这类编辑器的情况下，如果我们想要对某个模型设置渲染状态，需要十分复杂的代码，有了解过OpenGL的同学可能会有感受：\n``` C++\nvoid Initialization()\n{\n    //初始化渲染设置\n    //从硬盘加载顶点着色器代码\n    //从硬盘加载片元着色器代码\n    //把顶点着色器加载到GPU\n    //把片元着色器加载到GPU\n    string vertexShaderCode = LoadShaderFromFile(VertexShader.shader);\n    string fragmentShaderCode = LoadShaderFromFile(FragmentShader.shader);\n    LoadVertexShaderFromString(vertextShaderCode);\n    LoadFragmentShaderFromString(fragmentShaderCode);\n\n    //设置模型顶点坐标\n    //加载纹理图片\n    //加载预处理的变换矩阵\n    SetVertexShaderProperty(\"vertexPosition\",vertices);\n    SetVertexShaderProperty(\"MainTex\",someTexture);\n    SetVertexShaderProperty(\"MVP\",MVP);\n\n    //关闭混合\n    Disable(Blend);\n    //设置深度测试\n    Enable(ZTest);\n    SetZTestFunction(LessOrEqual);\n\n    //其他设置\n    ...\n}\n\n//每一帧进行渲染\nvoid OnRendering()\n{\n    DrawCall();\n    //其他渲染设置\n    ...\n}\n```\n上诉是渲染的流程，一般都用C/C++实现，而真正的shader文件则像下面样子:\n\n顶点着色器 VertexShader.shader\n``` C++\n//输入:顶点位置，纹理，MVP变换矩阵\nin float3 vertexPosition;\nin sample2D MainTex;\nin Matrix4x4 MVP;\n\n//输出:顶点经过MVP变换后的位置\nout float4 position;\n\nvoid main()\n{\n    position = MVP * vertexPosition;\n}\n```\n片元着色器 FragmentShader.shader\n``` C++\n//输入:VertexShader输出的position,光栅化程序插值后的position\nin float4 position;\n\n//输出:片元颜色值\nout float4 fragColor;\n\nvoid main()\n{\n    //片元设置为白色\n    fragColor = float4(1.0,1.0,1.0,1.0);\n}\n```\n这仅仅是超级简化版本了，除去许多冗长的函数名(函数功能还是很清晰的)之外，执行顺序，渲染数目的增多会让过程变得更加负责。幸运的是，使用Unity shader，我们便可以十分简单的实现上述的所有步骤了——这也就是抽象的好处：\"计算机中的任何问题都可以增加一层抽象来解决\"。\n\n从设计上而言，ShaderLab类似于CgFX和Direct3D Effects(.FX)语言。接下来，我们简要学习一下Unity Shader的基本结构，写出个\"Hello Shader\"来吧。\n### 3.Unity Shader Structure\n#### 3.1 Shader Name\n就和所有的编程一样，首先我们要为Unity Shader文件中定义的Shader取一个名字：\n```\nShader \"Customer/MyShader\"\n{\n    ...\n}\n```\n这样，当Material需要使用该shader时，就可以在下拉列表内找到。\n#### 3.2 Properties\nProperties语义块包含了许多的属性(property)\n```\nProperties\n{\n    Name (\"display name\", PropertyType) = DefaultValue\n    Name (\"display name\", PropertyType) = DefaultValue\n    //更多属性\n}\n```\n声明这些属性就像声明一个Public的变量一样，我们可以在材质面板中很方便地调整各种材质属性等。\n<br/>Properties 中字段含义:\n* Name 是我们在shader中要访问该变量时使用的名字，约定俗成一般以下划线开始\n* display name 是出现在材质面板上的名字\n* PropertyType 是属性的类型\n* DefaultValue 是属性默认值\n\nProperties所支持的PropertyType:\n\n|属性类型|默认值的定义语法|例子\n|:-|:-|:-|\n|Int|number|_Int(\"Int\",Int)=2\n|Float|number|_Float(\"Float\",Float)=1.5\n|Range(min,max)|number|_Range(\"Range\",Range(0.0,5.0))=3.0\n|Color|(number,number,number,number)|_Color(\"Color\",Color)=(1,1,1,1)\n|Vector|(number,number,number,number)|_Vector(\"Vector\",Vector)=(2,3,6,1)\n|2D|\"defaulttexture\"{}|_2d(\"2D\",2D)=\"\"{}\n|Cube|\"defaulttexture\"{}|_Cube(\"Cube\",Cube)=\"white\"{}\n|3D|\"defaulttexture\"{}|_3D(\"3D\",3D)=\"black\"{}\n<br/>对于Int,Float,Range这些属性，其默认值就是一个单独的数字\n<br/>对于Color,Vector这些属性，默认值是一个四维向量\n<br/>对于2D,Cube,3D这些属性，由一个字符串加{}组成，前面字符串要么为空，要么是内置的纹理名称，如\"whit\",\"black\",\"gray\"或\"bump\"这些，{}中指定一些纹理属性\n<br/>最后我们可以得到一个超级简单的\"Hello Shader\"的例子：\n``` C\nShader \"Custom/NewSurfaceShader\" {\n    Properties {\n        _Int(\"Int\",Int) = 2\n        _Float(\"Float\",Float) = 1.5\n        _Range(\"Range\",Range(0.0,5.0)) = 1.5\n        _Color(\"Color\", Color) = (1,1,1,1)\n        _Vector(\"Vector\",Vector) = (2,3,6,1)\n        _2D(\"2D\",2D)=\"\"{}\n        _Cube(\"Cuben\",Cube)=\"White\"{}\n        _3D(\"3D\",3D)=\"black\"{}\n    }\n    FallBack \"Diffuse\"\n}\n```\n<br/>在Unity编辑器中如下图所示:\n<div><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/Material_Shader_Show.png\"/></div>\n\n此外一些其他类型的变量若是想显示出来，Unity允许我们重载默认的材质编辑面板，流程与Customer Editor那套自定义Inspector的方式类似，只不过现在是Shader材质面板了，有兴趣了解的同学可以参考官方[Custome Shader GUI](http://docs.unity3d.com/Manual/SL-CustomShaderGUI)。\n#### 3.3 SubShader\n>每一个Unity Shader文件可以包含多个SubShader语义块，但至少要有一个。当Unity需要运行这个Unity Shader时，会依次扫描所有的SubShader，然后选择第一个可以在目标平台运行的SubShader。如果都不支持的话，会使用FallBack语义所指定的Unity Shader。\n\n之所这么设计的原因，是因为用户的显卡能力不同，为提供更加流畅与精美的画面，对高性能显卡的用户就是用较高计算复杂度的着色器，低性能的就使用较低计算复杂度的着色器。\n\nSubShader语义块形式如下：\n``` C\nSubShader {\n    //可选\n    [Tags]\n\n    //可选\n    [RenderSetup]\n\n    Pass{}\n    //other passes\n}\n```\n字段描述：\n* Pass: 每个Pass定义了一次完整的渲染流程,但如果Pass数量过多会造成渲染性能下降\n* RenderSetup: 渲染状态设置指令，可以设置显卡的各种状态，例如是否开启混合/深度测试等，设置之后会作用于所有的Pass块，常见RenderSetup设置见下表。\n* Tags: 标签(tags)时一个键值对，它的键和值都是字符串类型。常见Tags支持类型见下表。\n\n常见的RenderSetup设置选项：\n\n|状态名称|设置指令|解释\n|:---|:---|:---\n|Cull|Cull Back/Font/Off|设置剔除模式:剔除背面/正面/关闭剔除\n|ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数\n|ZWrite|ZWrite On/Off|开启/关闭深度写入\n|Blend|Blend SrcFactor DstFactor|开启并设置混合模式\n\n>当在SubShader中设置了上述渲染状态时，将会应用到所有的Pass上去。\n\nTags支持类型\n\n|标签类别|说明|例子\n|:---|:---|:---\n|Queue|控制渲染顺序，可以指定该物体属于哪个渲染队列，通过这种方式可以保证所有透明物体都可以在不透明物体之后被渲染|Tags{\"Queue\"=\"Transparent\"}\n|RenderType|对着色器进行分类，例如这是个不透明的着色器，或是一个透明的着色器，可以用于着色器替换功能(Shader Replacement)|Tags{\"RenderType\"=\"Opaque\"}\n|DisableBatching|是否对该SubShader使用批处理|Tags{\"DisableBatching\"=\"True\"}\n|ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影|Tags{\"ForceNoShadowCasting\"=\"True\"}\n|IgnoreProjector|控制使用该SubShader的物体是否会受到Projector的影响，通常用于半透明物体|Tags{\"Ignore'Projector\"=\"True\"}\n|CanUseSpriteAtlas|当该SubShader是用于精灵(sprite)时，将该标签设为\"False\"|Tags{\"CanUseSpriteAtlas\"=\"False\"}\n|PreviewType|指明材质面板将如何预览该材质，默认情况下，材质将显示为一个球形，我们可以通过把该标签设置为\"Plane\"，\"SkyBox\"来改变预览模型|Tags{\"PreviewType\"=\"Plane\"}\n\n上诉Tags仅可以在SubShader中声明，而不可以在Pass中声明。Pass块中也有标签可以定义，但它们不同于SubShader的标签类型。\n>Pass语义块\n\n``` C\nPass {\n    [Name]\n    [Tags]\n    [RenderSetup]\n    //other Code\n}\n```\n>Name \"MyPassName\"\n\n通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass。如：\n>UsePass \"MyShader/MYPASSNAME\"\n\n这样可以提高代码复用率，但需要注意的是，Unity内部会把所有Pass名字转换为大写字母表示，因此使用UsePass命令时，必须使用大写形式的名字。\n\n其次，Pass也可以设置渲染状态(RenderSetup)与标签(Tags)，渲染状态可以使用SubShader中支持的渲染状态，还可以使用固定管线的着色器命令。\n\nPass同样可以设置标签，但其标签不同于SubShader标签，Pass中支持的标签如下：\n\n|标签类型 | 说明 | 例子 |\n|:--- | :---- | :-------- |\n|LightMode | 定义该Pass在Unity渲染流水线中的角色 | Tags{\"LightMode\"=\"ForwardBase\"} |\n|RequireOptions | 用于指定当满足某些条件时才渲染该Pass | Tags{\"RequireOptions\"=\"SoftVegetation\"} |\n#### 3.4 Fallback\n紧跟在Unity Shader后面的是一个Fallback语句，它是最后一道保险，即如果所有的SubShader都不能用的话，就使用这个吧。语义如下：\n``` C\nFallback \"name\"\n// or\nFallback off\n```\n综上所述，我们可以通过一个字符串来指明这个\"最后的Shader\"，当然你也可以\"宁缺毋滥\"——不能按我的意思渲染的话，那就不要管它了。但是啊，FallBack还会影响阴影的投射，在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投影的Pass，通常情况下我们不需要自己去实现一个这样的Pass，这是因为Fallback使用的内置Shader中往往包含了一个这样的通用Pass，因此为每个Unity Shader设置好Fallback还是十分重要的。\n\n### 4.CG/HLSL\n目前，我们基本理解了一个Unity Shader的结构了，Properties里面定义属性，在SubShader中写真正的着色器代码。\n\n好了，还记得Unity提供给我们的四种Unity Shader模板么？实际上那便对应了Unity Shader的两个不同类型：表面着色器(Surface Shader)与顶点/片元着色器(Vertex/Fragment Shader)\n\n我们来看一个非常简单的表面着色器代码(Surface Shader)\n``` C\nShader \"Custom/Simple Surface Shader\"{\n    SubShader{\n        Tags{\"RenderType\"=\"Opaque\"}\n        CGPROGRAM\n        #Pragma surface surf Lambert\n        struct Input{\n            float4 color : COLOR;\n        };\n        void surf (Input IN,inout surfaceOutput o){\n            o.Albedo = 1;\n        }\n        ENDCG\n    }\n    Fallback \"Diffuse\"\n}\n```\n再来看一个非常简单的顶点/片元着色器(Vertex/Fragment Shader)\n``` C\nShader \"Custom/Simple VertexFragment Shader\"{\n    SubShader{\n        Pass{\n            CGProGRAM\n            \n            #pragma vertex vert\n            #pragma fragment frag\n\n            float4 vert(float4 v : POSITION) : SV_POSITION{\n                return mul (UNITY_MATRIX_MVP, v);\n            }\n\n            fixed4 frag() : SV_Target{\n                return fixed4(1.0,0.0,0.0,1.0);\n            }\n\n            ENDCG\n        }\n    }\n}\n```\n这就是Unity Shader的两种不同形式\n* 表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型，其所需要的代码量很少，Unity在背后做了很多工作，但渲染的代价比较大。其本质还是顶点/片元着色器，实际上就是顶点/片元着色器更高一层的抽象。它存在的价值在于为开发者处理了很多很多的光照细节，使得开发者不需要操心这些事情。\n  \n>表面着色器被定义在**SubShader语义块(而非Pass语义块)**中的CGPROGRAM与ENDCG之间，原因是表面着色器不关心开发者用多少个Pass，每个Pass如何渲染等问题，Unity会在背后做好这些事情。开发者所需要做的，就只是简单地告诉Surface Shader用\"这个纹理\"去填充颜色，用\"这个法线纹理\"去填充法线，使用光照模型等。具体细节不用关系。\n\n* 顶点/片元着色器(Vertex/Fragment Shader)则更加复杂，灵活性也更高。\n\n>和表面着色器类似，顶点/片元着色器地代码也需要定义在CGPROGRAM与ENDCG之间，但不同地是，顶点/片元着色器是写在**Pass语义块内(而非SubShader内)**。因此，我们需要自己定义每个Pass需要使用地Shader代码，可以控制渲染的实现细节。\n\n那么CGPROGRAM与ENDCG之间是什么呢？首先我们要了解一下当下主流的几种Shader Language(SL):\n>目前主流的Shader Language有3种语言\n* GLSL：基于OpenGL的OpenGL Shading Language，简称GLSL\n* HLSL: 基于DirectX的High Level Shading Language,简称HLSL\n* Cg语言: NVIDIA公司的C for Graphic，简称Cg语言。\n\n因此，我们需要把CG/HLSL的语言嵌套在ShaderLab语言之中，值得注意的是，此处的CG/HLSL是Unity经过封装后的，但其语法和标准的CG/HLSL语法几乎一模一样，只有部分原生的函数和用法没有支持，感觉和当时的JavaScript和UnityScript感觉很类似。而且由于CG与DX9风格的HLSL从写法上而言几乎是同一种语言，因此在Unity里CG与HLSL是等价的。同样的，ShaderLab也支持内嵌GLSL的！\n``` C\nCGPROGRAM\n    // CG/HLSL代码\n    // 支持平台：PC，Xbox360等等\nENDCG\n\nGLSLPROGRAM\n    // GLSL代码\n    // 支持平台：Mac OS X，OpenGL ES2.0，Linux\nENDGLSL\n```\nOK，现在基本的Unity Shader知识储备就差不多了，欢迎进入Shader的世界~\n### 5.几大SL的爱恨情仇\n摘抄自《GPU Programming And Cg Language Primer 1rd Edition》 中文名《GPU编程与CG语言之阳春白雪下里巴人》\n>Shader language目前有3种主流语言：基于OpenGL的GLSL（OpenGL Shading Language，也称为GLslang），基于Direct3D的HLSL（High Level Shading Language），还有NVIDIA公司的Cg （C for Graphic）语言。\n>GLSL与HLSL分别提基于OpenGL和Direct3D的接口，两者不能混用，事实上OpenGL和Direct3D一直都是冤家对头，曹操和刘备还有一段和平共处的甜美时光，但OpenGL和Direct3D各自的东家则从来都是争斗不休。争斗良久，既然没有分出胜负，那么必然是两败俱伤的局面。\n\n>首先ATI系列显卡对OpenGL扩展支持不够，例如我在使用OSG（Open Scene Graphic）开源图形引擎时，由于该引擎完全基于OpenGL，导致其上编写的3D仿真程序在较老的显卡上常常出现纹理无法显示的问题。其次GLSL 的语法体系自成一家，而HLSL和Cg语言的语法基本相同，这就意味着，只要学习HLSL和Cg中的任何一种，就等同于学习了两种语言。不过OpenGL 毕竟图形API的曾经领袖，通常介绍OpenGL都会附加上一句“事实上的工业标准”，所以在其长期发展中积累下的用户群庞大，这些用户当然会选择 GLSL学习。此外，GLSL继承了OpenGL的良好移植性，一度在unix等操作系统上独领风骚（已是曾经的往事）。\n\n>微软的HLSL移植性较差，在windows平台上可谓一家独大，可一出自己的院子（还好院子够大），就是落地凤凰不如鸡。这一点在很大程度上限制了 HLSL的推广和发展。目前HLSL多半都是用于游戏领域。我可以负责任的断言，在Shader language领域，HLSL可以凭借微软的老本成为割据一方的诸侯，但，决不可能成为君临天下的霸主。这和微软现在的局面很像，就是一个被带刺鲜花簇拥着的大财主，富贵已极，寸步难行。\n\n>上面两个大佬打的很热烈，在这种情况下可以用一句俗话来形容，“鹬蚌相争，渔翁得利”。NVIDIA是现在当之无愧的显卡之王（尤其在AMD兼并ATI之后），是GPU编程理论的奠基者，GeForce系列显卡早已深入人心，它推出的Cg语言已经取得了巨大的成功，生生形成了三足鼎立之势。NVIDIA公司深通广告之道，目前最流行的GPU编程精粹一书就出自该公司，书中不但介绍了大量的GPU前沿知识，最重要的是大部分都用Cg语言实现。凭借该系列的书籍，NVIDIA不光确定了在青年学子间的学术地位，而且成功的推广了Cg语言。\n\n### 6.Unity与Cg/HLSL\n>Unity官方手册上讲Shader程序嵌入的小片段是用Cg/HLSL编写的，从“CGPROGRAM”开始，到“CGEND”结束。所以，Unity官方主要是用Cg/HLSL编写Shader程序片段。Unity官方手册也说明对于Cg/HLSL程序进行扩展也可以使用GLSL，不过Unity官方建议使用原生的GLSL进行编写和测试。如果不使用原生GLSL，你就需要知道你的平台必须是Mac OS X、OpenGL ES 2.0以上的移动设备或者是Linux。在一般情况下Unity会把Cg/HLSL交叉编译成优化过的GLSL。因此我们有多种选择，我们既可以考虑使用Cg/HLSL，也可以使用GLSL。不过由于Cg/HLSL更好的跨平台性，更倾向于使用Cg/HLSL编写Shader程序。\n\n","slug":"d_shaderLearning01","published":1,"updated":"2019-02-25T01:36:46.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsok3v3n000vl8v65apizx2l","content":"<p>这是自己开的第一篇技术帖，主要讲述下基本的shader入门知识。预计在这个寒假结束之前写完吧。<br><br>参考书籍：《Unity Shader入门精要》<br><br>Unity版本: Unity 2018.2.4f1<br><br>有人说过，程序员的三大浪漫是：编译原理，操作系统和计算机图形学。诚然，我认为这几门技术都是难度比较大的，或许再加上计算机网络与数据库系统？游戏中的美术是无比重要的，没有好的美术，纵使你的玩法再完美，受众玩家都不会多——毕竟控制台的游戏感官实在要差很多。美术只是贴图，而那些光照，反射与现实下的物理模拟，则是我们程序员的事情，shader便是解决这些问题的工具(当然，美术画出这些真实场景的情况也有——部分精致的动漫中，画师细节把握实在到位，观众往往会发出”啊，这光，啊这水”的惊讶感叹)，但是对实时要求极高的游戏而言，画师的画画速度则是远远不够了。</p>\n<h3 id=\"1-渲染流水线\"><a href=\"#1-渲染流水线\" class=\"headerlink\" title=\"1.渲染流水线\"></a>1.渲染流水线</h3><p>渲染，顾名思义，将东西(我们定义好的信息)画(渲染)在纸(屏幕)上，这一部分要用到很多的数学计算，由CPU和GPU共同完成。<br>《Render-Time Rendering》中将渲染流程分为三个阶段：应用阶段(Application Stage),几何阶段(Geometry Stage)，光栅化阶段(Rasterizer Stage)。<br>简单而言:</p>\n<blockquote>\n<ul>\n<li>应用阶段：准备好要场景数据，包括摄像机位置，视锥体，光源等信息。就像是画画，先想一下自己想要画什么东西。(大脑(CPU)负责)</li>\n<li>几何阶段：应用阶段告诉了我们场景中有啥，而这些基本图形是点，线，三角形这些东西构成，几何阶段便是画出这些东西，但是没有颜色和其他信息，就像是一幅画的线稿一样。(速写笔(GPU)负责))</li>\n<li>光栅化阶段：根据上个几何阶段传递过来的数据，来产生屏幕上的像素，并最终渲染出最终的图像，就像画画，线稿画好了，根据我们最开始设定好的颜色，考虑下光照之类的信息，用我们的画笔给这副画上好色。(画笔(GPU)负责))</li>\n</ul>\n</blockquote>\n<p>此外，我们场景中的东西可能很多，但能看到的只有摄像机视野范围那一块，因此，运用”裁剪”技术剔除掉那些不在视野范围内的物体。此外，我们如何把一个现实中的物体画到纸上呢？我们都知道透视几何画3D物体，像我们学过的立体几何那些。因此计算机渲染也需要这么个操作，将世界坐标映射到屏幕之上：</p>\n<blockquote>\n<p>屏幕映射(Screen Mapping)的任务是把每个物体的x和y坐标转换到屏幕坐标系(Screen Coordinate)下。屏幕坐标系是一个二维坐标系，与显示画面的分辨率有很大关系。物体的Z坐标不做处理，其代表深度值。</p>\n</blockquote>\n<p>映射就涉及到坐标系的转换了，这部分是基本的数学操作。此外，开发者直接访问GPU是很麻烦的事情，因此使用一个中间的图像编程接口是十分有必要的，由于使用的屏幕坐标系可能不同，造成这部分的数学操作也不一样：</p>\n<blockquote>\n<ul>\n<li>OpenGL</li>\n<li>DirectX</li>\n</ul>\n</blockquote>\n<h3 id=\"2-Unity-Shader-与-ShaderLab\"><a href=\"#2-Unity-Shader-与-ShaderLab\" class=\"headerlink\" title=\"2.Unity Shader 与 ShaderLab\"></a>2.Unity Shader 与 ShaderLab</h3><p>Unity使用Materials，Shaders和Textures来进行渲染，它们之间联系紧密，最终渲染出美轮美奂的画面。</p>\n<blockquote>\n<ul>\n<li>Material: Material通过它包含的贴图，布局与颜色等信息来定义一个表面应该如何被渲染。一个Material根据其使用的shader来使用不同的可选项。</li>\n<li>Shader：Shader是一种基于光照输入和Material配置来进行数学运算并计算出每个像素点(pixel)渲染颜色的脚本。</li>\n<li>Texture: Texture是一种位图图像。一个Material包含对textures的引用，所以Material的Shader就可以使用Texture去计算一个物体(GameObject)的表面颜色了。除了游戏对象表面的基本颜色(albedo)外，纹理还可以表示材质表面的许多其他方面，如反射率，粗糙度等等。</li>\n</ul>\n</blockquote>\n<p>一个Material对应于一个Shader，这个Shader决定了这个Material种哪些可用的选项。一个Shader则对应了一个或多个Texture，在Unity的Inspector面板你可以直接拖拽Texture资源给Shader。总体而言，在Unity中，常见的使用流程是：</p>\n<blockquote>\n<ol>\n<li>创建一个Material  </li>\n<li>创建一个Unity Shader，并把它赋给上一步的Material  </li>\n<li>把材质赋给要渲染的对象(GameObject)</li>\n</ol>\n</blockquote>\n<p>在Unity中，上诉操作都可以在Unity菜单栏中选择Asset-&gt;Create-&gt;Shader/Material等实现。</p>\n<div style=\"text-align:left\"><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/shaderCapture.png\"></div>\n\n<p>其中有四种模板的Unity Shader供我们选择:</p>\n<blockquote>\n<ul>\n<li>Standard Surface Shader：产生一个包含了标准光照模型的表面着色器模板</li>\n<li>Unlit Shader：产生一个不含光照效果(但含雾效果)的基本的顶点/片元着色器</li>\n<li>Image Effect Shader：提供一个屏幕后处理效果的基本模板</li>\n<li>Computer Shader：特殊Shader文件，旨在利用GPU的并行性来计算一些与常规渲染流水线无关的计算</li>\n</ul>\n</blockquote>\n<p>创建好Shader文件后，我们就可以开始我们的Unity Shader编程工作了。在Unity中，所有的Unity Shader都是由ShaderLib来编写的:</p>\n<blockquote>\n<p>ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。它使用一些嵌套在花括号内部的语义(syntax)来描述一个Unity Shader文件的结构。<br>一个Unity Shader的基础结构如下所示：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"ShaderName\"</span>&#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Shader Properties</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Subshader A</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Subshader B</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Unity在背后会根据所使用的平台来把这些结构编译为真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可，这就像我们使用C/C++等编程语言，而编译器会编译为机器语言。在这里，我们使用Unity Shader进行编程，Unity将其翻译为真正的Shader文件。</p>\n<p>在没有Unity这类编辑器的情况下，如果我们想要对某个模型设置渲染状态，需要十分复杂的代码，有了解过OpenGL的同学可能会有感受：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialization</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化渲染设置</span></span><br><span class=\"line\">    <span class=\"comment\">//从硬盘加载顶点着色器代码</span></span><br><span class=\"line\">    <span class=\"comment\">//从硬盘加载片元着色器代码</span></span><br><span class=\"line\">    <span class=\"comment\">//把顶点着色器加载到GPU</span></span><br><span class=\"line\">    <span class=\"comment\">//把片元着色器加载到GPU</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> vertexShaderCode = LoadShaderFromFile(VertexShader.shader);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> fragmentShaderCode = LoadShaderFromFile(FragmentShader.shader);</span><br><span class=\"line\">    LoadVertexShaderFromString(vertextShaderCode);</span><br><span class=\"line\">    LoadFragmentShaderFromString(fragmentShaderCode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置模型顶点坐标</span></span><br><span class=\"line\">    <span class=\"comment\">//加载纹理图片</span></span><br><span class=\"line\">    <span class=\"comment\">//加载预处理的变换矩阵</span></span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"vertexPosition\"</span>,vertices);</span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"MainTex\"</span>,someTexture);</span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"MVP\"</span>,MVP);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//关闭混合</span></span><br><span class=\"line\">    Disable(Blend);</span><br><span class=\"line\">    <span class=\"comment\">//设置深度测试</span></span><br><span class=\"line\">    Enable(ZTest);</span><br><span class=\"line\">    SetZTestFunction(LessOrEqual);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他设置</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每一帧进行渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnRendering</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    DrawCall();</span><br><span class=\"line\">    <span class=\"comment\">//其他渲染设置</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上诉是渲染的流程，一般都用C/C++实现，而真正的shader文件则像下面样子:</p>\n<p>顶点着色器 VertexShader.shader<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入:顶点位置，纹理，MVP变换矩阵</span></span><br><span class=\"line\">in float3 vertexPosition;</span><br><span class=\"line\">in sample2D MainTex;</span><br><span class=\"line\">in Matrix4x4 MVP;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出:顶点经过MVP变换后的位置</span></span><br><span class=\"line\">out float4 position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    position = MVP * vertexPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>片元着色器 FragmentShader.shader<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入:VertexShader输出的position,光栅化程序插值后的position</span></span><br><span class=\"line\">in float4 position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出:片元颜色值</span></span><br><span class=\"line\">out float4 fragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//片元设置为白色</span></span><br><span class=\"line\">    fragColor = float4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这仅仅是超级简化版本了，除去许多冗长的函数名(函数功能还是很清晰的)之外，执行顺序，渲染数目的增多会让过程变得更加负责。幸运的是，使用Unity shader，我们便可以十分简单的实现上述的所有步骤了——这也就是抽象的好处：”计算机中的任何问题都可以增加一层抽象来解决”。</p>\n<p>从设计上而言，ShaderLab类似于CgFX和Direct3D Effects(.FX)语言。接下来，我们简要学习一下Unity Shader的基本结构，写出个”Hello Shader”来吧。</p>\n<h3 id=\"3-Unity-Shader-Structure\"><a href=\"#3-Unity-Shader-Structure\" class=\"headerlink\" title=\"3.Unity Shader Structure\"></a>3.Unity Shader Structure</h3><h4 id=\"3-1-Shader-Name\"><a href=\"#3-1-Shader-Name\" class=\"headerlink\" title=\"3.1 Shader Name\"></a>3.1 Shader Name</h4><p>就和所有的编程一样，首先我们要为Unity Shader文件中定义的Shader取一个名字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;Customer/MyShader&quot;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当Material需要使用该shader时，就可以在下拉列表内找到。</p>\n<h4 id=\"3-2-Properties\"><a href=\"#3-2-Properties\" class=\"headerlink\" title=\"3.2 Properties\"></a>3.2 Properties</h4><p>Properties语义块包含了许多的属性(property)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class=\"line\">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class=\"line\">    //更多属性</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明这些属性就像声明一个Public的变量一样，我们可以在材质面板中很方便地调整各种材质属性等。<br><br>Properties 中字段含义:</p>\n<ul>\n<li>Name 是我们在shader中要访问该变量时使用的名字，约定俗成一般以下划线开始</li>\n<li>display name 是出现在材质面板上的名字</li>\n<li>PropertyType 是属性的类型</li>\n<li>DefaultValue 是属性默认值</li>\n</ul>\n<p>Properties所支持的PropertyType:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性类型</th>\n<th style=\"text-align:left\">默认值的定义语法</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Int(“Int”,Int)=2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Float</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Float(“Float”,Float)=1.5</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Range(min,max)</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Range(“Range”,Range(0.0,5.0))=3.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Color</td>\n<td style=\"text-align:left\">(number,number,number,number)</td>\n<td style=\"text-align:left\">_Color(“Color”,Color)=(1,1,1,1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Vector</td>\n<td style=\"text-align:left\">(number,number,number,number)</td>\n<td style=\"text-align:left\">_Vector(“Vector”,Vector)=(2,3,6,1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2D</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_2d(“2D”,2D)=””{}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Cube</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_Cube(“Cube”,Cube)=”white”{}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3D</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_3D(“3D”,3D)=”black”{}</td>\n</tr>\n</tbody>\n</table>\n<p><br>对于Int,Float,Range这些属性，其默认值就是一个单独的数字<br><br>对于Color,Vector这些属性，默认值是一个四维向量<br><br>对于2D,Cube,3D这些属性，由一个字符串加{}组成，前面字符串要么为空，要么是内置的纹理名称，如”whit”,”black”,”gray”或”bump”这些，{}中指定一些纹理属性<br><br>最后我们可以得到一个超级简单的”Hello Shader”的例子：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/NewSurfaceShader\"</span> &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        _Int(<span class=\"string\">\"Int\"</span>,Int) = <span class=\"number\">2</span></span><br><span class=\"line\">        _Float(<span class=\"string\">\"Float\"</span>,Float) = <span class=\"number\">1.5</span></span><br><span class=\"line\">        _Range(<span class=\"string\">\"Range\"</span>,Range(<span class=\"number\">0.0</span>,<span class=\"number\">5.0</span>)) = <span class=\"number\">1.5</span></span><br><span class=\"line\">        _Color(<span class=\"string\">\"Color\"</span>, Color) = (<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">        _Vector(<span class=\"string\">\"Vector\"</span>,Vector) = (<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">        _2D(<span class=\"string\">\"2D\"</span>,<span class=\"number\">2</span>D)=<span class=\"string\">\"\"</span>&#123;&#125;</span><br><span class=\"line\">        _Cube(<span class=\"string\">\"Cuben\"</span>,Cube)=<span class=\"string\">\"White\"</span>&#123;&#125;</span><br><span class=\"line\">        _3D(<span class=\"string\">\"3D\"</span>,<span class=\"number\">3</span>D)=<span class=\"string\">\"black\"</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    FallBack <span class=\"string\">\"Diffuse\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br>在Unity编辑器中如下图所示:</p>\n<div><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/Material_Shader_Show.png\"></div>\n\n<p>此外一些其他类型的变量若是想显示出来，Unity允许我们重载默认的材质编辑面板，流程与Customer Editor那套自定义Inspector的方式类似，只不过现在是Shader材质面板了，有兴趣了解的同学可以参考官方<a href=\"http://docs.unity3d.com/Manual/SL-CustomShaderGUI\" target=\"_blank\" rel=\"noopener\">Custome Shader GUI</a>。</p>\n<h4 id=\"3-3-SubShader\"><a href=\"#3-3-SubShader\" class=\"headerlink\" title=\"3.3 SubShader\"></a>3.3 SubShader</h4><blockquote>\n<p>每一个Unity Shader文件可以包含多个SubShader语义块，但至少要有一个。当Unity需要运行这个Unity Shader时，会依次扫描所有的SubShader，然后选择第一个可以在目标平台运行的SubShader。如果都不支持的话，会使用FallBack语义所指定的Unity Shader。</p>\n</blockquote>\n<p>之所这么设计的原因，是因为用户的显卡能力不同，为提供更加流畅与精美的画面，对高性能显卡的用户就是用较高计算复杂度的着色器，低性能的就使用较低计算复杂度的着色器。</p>\n<p>SubShader语义块形式如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubShader &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可选</span></span><br><span class=\"line\">    [Tags]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//可选</span></span><br><span class=\"line\">    [RenderSetup]</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//other passes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>字段描述：</p>\n<ul>\n<li>Pass: 每个Pass定义了一次完整的渲染流程,但如果Pass数量过多会造成渲染性能下降</li>\n<li>RenderSetup: 渲染状态设置指令，可以设置显卡的各种状态，例如是否开启混合/深度测试等，设置之后会作用于所有的Pass块，常见RenderSetup设置见下表。</li>\n<li>Tags: 标签(tags)时一个键值对，它的键和值都是字符串类型。常见Tags支持类型见下表。</li>\n</ul>\n<p>常见的RenderSetup设置选项：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态名称</th>\n<th style=\"text-align:left\">设置指令</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Cull</td>\n<td style=\"text-align:left\">Cull Back/Font/Off</td>\n<td style=\"text-align:left\">设置剔除模式:剔除背面/正面/关闭剔除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZTest</td>\n<td style=\"text-align:left\">ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always</td>\n<td style=\"text-align:left\">设置深度剔除时使用的函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZWrite</td>\n<td style=\"text-align:left\">ZWrite On/Off</td>\n<td style=\"text-align:left\">开启/关闭深度写入</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Blend</td>\n<td style=\"text-align:left\">Blend SrcFactor DstFactor</td>\n<td style=\"text-align:left\">开启并设置混合模式</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>当在SubShader中设置了上述渲染状态时，将会应用到所有的Pass上去。</p>\n</blockquote>\n<p>Tags支持类型</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标签类别</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Queue</td>\n<td style=\"text-align:left\">控制渲染顺序，可以指定该物体属于哪个渲染队列，通过这种方式可以保证所有透明物体都可以在不透明物体之后被渲染</td>\n<td style=\"text-align:left\">Tags{“Queue”=”Transparent”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RenderType</td>\n<td style=\"text-align:left\">对着色器进行分类，例如这是个不透明的着色器，或是一个透明的着色器，可以用于着色器替换功能(Shader Replacement)</td>\n<td style=\"text-align:left\">Tags{“RenderType”=”Opaque”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DisableBatching</td>\n<td style=\"text-align:left\">是否对该SubShader使用批处理</td>\n<td style=\"text-align:left\">Tags{“DisableBatching”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ForceNoShadowCasting</td>\n<td style=\"text-align:left\">控制使用该SubShader的物体是否会投射阴影</td>\n<td style=\"text-align:left\">Tags{“ForceNoShadowCasting”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IgnoreProjector</td>\n<td style=\"text-align:left\">控制使用该SubShader的物体是否会受到Projector的影响，通常用于半透明物体</td>\n<td style=\"text-align:left\">Tags{“Ignore’Projector”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CanUseSpriteAtlas</td>\n<td style=\"text-align:left\">当该SubShader是用于精灵(sprite)时，将该标签设为”False”</td>\n<td style=\"text-align:left\">Tags{“CanUseSpriteAtlas”=”False”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PreviewType</td>\n<td style=\"text-align:left\">指明材质面板将如何预览该材质，默认情况下，材质将显示为一个球形，我们可以通过把该标签设置为”Plane”，”SkyBox”来改变预览模型</td>\n<td style=\"text-align:left\">Tags{“PreviewType”=”Plane”}</td>\n</tr>\n</tbody>\n</table>\n<p>上诉Tags仅可以在SubShader中声明，而不可以在Pass中声明。Pass块中也有标签可以定义，但它们不同于SubShader的标签类型。</p>\n<blockquote>\n<p>Pass语义块</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pass &#123;</span><br><span class=\"line\">    [Name]</span><br><span class=\"line\">    [Tags]</span><br><span class=\"line\">    [RenderSetup]</span><br><span class=\"line\">    <span class=\"comment\">//other Code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Name “MyPassName”</p>\n</blockquote>\n<p>通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass。如：</p>\n<blockquote>\n<p>UsePass “MyShader/MYPASSNAME”</p>\n</blockquote>\n<p>这样可以提高代码复用率，但需要注意的是，Unity内部会把所有Pass名字转换为大写字母表示，因此使用UsePass命令时，必须使用大写形式的名字。</p>\n<p>其次，Pass也可以设置渲染状态(RenderSetup)与标签(Tags)，渲染状态可以使用SubShader中支持的渲染状态，还可以使用固定管线的着色器命令。</p>\n<p>Pass同样可以设置标签，但其标签不同于SubShader标签，Pass中支持的标签如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标签类型</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">LightMode</td>\n<td style=\"text-align:left\">定义该Pass在Unity渲染流水线中的角色</td>\n<td style=\"text-align:left\">Tags{“LightMode”=”ForwardBase”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RequireOptions</td>\n<td style=\"text-align:left\">用于指定当满足某些条件时才渲染该Pass</td>\n<td style=\"text-align:left\">Tags{“RequireOptions”=”SoftVegetation”}</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-4-Fallback\"><a href=\"#3-4-Fallback\" class=\"headerlink\" title=\"3.4 Fallback\"></a>3.4 Fallback</h4><p>紧跟在Unity Shader后面的是一个Fallback语句，它是最后一道保险，即如果所有的SubShader都不能用的话，就使用这个吧。语义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fallback <span class=\"string\">\"name\"</span></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">Fallback off</span><br></pre></td></tr></table></figure></p>\n<p>综上所述，我们可以通过一个字符串来指明这个”最后的Shader”，当然你也可以”宁缺毋滥”——不能按我的意思渲染的话，那就不要管它了。但是啊，FallBack还会影响阴影的投射，在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投影的Pass，通常情况下我们不需要自己去实现一个这样的Pass，这是因为Fallback使用的内置Shader中往往包含了一个这样的通用Pass，因此为每个Unity Shader设置好Fallback还是十分重要的。</p>\n<h3 id=\"4-CG-HLSL\"><a href=\"#4-CG-HLSL\" class=\"headerlink\" title=\"4.CG/HLSL\"></a>4.CG/HLSL</h3><p>目前，我们基本理解了一个Unity Shader的结构了，Properties里面定义属性，在SubShader中写真正的着色器代码。</p>\n<p>好了，还记得Unity提供给我们的四种Unity Shader模板么？实际上那便对应了Unity Shader的两个不同类型：表面着色器(Surface Shader)与顶点/片元着色器(Vertex/Fragment Shader)</p>\n<p>我们来看一个非常简单的表面着色器代码(Surface Shader)<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/Simple Surface Shader\"</span>&#123;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        Tags&#123;<span class=\"string\">\"RenderType\"</span>=<span class=\"string\">\"Opaque\"</span>&#125;</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        #Pragma surface surf Lambert</span><br><span class=\"line\">        struct Input&#123;</span><br><span class=\"line\">            float4 color : COLOR;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">surf</span> <span class=\"params\">(Input IN,inout surfaceOutput o)</span></span>&#123;</span><br><span class=\"line\">            o.Albedo = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback <span class=\"string\">\"Diffuse\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看一个非常简单的顶点/片元着色器(Vertex/Fragment Shader)<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/Simple VertexFragment Shader\"</span>&#123;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        Pass&#123;</span><br><span class=\"line\">            CGProGRAM</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\"></span><br><span class=\"line\">            float4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mul (UNITY_MATRIX_MVP, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fixed4 frag() : SV_Target&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fixed4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ENDCG</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是Unity Shader的两种不同形式</p>\n<ul>\n<li>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型，其所需要的代码量很少，Unity在背后做了很多工作，但渲染的代价比较大。其本质还是顶点/片元着色器，实际上就是顶点/片元着色器更高一层的抽象。它存在的价值在于为开发者处理了很多很多的光照细节，使得开发者不需要操心这些事情。</li>\n</ul>\n<blockquote>\n<p>表面着色器被定义在<strong>SubShader语义块(而非Pass语义块)</strong>中的CGPROGRAM与ENDCG之间，原因是表面着色器不关心开发者用多少个Pass，每个Pass如何渲染等问题，Unity会在背后做好这些事情。开发者所需要做的，就只是简单地告诉Surface Shader用”这个纹理”去填充颜色，用”这个法线纹理”去填充法线，使用光照模型等。具体细节不用关系。</p>\n</blockquote>\n<ul>\n<li>顶点/片元着色器(Vertex/Fragment Shader)则更加复杂，灵活性也更高。</li>\n</ul>\n<blockquote>\n<p>和表面着色器类似，顶点/片元着色器地代码也需要定义在CGPROGRAM与ENDCG之间，但不同地是，顶点/片元着色器是写在<strong>Pass语义块内(而非SubShader内)</strong>。因此，我们需要自己定义每个Pass需要使用地Shader代码，可以控制渲染的实现细节。</p>\n</blockquote>\n<p>那么CGPROGRAM与ENDCG之间是什么呢？首先我们要了解一下当下主流的几种Shader Language(SL):</p>\n<blockquote>\n<p>目前主流的Shader Language有3种语言</p>\n<ul>\n<li>GLSL：基于OpenGL的OpenGL Shading Language，简称GLSL</li>\n<li>HLSL: 基于DirectX的High Level Shading Language,简称HLSL</li>\n<li>Cg语言: NVIDIA公司的C for Graphic，简称Cg语言。</li>\n</ul>\n</blockquote>\n<p>因此，我们需要把CG/HLSL的语言嵌套在ShaderLab语言之中，值得注意的是，此处的CG/HLSL是Unity经过封装后的，但其语法和标准的CG/HLSL语法几乎一模一样，只有部分原生的函数和用法没有支持，感觉和当时的JavaScript和UnityScript感觉很类似。而且由于CG与DX9风格的HLSL从写法上而言几乎是同一种语言，因此在Unity里CG与HLSL是等价的。同样的，ShaderLab也支持内嵌GLSL的！<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CGPROGRAM</span><br><span class=\"line\">    <span class=\"comment\">// CG/HLSL代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 支持平台：PC，Xbox360等等</span></span><br><span class=\"line\">ENDCG</span><br><span class=\"line\"></span><br><span class=\"line\">GLSLPROGRAM</span><br><span class=\"line\">    <span class=\"comment\">// GLSL代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 支持平台：Mac OS X，OpenGL ES2.0，Linux</span></span><br><span class=\"line\">ENDGLSL</span><br></pre></td></tr></table></figure></p>\n<p>OK，现在基本的Unity Shader知识储备就差不多了，欢迎进入Shader的世界~</p>\n<h3 id=\"5-几大SL的爱恨情仇\"><a href=\"#5-几大SL的爱恨情仇\" class=\"headerlink\" title=\"5.几大SL的爱恨情仇\"></a>5.几大SL的爱恨情仇</h3><p>摘抄自《GPU Programming And Cg Language Primer 1rd Edition》 中文名《GPU编程与CG语言之阳春白雪下里巴人》</p>\n<blockquote>\n<p>Shader language目前有3种主流语言：基于OpenGL的GLSL（OpenGL Shading Language，也称为GLslang），基于Direct3D的HLSL（High Level Shading Language），还有NVIDIA公司的Cg （C for Graphic）语言。<br>GLSL与HLSL分别提基于OpenGL和Direct3D的接口，两者不能混用，事实上OpenGL和Direct3D一直都是冤家对头，曹操和刘备还有一段和平共处的甜美时光，但OpenGL和Direct3D各自的东家则从来都是争斗不休。争斗良久，既然没有分出胜负，那么必然是两败俱伤的局面。</p>\n</blockquote>\n<blockquote>\n<p>首先ATI系列显卡对OpenGL扩展支持不够，例如我在使用OSG（Open Scene Graphic）开源图形引擎时，由于该引擎完全基于OpenGL，导致其上编写的3D仿真程序在较老的显卡上常常出现纹理无法显示的问题。其次GLSL 的语法体系自成一家，而HLSL和Cg语言的语法基本相同，这就意味着，只要学习HLSL和Cg中的任何一种，就等同于学习了两种语言。不过OpenGL 毕竟图形API的曾经领袖，通常介绍OpenGL都会附加上一句“事实上的工业标准”，所以在其长期发展中积累下的用户群庞大，这些用户当然会选择 GLSL学习。此外，GLSL继承了OpenGL的良好移植性，一度在unix等操作系统上独领风骚（已是曾经的往事）。</p>\n</blockquote>\n<blockquote>\n<p>微软的HLSL移植性较差，在windows平台上可谓一家独大，可一出自己的院子（还好院子够大），就是落地凤凰不如鸡。这一点在很大程度上限制了 HLSL的推广和发展。目前HLSL多半都是用于游戏领域。我可以负责任的断言，在Shader language领域，HLSL可以凭借微软的老本成为割据一方的诸侯，但，决不可能成为君临天下的霸主。这和微软现在的局面很像，就是一个被带刺鲜花簇拥着的大财主，富贵已极，寸步难行。</p>\n</blockquote>\n<blockquote>\n<p>上面两个大佬打的很热烈，在这种情况下可以用一句俗话来形容，“鹬蚌相争，渔翁得利”。NVIDIA是现在当之无愧的显卡之王（尤其在AMD兼并ATI之后），是GPU编程理论的奠基者，GeForce系列显卡早已深入人心，它推出的Cg语言已经取得了巨大的成功，生生形成了三足鼎立之势。NVIDIA公司深通广告之道，目前最流行的GPU编程精粹一书就出自该公司，书中不但介绍了大量的GPU前沿知识，最重要的是大部分都用Cg语言实现。凭借该系列的书籍，NVIDIA不光确定了在青年学子间的学术地位，而且成功的推广了Cg语言。</p>\n</blockquote>\n<h3 id=\"6-Unity与Cg-HLSL\"><a href=\"#6-Unity与Cg-HLSL\" class=\"headerlink\" title=\"6.Unity与Cg/HLSL\"></a>6.Unity与Cg/HLSL</h3><blockquote>\n<p>Unity官方手册上讲Shader程序嵌入的小片段是用Cg/HLSL编写的，从“CGPROGRAM”开始，到“CGEND”结束。所以，Unity官方主要是用Cg/HLSL编写Shader程序片段。Unity官方手册也说明对于Cg/HLSL程序进行扩展也可以使用GLSL，不过Unity官方建议使用原生的GLSL进行编写和测试。如果不使用原生GLSL，你就需要知道你的平台必须是Mac OS X、OpenGL ES 2.0以上的移动设备或者是Linux。在一般情况下Unity会把Cg/HLSL交叉编译成优化过的GLSL。因此我们有多种选择，我们既可以考虑使用Cg/HLSL，也可以使用GLSL。不过由于Cg/HLSL更好的跨平台性，更倾向于使用Cg/HLSL编写Shader程序。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>这是自己开的第一篇技术帖，主要讲述下基本的shader入门知识。预计在这个寒假结束之前写完吧。<br><br>参考书籍：《Unity Shader入门精要》<br><br>Unity版本: Unity 2018.2.4f1<br><br>有人说过，程序员的三大浪漫是：编译原理，操作系统和计算机图形学。诚然，我认为这几门技术都是难度比较大的，或许再加上计算机网络与数据库系统？游戏中的美术是无比重要的，没有好的美术，纵使你的玩法再完美，受众玩家都不会多——毕竟控制台的游戏感官实在要差很多。美术只是贴图，而那些光照，反射与现实下的物理模拟，则是我们程序员的事情，shader便是解决这些问题的工具(当然，美术画出这些真实场景的情况也有——部分精致的动漫中，画师细节把握实在到位，观众往往会发出”啊，这光，啊这水”的惊讶感叹)，但是对实时要求极高的游戏而言，画师的画画速度则是远远不够了。</p>\n<h3 id=\"1-渲染流水线\"><a href=\"#1-渲染流水线\" class=\"headerlink\" title=\"1.渲染流水线\"></a>1.渲染流水线</h3><p>渲染，顾名思义，将东西(我们定义好的信息)画(渲染)在纸(屏幕)上，这一部分要用到很多的数学计算，由CPU和GPU共同完成。<br>《Render-Time Rendering》中将渲染流程分为三个阶段：应用阶段(Application Stage),几何阶段(Geometry Stage)，光栅化阶段(Rasterizer Stage)。<br>简单而言:</p>\n<blockquote>\n<ul>\n<li>应用阶段：准备好要场景数据，包括摄像机位置，视锥体，光源等信息。就像是画画，先想一下自己想要画什么东西。(大脑(CPU)负责)</li>\n<li>几何阶段：应用阶段告诉了我们场景中有啥，而这些基本图形是点，线，三角形这些东西构成，几何阶段便是画出这些东西，但是没有颜色和其他信息，就像是一幅画的线稿一样。(速写笔(GPU)负责))</li>\n<li>光栅化阶段：根据上个几何阶段传递过来的数据，来产生屏幕上的像素，并最终渲染出最终的图像，就像画画，线稿画好了，根据我们最开始设定好的颜色，考虑下光照之类的信息，用我们的画笔给这副画上好色。(画笔(GPU)负责))</li>\n</ul>\n</blockquote>\n<p>此外，我们场景中的东西可能很多，但能看到的只有摄像机视野范围那一块，因此，运用”裁剪”技术剔除掉那些不在视野范围内的物体。此外，我们如何把一个现实中的物体画到纸上呢？我们都知道透视几何画3D物体，像我们学过的立体几何那些。因此计算机渲染也需要这么个操作，将世界坐标映射到屏幕之上：</p>\n<blockquote>\n<p>屏幕映射(Screen Mapping)的任务是把每个物体的x和y坐标转换到屏幕坐标系(Screen Coordinate)下。屏幕坐标系是一个二维坐标系，与显示画面的分辨率有很大关系。物体的Z坐标不做处理，其代表深度值。</p>\n</blockquote>\n<p>映射就涉及到坐标系的转换了，这部分是基本的数学操作。此外，开发者直接访问GPU是很麻烦的事情，因此使用一个中间的图像编程接口是十分有必要的，由于使用的屏幕坐标系可能不同，造成这部分的数学操作也不一样：</p>\n<blockquote>\n<ul>\n<li>OpenGL</li>\n<li>DirectX</li>\n</ul>\n</blockquote>\n<h3 id=\"2-Unity-Shader-与-ShaderLab\"><a href=\"#2-Unity-Shader-与-ShaderLab\" class=\"headerlink\" title=\"2.Unity Shader 与 ShaderLab\"></a>2.Unity Shader 与 ShaderLab</h3><p>Unity使用Materials，Shaders和Textures来进行渲染，它们之间联系紧密，最终渲染出美轮美奂的画面。</p>\n<blockquote>\n<ul>\n<li>Material: Material通过它包含的贴图，布局与颜色等信息来定义一个表面应该如何被渲染。一个Material根据其使用的shader来使用不同的可选项。</li>\n<li>Shader：Shader是一种基于光照输入和Material配置来进行数学运算并计算出每个像素点(pixel)渲染颜色的脚本。</li>\n<li>Texture: Texture是一种位图图像。一个Material包含对textures的引用，所以Material的Shader就可以使用Texture去计算一个物体(GameObject)的表面颜色了。除了游戏对象表面的基本颜色(albedo)外，纹理还可以表示材质表面的许多其他方面，如反射率，粗糙度等等。</li>\n</ul>\n</blockquote>\n<p>一个Material对应于一个Shader，这个Shader决定了这个Material种哪些可用的选项。一个Shader则对应了一个或多个Texture，在Unity的Inspector面板你可以直接拖拽Texture资源给Shader。总体而言，在Unity中，常见的使用流程是：</p>\n<blockquote>\n<ol>\n<li>创建一个Material  </li>\n<li>创建一个Unity Shader，并把它赋给上一步的Material  </li>\n<li>把材质赋给要渲染的对象(GameObject)</li>\n</ol>\n</blockquote>\n<p>在Unity中，上诉操作都可以在Unity菜单栏中选择Asset-&gt;Create-&gt;Shader/Material等实现。</p>\n<div style=\"text-align:left\"><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/shaderCapture.png\"></div>\n\n<p>其中有四种模板的Unity Shader供我们选择:</p>\n<blockquote>\n<ul>\n<li>Standard Surface Shader：产生一个包含了标准光照模型的表面着色器模板</li>\n<li>Unlit Shader：产生一个不含光照效果(但含雾效果)的基本的顶点/片元着色器</li>\n<li>Image Effect Shader：提供一个屏幕后处理效果的基本模板</li>\n<li>Computer Shader：特殊Shader文件，旨在利用GPU的并行性来计算一些与常规渲染流水线无关的计算</li>\n</ul>\n</blockquote>\n<p>创建好Shader文件后，我们就可以开始我们的Unity Shader编程工作了。在Unity中，所有的Unity Shader都是由ShaderLib来编写的:</p>\n<blockquote>\n<p>ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。它使用一些嵌套在花括号内部的语义(syntax)来描述一个Unity Shader文件的结构。<br>一个Unity Shader的基础结构如下所示：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"ShaderName\"</span>&#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Shader Properties</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Subshader A</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Subshader B</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Unity在背后会根据所使用的平台来把这些结构编译为真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可，这就像我们使用C/C++等编程语言，而编译器会编译为机器语言。在这里，我们使用Unity Shader进行编程，Unity将其翻译为真正的Shader文件。</p>\n<p>在没有Unity这类编辑器的情况下，如果我们想要对某个模型设置渲染状态，需要十分复杂的代码，有了解过OpenGL的同学可能会有感受：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Initialization</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化渲染设置</span></span><br><span class=\"line\">    <span class=\"comment\">//从硬盘加载顶点着色器代码</span></span><br><span class=\"line\">    <span class=\"comment\">//从硬盘加载片元着色器代码</span></span><br><span class=\"line\">    <span class=\"comment\">//把顶点着色器加载到GPU</span></span><br><span class=\"line\">    <span class=\"comment\">//把片元着色器加载到GPU</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> vertexShaderCode = LoadShaderFromFile(VertexShader.shader);</span><br><span class=\"line\">    <span class=\"built_in\">string</span> fragmentShaderCode = LoadShaderFromFile(FragmentShader.shader);</span><br><span class=\"line\">    LoadVertexShaderFromString(vertextShaderCode);</span><br><span class=\"line\">    LoadFragmentShaderFromString(fragmentShaderCode);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置模型顶点坐标</span></span><br><span class=\"line\">    <span class=\"comment\">//加载纹理图片</span></span><br><span class=\"line\">    <span class=\"comment\">//加载预处理的变换矩阵</span></span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"vertexPosition\"</span>,vertices);</span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"MainTex\"</span>,someTexture);</span><br><span class=\"line\">    SetVertexShaderProperty(<span class=\"string\">\"MVP\"</span>,MVP);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//关闭混合</span></span><br><span class=\"line\">    Disable(Blend);</span><br><span class=\"line\">    <span class=\"comment\">//设置深度测试</span></span><br><span class=\"line\">    Enable(ZTest);</span><br><span class=\"line\">    SetZTestFunction(LessOrEqual);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//其他设置</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每一帧进行渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OnRendering</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    DrawCall();</span><br><span class=\"line\">    <span class=\"comment\">//其他渲染设置</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上诉是渲染的流程，一般都用C/C++实现，而真正的shader文件则像下面样子:</p>\n<p>顶点着色器 VertexShader.shader<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入:顶点位置，纹理，MVP变换矩阵</span></span><br><span class=\"line\">in float3 vertexPosition;</span><br><span class=\"line\">in sample2D MainTex;</span><br><span class=\"line\">in Matrix4x4 MVP;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出:顶点经过MVP变换后的位置</span></span><br><span class=\"line\">out float4 position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    position = MVP * vertexPosition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>片元着色器 FragmentShader.shader<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输入:VertexShader输出的position,光栅化程序插值后的position</span></span><br><span class=\"line\">in float4 position;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出:片元颜色值</span></span><br><span class=\"line\">out float4 fragColor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//片元设置为白色</span></span><br><span class=\"line\">    fragColor = float4(<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这仅仅是超级简化版本了，除去许多冗长的函数名(函数功能还是很清晰的)之外，执行顺序，渲染数目的增多会让过程变得更加负责。幸运的是，使用Unity shader，我们便可以十分简单的实现上述的所有步骤了——这也就是抽象的好处：”计算机中的任何问题都可以增加一层抽象来解决”。</p>\n<p>从设计上而言，ShaderLab类似于CgFX和Direct3D Effects(.FX)语言。接下来，我们简要学习一下Unity Shader的基本结构，写出个”Hello Shader”来吧。</p>\n<h3 id=\"3-Unity-Shader-Structure\"><a href=\"#3-Unity-Shader-Structure\" class=\"headerlink\" title=\"3.Unity Shader Structure\"></a>3.Unity Shader Structure</h3><h4 id=\"3-1-Shader-Name\"><a href=\"#3-1-Shader-Name\" class=\"headerlink\" title=\"3.1 Shader Name\"></a>3.1 Shader Name</h4><p>就和所有的编程一样，首先我们要为Unity Shader文件中定义的Shader取一个名字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;Customer/MyShader&quot;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，当Material需要使用该shader时，就可以在下拉列表内找到。</p>\n<h4 id=\"3-2-Properties\"><a href=\"#3-2-Properties\" class=\"headerlink\" title=\"3.2 Properties\"></a>3.2 Properties</h4><p>Properties语义块包含了许多的属性(property)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class=\"line\">    Name (&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class=\"line\">    //更多属性</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明这些属性就像声明一个Public的变量一样，我们可以在材质面板中很方便地调整各种材质属性等。<br><br>Properties 中字段含义:</p>\n<ul>\n<li>Name 是我们在shader中要访问该变量时使用的名字，约定俗成一般以下划线开始</li>\n<li>display name 是出现在材质面板上的名字</li>\n<li>PropertyType 是属性的类型</li>\n<li>DefaultValue 是属性默认值</li>\n</ul>\n<p>Properties所支持的PropertyType:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性类型</th>\n<th style=\"text-align:left\">默认值的定义语法</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Int(“Int”,Int)=2</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Float</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Float(“Float”,Float)=1.5</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Range(min,max)</td>\n<td style=\"text-align:left\">number</td>\n<td style=\"text-align:left\">_Range(“Range”,Range(0.0,5.0))=3.0</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Color</td>\n<td style=\"text-align:left\">(number,number,number,number)</td>\n<td style=\"text-align:left\">_Color(“Color”,Color)=(1,1,1,1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Vector</td>\n<td style=\"text-align:left\">(number,number,number,number)</td>\n<td style=\"text-align:left\">_Vector(“Vector”,Vector)=(2,3,6,1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2D</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_2d(“2D”,2D)=””{}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Cube</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_Cube(“Cube”,Cube)=”white”{}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3D</td>\n<td style=\"text-align:left\">“defaulttexture”{}</td>\n<td style=\"text-align:left\">_3D(“3D”,3D)=”black”{}</td>\n</tr>\n</tbody>\n</table>\n<p><br>对于Int,Float,Range这些属性，其默认值就是一个单独的数字<br><br>对于Color,Vector这些属性，默认值是一个四维向量<br><br>对于2D,Cube,3D这些属性，由一个字符串加{}组成，前面字符串要么为空，要么是内置的纹理名称，如”whit”,”black”,”gray”或”bump”这些，{}中指定一些纹理属性<br><br>最后我们可以得到一个超级简单的”Hello Shader”的例子：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/NewSurfaceShader\"</span> &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        _Int(<span class=\"string\">\"Int\"</span>,Int) = <span class=\"number\">2</span></span><br><span class=\"line\">        _Float(<span class=\"string\">\"Float\"</span>,Float) = <span class=\"number\">1.5</span></span><br><span class=\"line\">        _Range(<span class=\"string\">\"Range\"</span>,Range(<span class=\"number\">0.0</span>,<span class=\"number\">5.0</span>)) = <span class=\"number\">1.5</span></span><br><span class=\"line\">        _Color(<span class=\"string\">\"Color\"</span>, Color) = (<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">        _Vector(<span class=\"string\">\"Vector\"</span>,Vector) = (<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">        _2D(<span class=\"string\">\"2D\"</span>,<span class=\"number\">2</span>D)=<span class=\"string\">\"\"</span>&#123;&#125;</span><br><span class=\"line\">        _Cube(<span class=\"string\">\"Cuben\"</span>,Cube)=<span class=\"string\">\"White\"</span>&#123;&#125;</span><br><span class=\"line\">        _3D(<span class=\"string\">\"3D\"</span>,<span class=\"number\">3</span>D)=<span class=\"string\">\"black\"</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    FallBack <span class=\"string\">\"Diffuse\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br>在Unity编辑器中如下图所示:</p>\n<div><img src=\"https://raw.githubusercontent.com/nature-god/MarkdownPhotos/master/Blog_Shader01/Material_Shader_Show.png\"></div>\n\n<p>此外一些其他类型的变量若是想显示出来，Unity允许我们重载默认的材质编辑面板，流程与Customer Editor那套自定义Inspector的方式类似，只不过现在是Shader材质面板了，有兴趣了解的同学可以参考官方<a href=\"http://docs.unity3d.com/Manual/SL-CustomShaderGUI\" target=\"_blank\" rel=\"noopener\">Custome Shader GUI</a>。</p>\n<h4 id=\"3-3-SubShader\"><a href=\"#3-3-SubShader\" class=\"headerlink\" title=\"3.3 SubShader\"></a>3.3 SubShader</h4><blockquote>\n<p>每一个Unity Shader文件可以包含多个SubShader语义块，但至少要有一个。当Unity需要运行这个Unity Shader时，会依次扫描所有的SubShader，然后选择第一个可以在目标平台运行的SubShader。如果都不支持的话，会使用FallBack语义所指定的Unity Shader。</p>\n</blockquote>\n<p>之所这么设计的原因，是因为用户的显卡能力不同，为提供更加流畅与精美的画面，对高性能显卡的用户就是用较高计算复杂度的着色器，低性能的就使用较低计算复杂度的着色器。</p>\n<p>SubShader语义块形式如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubShader &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可选</span></span><br><span class=\"line\">    [Tags]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//可选</span></span><br><span class=\"line\">    [RenderSetup]</span><br><span class=\"line\"></span><br><span class=\"line\">    Pass&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//other passes</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>字段描述：</p>\n<ul>\n<li>Pass: 每个Pass定义了一次完整的渲染流程,但如果Pass数量过多会造成渲染性能下降</li>\n<li>RenderSetup: 渲染状态设置指令，可以设置显卡的各种状态，例如是否开启混合/深度测试等，设置之后会作用于所有的Pass块，常见RenderSetup设置见下表。</li>\n<li>Tags: 标签(tags)时一个键值对，它的键和值都是字符串类型。常见Tags支持类型见下表。</li>\n</ul>\n<p>常见的RenderSetup设置选项：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">状态名称</th>\n<th style=\"text-align:left\">设置指令</th>\n<th style=\"text-align:left\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Cull</td>\n<td style=\"text-align:left\">Cull Back/Font/Off</td>\n<td style=\"text-align:left\">设置剔除模式:剔除背面/正面/关闭剔除</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZTest</td>\n<td style=\"text-align:left\">ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always</td>\n<td style=\"text-align:left\">设置深度剔除时使用的函数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ZWrite</td>\n<td style=\"text-align:left\">ZWrite On/Off</td>\n<td style=\"text-align:left\">开启/关闭深度写入</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Blend</td>\n<td style=\"text-align:left\">Blend SrcFactor DstFactor</td>\n<td style=\"text-align:left\">开启并设置混合模式</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>当在SubShader中设置了上述渲染状态时，将会应用到所有的Pass上去。</p>\n</blockquote>\n<p>Tags支持类型</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标签类别</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Queue</td>\n<td style=\"text-align:left\">控制渲染顺序，可以指定该物体属于哪个渲染队列，通过这种方式可以保证所有透明物体都可以在不透明物体之后被渲染</td>\n<td style=\"text-align:left\">Tags{“Queue”=”Transparent”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RenderType</td>\n<td style=\"text-align:left\">对着色器进行分类，例如这是个不透明的着色器，或是一个透明的着色器，可以用于着色器替换功能(Shader Replacement)</td>\n<td style=\"text-align:left\">Tags{“RenderType”=”Opaque”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DisableBatching</td>\n<td style=\"text-align:left\">是否对该SubShader使用批处理</td>\n<td style=\"text-align:left\">Tags{“DisableBatching”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ForceNoShadowCasting</td>\n<td style=\"text-align:left\">控制使用该SubShader的物体是否会投射阴影</td>\n<td style=\"text-align:left\">Tags{“ForceNoShadowCasting”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IgnoreProjector</td>\n<td style=\"text-align:left\">控制使用该SubShader的物体是否会受到Projector的影响，通常用于半透明物体</td>\n<td style=\"text-align:left\">Tags{“Ignore’Projector”=”True”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CanUseSpriteAtlas</td>\n<td style=\"text-align:left\">当该SubShader是用于精灵(sprite)时，将该标签设为”False”</td>\n<td style=\"text-align:left\">Tags{“CanUseSpriteAtlas”=”False”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PreviewType</td>\n<td style=\"text-align:left\">指明材质面板将如何预览该材质，默认情况下，材质将显示为一个球形，我们可以通过把该标签设置为”Plane”，”SkyBox”来改变预览模型</td>\n<td style=\"text-align:left\">Tags{“PreviewType”=”Plane”}</td>\n</tr>\n</tbody>\n</table>\n<p>上诉Tags仅可以在SubShader中声明，而不可以在Pass中声明。Pass块中也有标签可以定义，但它们不同于SubShader的标签类型。</p>\n<blockquote>\n<p>Pass语义块</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pass &#123;</span><br><span class=\"line\">    [Name]</span><br><span class=\"line\">    [Tags]</span><br><span class=\"line\">    [RenderSetup]</span><br><span class=\"line\">    <span class=\"comment\">//other Code</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Name “MyPassName”</p>\n</blockquote>\n<p>通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass。如：</p>\n<blockquote>\n<p>UsePass “MyShader/MYPASSNAME”</p>\n</blockquote>\n<p>这样可以提高代码复用率，但需要注意的是，Unity内部会把所有Pass名字转换为大写字母表示，因此使用UsePass命令时，必须使用大写形式的名字。</p>\n<p>其次，Pass也可以设置渲染状态(RenderSetup)与标签(Tags)，渲染状态可以使用SubShader中支持的渲染状态，还可以使用固定管线的着色器命令。</p>\n<p>Pass同样可以设置标签，但其标签不同于SubShader标签，Pass中支持的标签如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">标签类型</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">例子</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">LightMode</td>\n<td style=\"text-align:left\">定义该Pass在Unity渲染流水线中的角色</td>\n<td style=\"text-align:left\">Tags{“LightMode”=”ForwardBase”}</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">RequireOptions</td>\n<td style=\"text-align:left\">用于指定当满足某些条件时才渲染该Pass</td>\n<td style=\"text-align:left\">Tags{“RequireOptions”=”SoftVegetation”}</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"3-4-Fallback\"><a href=\"#3-4-Fallback\" class=\"headerlink\" title=\"3.4 Fallback\"></a>3.4 Fallback</h4><p>紧跟在Unity Shader后面的是一个Fallback语句，它是最后一道保险，即如果所有的SubShader都不能用的话，就使用这个吧。语义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fallback <span class=\"string\">\"name\"</span></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">Fallback off</span><br></pre></td></tr></table></figure></p>\n<p>综上所述，我们可以通过一个字符串来指明这个”最后的Shader”，当然你也可以”宁缺毋滥”——不能按我的意思渲染的话，那就不要管它了。但是啊，FallBack还会影响阴影的投射，在渲染阴影纹理时，Unity会在每个Unity Shader中寻找一个阴影投影的Pass，通常情况下我们不需要自己去实现一个这样的Pass，这是因为Fallback使用的内置Shader中往往包含了一个这样的通用Pass，因此为每个Unity Shader设置好Fallback还是十分重要的。</p>\n<h3 id=\"4-CG-HLSL\"><a href=\"#4-CG-HLSL\" class=\"headerlink\" title=\"4.CG/HLSL\"></a>4.CG/HLSL</h3><p>目前，我们基本理解了一个Unity Shader的结构了，Properties里面定义属性，在SubShader中写真正的着色器代码。</p>\n<p>好了，还记得Unity提供给我们的四种Unity Shader模板么？实际上那便对应了Unity Shader的两个不同类型：表面着色器(Surface Shader)与顶点/片元着色器(Vertex/Fragment Shader)</p>\n<p>我们来看一个非常简单的表面着色器代码(Surface Shader)<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/Simple Surface Shader\"</span>&#123;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        Tags&#123;<span class=\"string\">\"RenderType\"</span>=<span class=\"string\">\"Opaque\"</span>&#125;</span><br><span class=\"line\">        CGPROGRAM</span><br><span class=\"line\">        #Pragma surface surf Lambert</span><br><span class=\"line\">        struct Input&#123;</span><br><span class=\"line\">            float4 color : COLOR;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">surf</span> <span class=\"params\">(Input IN,inout surfaceOutput o)</span></span>&#123;</span><br><span class=\"line\">            o.Albedo = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ENDCG</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback <span class=\"string\">\"Diffuse\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再来看一个非常简单的顶点/片元着色器(Vertex/Fragment Shader)<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader <span class=\"string\">\"Custom/Simple VertexFragment Shader\"</span>&#123;</span><br><span class=\"line\">    SubShader&#123;</span><br><span class=\"line\">        Pass&#123;</span><br><span class=\"line\">            CGProGRAM</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> vertex vert</span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> fragment frag</span></span><br><span class=\"line\"></span><br><span class=\"line\">            float4 vert(float4 v : POSITION) : SV_POSITION&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mul (UNITY_MATRIX_MVP, v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            fixed4 frag() : SV_Target&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fixed4(<span class=\"number\">1.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ENDCG</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就是Unity Shader的两种不同形式</p>\n<ul>\n<li>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型，其所需要的代码量很少，Unity在背后做了很多工作，但渲染的代价比较大。其本质还是顶点/片元着色器，实际上就是顶点/片元着色器更高一层的抽象。它存在的价值在于为开发者处理了很多很多的光照细节，使得开发者不需要操心这些事情。</li>\n</ul>\n<blockquote>\n<p>表面着色器被定义在<strong>SubShader语义块(而非Pass语义块)</strong>中的CGPROGRAM与ENDCG之间，原因是表面着色器不关心开发者用多少个Pass，每个Pass如何渲染等问题，Unity会在背后做好这些事情。开发者所需要做的，就只是简单地告诉Surface Shader用”这个纹理”去填充颜色，用”这个法线纹理”去填充法线，使用光照模型等。具体细节不用关系。</p>\n</blockquote>\n<ul>\n<li>顶点/片元着色器(Vertex/Fragment Shader)则更加复杂，灵活性也更高。</li>\n</ul>\n<blockquote>\n<p>和表面着色器类似，顶点/片元着色器地代码也需要定义在CGPROGRAM与ENDCG之间，但不同地是，顶点/片元着色器是写在<strong>Pass语义块内(而非SubShader内)</strong>。因此，我们需要自己定义每个Pass需要使用地Shader代码，可以控制渲染的实现细节。</p>\n</blockquote>\n<p>那么CGPROGRAM与ENDCG之间是什么呢？首先我们要了解一下当下主流的几种Shader Language(SL):</p>\n<blockquote>\n<p>目前主流的Shader Language有3种语言</p>\n<ul>\n<li>GLSL：基于OpenGL的OpenGL Shading Language，简称GLSL</li>\n<li>HLSL: 基于DirectX的High Level Shading Language,简称HLSL</li>\n<li>Cg语言: NVIDIA公司的C for Graphic，简称Cg语言。</li>\n</ul>\n</blockquote>\n<p>因此，我们需要把CG/HLSL的语言嵌套在ShaderLab语言之中，值得注意的是，此处的CG/HLSL是Unity经过封装后的，但其语法和标准的CG/HLSL语法几乎一模一样，只有部分原生的函数和用法没有支持，感觉和当时的JavaScript和UnityScript感觉很类似。而且由于CG与DX9风格的HLSL从写法上而言几乎是同一种语言，因此在Unity里CG与HLSL是等价的。同样的，ShaderLab也支持内嵌GLSL的！<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CGPROGRAM</span><br><span class=\"line\">    <span class=\"comment\">// CG/HLSL代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 支持平台：PC，Xbox360等等</span></span><br><span class=\"line\">ENDCG</span><br><span class=\"line\"></span><br><span class=\"line\">GLSLPROGRAM</span><br><span class=\"line\">    <span class=\"comment\">// GLSL代码</span></span><br><span class=\"line\">    <span class=\"comment\">// 支持平台：Mac OS X，OpenGL ES2.0，Linux</span></span><br><span class=\"line\">ENDGLSL</span><br></pre></td></tr></table></figure></p>\n<p>OK，现在基本的Unity Shader知识储备就差不多了，欢迎进入Shader的世界~</p>\n<h3 id=\"5-几大SL的爱恨情仇\"><a href=\"#5-几大SL的爱恨情仇\" class=\"headerlink\" title=\"5.几大SL的爱恨情仇\"></a>5.几大SL的爱恨情仇</h3><p>摘抄自《GPU Programming And Cg Language Primer 1rd Edition》 中文名《GPU编程与CG语言之阳春白雪下里巴人》</p>\n<blockquote>\n<p>Shader language目前有3种主流语言：基于OpenGL的GLSL（OpenGL Shading Language，也称为GLslang），基于Direct3D的HLSL（High Level Shading Language），还有NVIDIA公司的Cg （C for Graphic）语言。<br>GLSL与HLSL分别提基于OpenGL和Direct3D的接口，两者不能混用，事实上OpenGL和Direct3D一直都是冤家对头，曹操和刘备还有一段和平共处的甜美时光，但OpenGL和Direct3D各自的东家则从来都是争斗不休。争斗良久，既然没有分出胜负，那么必然是两败俱伤的局面。</p>\n</blockquote>\n<blockquote>\n<p>首先ATI系列显卡对OpenGL扩展支持不够，例如我在使用OSG（Open Scene Graphic）开源图形引擎时，由于该引擎完全基于OpenGL，导致其上编写的3D仿真程序在较老的显卡上常常出现纹理无法显示的问题。其次GLSL 的语法体系自成一家，而HLSL和Cg语言的语法基本相同，这就意味着，只要学习HLSL和Cg中的任何一种，就等同于学习了两种语言。不过OpenGL 毕竟图形API的曾经领袖，通常介绍OpenGL都会附加上一句“事实上的工业标准”，所以在其长期发展中积累下的用户群庞大，这些用户当然会选择 GLSL学习。此外，GLSL继承了OpenGL的良好移植性，一度在unix等操作系统上独领风骚（已是曾经的往事）。</p>\n</blockquote>\n<blockquote>\n<p>微软的HLSL移植性较差，在windows平台上可谓一家独大，可一出自己的院子（还好院子够大），就是落地凤凰不如鸡。这一点在很大程度上限制了 HLSL的推广和发展。目前HLSL多半都是用于游戏领域。我可以负责任的断言，在Shader language领域，HLSL可以凭借微软的老本成为割据一方的诸侯，但，决不可能成为君临天下的霸主。这和微软现在的局面很像，就是一个被带刺鲜花簇拥着的大财主，富贵已极，寸步难行。</p>\n</blockquote>\n<blockquote>\n<p>上面两个大佬打的很热烈，在这种情况下可以用一句俗话来形容，“鹬蚌相争，渔翁得利”。NVIDIA是现在当之无愧的显卡之王（尤其在AMD兼并ATI之后），是GPU编程理论的奠基者，GeForce系列显卡早已深入人心，它推出的Cg语言已经取得了巨大的成功，生生形成了三足鼎立之势。NVIDIA公司深通广告之道，目前最流行的GPU编程精粹一书就出自该公司，书中不但介绍了大量的GPU前沿知识，最重要的是大部分都用Cg语言实现。凭借该系列的书籍，NVIDIA不光确定了在青年学子间的学术地位，而且成功的推广了Cg语言。</p>\n</blockquote>\n<h3 id=\"6-Unity与Cg-HLSL\"><a href=\"#6-Unity与Cg-HLSL\" class=\"headerlink\" title=\"6.Unity与Cg/HLSL\"></a>6.Unity与Cg/HLSL</h3><blockquote>\n<p>Unity官方手册上讲Shader程序嵌入的小片段是用Cg/HLSL编写的，从“CGPROGRAM”开始，到“CGEND”结束。所以，Unity官方主要是用Cg/HLSL编写Shader程序片段。Unity官方手册也说明对于Cg/HLSL程序进行扩展也可以使用GLSL，不过Unity官方建议使用原生的GLSL进行编写和测试。如果不使用原生GLSL，你就需要知道你的平台必须是Mac OS X、OpenGL ES 2.0以上的移动设备或者是Linux。在一般情况下Unity会把Cg/HLSL交叉编译成优化过的GLSL。因此我们有多种选择，我们既可以考虑使用Cg/HLSL，也可以使用GLSL。不过由于Cg/HLSL更好的跨平台性，更倾向于使用Cg/HLSL编写Shader程序。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjsok3v1o0000l8v6qp9kmk88","tag_id":"cjsok3v220002l8v6c7v5yvfz","_id":"cjsok3v2b0007l8v6t38f56mu"},{"post_id":"cjsok3v1y0001l8v67r02usqq","tag_id":"cjsok3v2a0006l8v6sxqbjm7j","_id":"cjsok3v2g000cl8v60xe1owc3"},{"post_id":"cjsok3v240003l8v6l2ru25ac","tag_id":"cjsok3v2e000al8v6g0kw7ilz","_id":"cjsok3v2h000el8v6qa7p9kfb"},{"post_id":"cjsok3v260004l8v6mdqaa0x0","tag_id":"cjsok3v2h000dl8v6jzfbq9uz","_id":"cjsok3v2i000gl8v6qc63quml"},{"post_id":"cjsok3v270005l8v6ayct403z","tag_id":"cjsok3v2i000fl8v69kwnw49h","_id":"cjsok3v2j000il8v67zra7c7p"},{"post_id":"cjsok3v2b0008l8v6wyqhsmn8","tag_id":"cjsok3v2j000hl8v6z8vp6kc5","_id":"cjsok3v2l000kl8v65tz8ppuc"},{"post_id":"cjsok3v2d0009l8v6xtcuq1i9","tag_id":"cjsok3v2j000hl8v6z8vp6kc5","_id":"cjsok3v2n000ml8v6oub6law9"},{"post_id":"cjsok3v2f000bl8v6e7a24i86","tag_id":"cjsok3v2h000dl8v6jzfbq9uz","_id":"cjsok3v2n000nl8v6wlh67zd2"},{"post_id":"cjsok3v38000pl8v6wtp656iq","tag_id":"cjsok3v220002l8v6c7v5yvfz","_id":"cjsok3v3j000sl8v6li3h7rks"},{"post_id":"cjsok3v3f000rl8v660s7vw6s","tag_id":"cjsok3v220002l8v6c7v5yvfz","_id":"cjsok3v3k000tl8v6g50p0ykh"},{"post_id":"cjsok3v37000ol8v6w17q4588","tag_id":"cjsok3v3e000ql8v6h1czqn4n","_id":"cjsok3v3k000ul8v6snebbop5"},{"post_id":"cjsok3v3n000vl8v65apizx2l","tag_id":"cjsok3v3e000ql8v6h1czqn4n","_id":"cjsok3v3p000wl8v6kkdhfrbt"}],"Tag":[{"name":"Unity","_id":"cjsok3v220002l8v6c7v5yvfz"},{"name":"随笔","_id":"cjsok3v2a0006l8v6sxqbjm7j"},{"name":"Qt","_id":"cjsok3v2e000al8v6g0kw7ilz"},{"name":"游戏杂谈","_id":"cjsok3v2h000dl8v6jzfbq9uz"},{"name":"学习","_id":"cjsok3v2i000fl8v69kwnw49h"},{"name":"游戏观后感","_id":"cjsok3v2j000hl8v6z8vp6kc5"},{"name":"Unity Shader","_id":"cjsok3v3e000ql8v6h1czqn4n"}]}}